# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'AccessTokenAdminToken',
    'FederatedAlpineRepositoryMember',
    'FederatedBowerRepositoryMember',
    'FederatedCargoRepositoryMember',
    'FederatedChefRepositoryMember',
    'FederatedCocoapodsRepositoryMember',
    'FederatedComposerRepositoryMember',
    'FederatedConanRepositoryMember',
    'FederatedCondaRepositoryMember',
    'FederatedCranRepositoryMember',
    'FederatedDebianRepositoryMember',
    'FederatedDockerRepositoryMember',
    'FederatedGemsRepositoryMember',
    'FederatedGenericRepositoryMember',
    'FederatedGitltfsRepositoryMember',
    'FederatedGoRepositoryMember',
    'FederatedGradleRepositoryMember',
    'FederatedHelmRepositoryMember',
    'FederatedIvyRepositoryMember',
    'FederatedMavenRepositoryMember',
    'FederatedNpmRepositoryMember',
    'FederatedNugetRepositoryMember',
    'FederatedOpkgRepositoryMember',
    'FederatedPuppetRepositoryMember',
    'FederatedPypiRepositoryMember',
    'FederatedRpmRepositoryMember',
    'FederatedSbtRepositoryMember',
    'FederatedVagrantRepositoryMember',
    'OauthSettingsOauthProvider',
    'PermissionTargetBuild',
    'PermissionTargetBuildActions',
    'PermissionTargetBuildActionsGroup',
    'PermissionTargetBuildActionsUser',
    'PermissionTargetReleaseBundle',
    'PermissionTargetReleaseBundleActions',
    'PermissionTargetReleaseBundleActionsGroup',
    'PermissionTargetReleaseBundleActionsUser',
    'PermissionTargetRepo',
    'PermissionTargetRepoActions',
    'PermissionTargetRepoActionsGroup',
    'PermissionTargetRepoActionsUser',
    'PermissionTargetsBuild',
    'PermissionTargetsBuildActions',
    'PermissionTargetsBuildActionsGroup',
    'PermissionTargetsBuildActionsUser',
    'PermissionTargetsReleaseBundle',
    'PermissionTargetsReleaseBundleActions',
    'PermissionTargetsReleaseBundleActionsGroup',
    'PermissionTargetsReleaseBundleActionsUser',
    'PermissionTargetsRepo',
    'PermissionTargetsRepoActions',
    'PermissionTargetsRepoActionsGroup',
    'PermissionTargetsRepoActionsUser',
    'PushReplicationReplication',
    'RemoteCargoRepositoryContentSynchronisation',
    'RemoteDockerRepositoryContentSynchronisation',
    'RemoteHelmRepositoryContentSynchronisation',
    'RemoteNpmRepositoryContentSynchronisation',
    'RemotePypiRepositoryContentSynchronisation',
    'RemoteRepositoryContentSynchronisation',
    'ReplicationConfigReplication',
    'XrayPolicyRule',
    'XrayPolicyRuleActions',
    'XrayPolicyRuleActionsBlockDownload',
    'XrayPolicyRuleCriteria',
    'XrayPolicyRuleCriteriaCvssRange',
    'XrayWatchAssignedPolicy',
    'XrayWatchResource',
    'XrayWatchResourceFilter',
]

@pulumi.output_type
class AccessTokenAdminToken(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceId":
            suggest = "instance_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessTokenAdminToken. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessTokenAdminToken.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessTokenAdminToken.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_id: str):
        pulumi.set(__self__, "instance_id", instance_id)

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> str:
        return pulumi.get(self, "instance_id")


@pulumi.output_type
class FederatedAlpineRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedBowerRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedCargoRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedChefRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedCocoapodsRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedComposerRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedConanRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedCondaRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedCranRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedDebianRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedDockerRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedGemsRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedGenericRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedGitltfsRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedGoRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedGradleRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedHelmRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedIvyRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedMavenRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedNpmRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedNugetRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedOpkgRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedPuppetRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedPypiRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedRpmRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedSbtRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedVagrantRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class OauthSettingsOauthProvider(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiUrl":
            suggest = "api_url"
        elif key == "authUrl":
            suggest = "auth_url"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "tokenUrl":
            suggest = "token_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OauthSettingsOauthProvider. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OauthSettingsOauthProvider.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OauthSettingsOauthProvider.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_url: str,
                 auth_url: str,
                 client_id: str,
                 client_secret: str,
                 name: str,
                 token_url: str,
                 type: str,
                 enabled: Optional[bool] = None):
        """
        :param str api_url: OAuth user info endpoint for the IdP.
        :param str auth_url: OAuth authorization endpoint for the IdP.
        :param str client_id: OAuth client ID configured on the IdP.
        :param str client_secret: OAuth client secret configured on the IdP.
        :param str name: Name of the Artifactory OAuth provider.
        :param str token_url: OAuth token endpoint for the IdP.
        :param str type: Type of OAuth provider. (e.g., `github`, `google`, `cloudfoundry`, or `openId`)
        :param bool enabled: Enable the Artifactory OAuth provider.  Default value is `true`.
        """
        pulumi.set(__self__, "api_url", api_url)
        pulumi.set(__self__, "auth_url", auth_url)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "token_url", token_url)
        pulumi.set(__self__, "type", type)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="apiUrl")
    def api_url(self) -> str:
        """
        OAuth user info endpoint for the IdP.
        """
        return pulumi.get(self, "api_url")

    @property
    @pulumi.getter(name="authUrl")
    def auth_url(self) -> str:
        """
        OAuth authorization endpoint for the IdP.
        """
        return pulumi.get(self, "auth_url")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        OAuth client ID configured on the IdP.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        OAuth client secret configured on the IdP.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the Artifactory OAuth provider.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="tokenUrl")
    def token_url(self) -> str:
        """
        OAuth token endpoint for the IdP.
        """
        return pulumi.get(self, "token_url")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of OAuth provider. (e.g., `github`, `google`, `cloudfoundry`, or `openId`)
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Enable the Artifactory OAuth provider.  Default value is `true`.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class PermissionTargetBuild(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludesPatterns":
            suggest = "excludes_patterns"
        elif key == "includesPatterns":
            suggest = "includes_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PermissionTargetBuild. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PermissionTargetBuild.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PermissionTargetBuild.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 repositories: Sequence[str],
                 actions: Optional['outputs.PermissionTargetBuildActions'] = None,
                 excludes_patterns: Optional[Sequence[str]] = None,
                 includes_patterns: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] repositories: List of repositories this permission target is applicable for
        :param 'PermissionTargetBuildActionsArgs' actions: -
        :param Sequence[str] excludes_patterns: Pattern of artifacts to exclude
        :param Sequence[str] includes_patterns: Pattern of artifacts to include
        """
        pulumi.set(__self__, "repositories", repositories)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if excludes_patterns is not None:
            pulumi.set(__self__, "excludes_patterns", excludes_patterns)
        if includes_patterns is not None:
            pulumi.set(__self__, "includes_patterns", includes_patterns)

    @property
    @pulumi.getter
    def repositories(self) -> Sequence[str]:
        """
        List of repositories this permission target is applicable for
        """
        return pulumi.get(self, "repositories")

    @property
    @pulumi.getter
    def actions(self) -> Optional['outputs.PermissionTargetBuildActions']:
        """
        -
        """
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="excludesPatterns")
    def excludes_patterns(self) -> Optional[Sequence[str]]:
        """
        Pattern of artifacts to exclude
        """
        return pulumi.get(self, "excludes_patterns")

    @property
    @pulumi.getter(name="includesPatterns")
    def includes_patterns(self) -> Optional[Sequence[str]]:
        """
        Pattern of artifacts to include
        """
        return pulumi.get(self, "includes_patterns")


@pulumi.output_type
class PermissionTargetBuildActions(dict):
    def __init__(__self__, *,
                 groups: Optional[Sequence['outputs.PermissionTargetBuildActionsGroup']] = None,
                 users: Optional[Sequence['outputs.PermissionTargetBuildActionsUser']] = None):
        """
        :param Sequence['PermissionTargetBuildActionsGroupArgs'] groups: Groups this permission applies for.
        :param Sequence['PermissionTargetBuildActionsUserArgs'] users: Users this permission target applies for.
        """
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence['outputs.PermissionTargetBuildActionsGroup']]:
        """
        Groups this permission applies for.
        """
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def users(self) -> Optional[Sequence['outputs.PermissionTargetBuildActionsUser']]:
        """
        Users this permission target applies for.
        """
        return pulumi.get(self, "users")


@pulumi.output_type
class PermissionTargetBuildActionsGroup(dict):
    def __init__(__self__, *,
                 name: str,
                 permissions: Sequence[str]):
        """
        :param str name: Name of permission
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of permission
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def permissions(self) -> Sequence[str]:
        return pulumi.get(self, "permissions")


@pulumi.output_type
class PermissionTargetBuildActionsUser(dict):
    def __init__(__self__, *,
                 name: str,
                 permissions: Sequence[str]):
        """
        :param str name: Name of permission
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of permission
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def permissions(self) -> Sequence[str]:
        return pulumi.get(self, "permissions")


@pulumi.output_type
class PermissionTargetReleaseBundle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludesPatterns":
            suggest = "excludes_patterns"
        elif key == "includesPatterns":
            suggest = "includes_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PermissionTargetReleaseBundle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PermissionTargetReleaseBundle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PermissionTargetReleaseBundle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 repositories: Sequence[str],
                 actions: Optional['outputs.PermissionTargetReleaseBundleActions'] = None,
                 excludes_patterns: Optional[Sequence[str]] = None,
                 includes_patterns: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] repositories: List of repositories this permission target is applicable for
        :param 'PermissionTargetReleaseBundleActionsArgs' actions: -
        :param Sequence[str] excludes_patterns: Pattern of artifacts to exclude
        :param Sequence[str] includes_patterns: Pattern of artifacts to include
        """
        pulumi.set(__self__, "repositories", repositories)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if excludes_patterns is not None:
            pulumi.set(__self__, "excludes_patterns", excludes_patterns)
        if includes_patterns is not None:
            pulumi.set(__self__, "includes_patterns", includes_patterns)

    @property
    @pulumi.getter
    def repositories(self) -> Sequence[str]:
        """
        List of repositories this permission target is applicable for
        """
        return pulumi.get(self, "repositories")

    @property
    @pulumi.getter
    def actions(self) -> Optional['outputs.PermissionTargetReleaseBundleActions']:
        """
        -
        """
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="excludesPatterns")
    def excludes_patterns(self) -> Optional[Sequence[str]]:
        """
        Pattern of artifacts to exclude
        """
        return pulumi.get(self, "excludes_patterns")

    @property
    @pulumi.getter(name="includesPatterns")
    def includes_patterns(self) -> Optional[Sequence[str]]:
        """
        Pattern of artifacts to include
        """
        return pulumi.get(self, "includes_patterns")


@pulumi.output_type
class PermissionTargetReleaseBundleActions(dict):
    def __init__(__self__, *,
                 groups: Optional[Sequence['outputs.PermissionTargetReleaseBundleActionsGroup']] = None,
                 users: Optional[Sequence['outputs.PermissionTargetReleaseBundleActionsUser']] = None):
        """
        :param Sequence['PermissionTargetReleaseBundleActionsGroupArgs'] groups: Groups this permission applies for.
        :param Sequence['PermissionTargetReleaseBundleActionsUserArgs'] users: Users this permission target applies for.
        """
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence['outputs.PermissionTargetReleaseBundleActionsGroup']]:
        """
        Groups this permission applies for.
        """
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def users(self) -> Optional[Sequence['outputs.PermissionTargetReleaseBundleActionsUser']]:
        """
        Users this permission target applies for.
        """
        return pulumi.get(self, "users")


@pulumi.output_type
class PermissionTargetReleaseBundleActionsGroup(dict):
    def __init__(__self__, *,
                 name: str,
                 permissions: Sequence[str]):
        """
        :param str name: Name of permission
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of permission
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def permissions(self) -> Sequence[str]:
        return pulumi.get(self, "permissions")


@pulumi.output_type
class PermissionTargetReleaseBundleActionsUser(dict):
    def __init__(__self__, *,
                 name: str,
                 permissions: Sequence[str]):
        """
        :param str name: Name of permission
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of permission
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def permissions(self) -> Sequence[str]:
        return pulumi.get(self, "permissions")


@pulumi.output_type
class PermissionTargetRepo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludesPatterns":
            suggest = "excludes_patterns"
        elif key == "includesPatterns":
            suggest = "includes_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PermissionTargetRepo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PermissionTargetRepo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PermissionTargetRepo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 repositories: Sequence[str],
                 actions: Optional['outputs.PermissionTargetRepoActions'] = None,
                 excludes_patterns: Optional[Sequence[str]] = None,
                 includes_patterns: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] repositories: List of repositories this permission target is applicable for
        :param 'PermissionTargetRepoActionsArgs' actions: -
        :param Sequence[str] excludes_patterns: Pattern of artifacts to exclude
        :param Sequence[str] includes_patterns: Pattern of artifacts to include
        """
        pulumi.set(__self__, "repositories", repositories)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if excludes_patterns is not None:
            pulumi.set(__self__, "excludes_patterns", excludes_patterns)
        if includes_patterns is not None:
            pulumi.set(__self__, "includes_patterns", includes_patterns)

    @property
    @pulumi.getter
    def repositories(self) -> Sequence[str]:
        """
        List of repositories this permission target is applicable for
        """
        return pulumi.get(self, "repositories")

    @property
    @pulumi.getter
    def actions(self) -> Optional['outputs.PermissionTargetRepoActions']:
        """
        -
        """
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="excludesPatterns")
    def excludes_patterns(self) -> Optional[Sequence[str]]:
        """
        Pattern of artifacts to exclude
        """
        return pulumi.get(self, "excludes_patterns")

    @property
    @pulumi.getter(name="includesPatterns")
    def includes_patterns(self) -> Optional[Sequence[str]]:
        """
        Pattern of artifacts to include
        """
        return pulumi.get(self, "includes_patterns")


@pulumi.output_type
class PermissionTargetRepoActions(dict):
    def __init__(__self__, *,
                 groups: Optional[Sequence['outputs.PermissionTargetRepoActionsGroup']] = None,
                 users: Optional[Sequence['outputs.PermissionTargetRepoActionsUser']] = None):
        """
        :param Sequence['PermissionTargetRepoActionsGroupArgs'] groups: Groups this permission applies for.
        :param Sequence['PermissionTargetRepoActionsUserArgs'] users: Users this permission target applies for.
        """
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence['outputs.PermissionTargetRepoActionsGroup']]:
        """
        Groups this permission applies for.
        """
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def users(self) -> Optional[Sequence['outputs.PermissionTargetRepoActionsUser']]:
        """
        Users this permission target applies for.
        """
        return pulumi.get(self, "users")


@pulumi.output_type
class PermissionTargetRepoActionsGroup(dict):
    def __init__(__self__, *,
                 name: str,
                 permissions: Sequence[str]):
        """
        :param str name: Name of permission
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of permission
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def permissions(self) -> Sequence[str]:
        return pulumi.get(self, "permissions")


@pulumi.output_type
class PermissionTargetRepoActionsUser(dict):
    def __init__(__self__, *,
                 name: str,
                 permissions: Sequence[str]):
        """
        :param str name: Name of permission
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of permission
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def permissions(self) -> Sequence[str]:
        return pulumi.get(self, "permissions")


@pulumi.output_type
class PermissionTargetsBuild(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludesPatterns":
            suggest = "excludes_patterns"
        elif key == "includesPatterns":
            suggest = "includes_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PermissionTargetsBuild. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PermissionTargetsBuild.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PermissionTargetsBuild.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 repositories: Sequence[str],
                 actions: Optional['outputs.PermissionTargetsBuildActions'] = None,
                 excludes_patterns: Optional[Sequence[str]] = None,
                 includes_patterns: Optional[Sequence[str]] = None):
        pulumi.set(__self__, "repositories", repositories)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if excludes_patterns is not None:
            pulumi.set(__self__, "excludes_patterns", excludes_patterns)
        if includes_patterns is not None:
            pulumi.set(__self__, "includes_patterns", includes_patterns)

    @property
    @pulumi.getter
    def repositories(self) -> Sequence[str]:
        return pulumi.get(self, "repositories")

    @property
    @pulumi.getter
    def actions(self) -> Optional['outputs.PermissionTargetsBuildActions']:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="excludesPatterns")
    def excludes_patterns(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "excludes_patterns")

    @property
    @pulumi.getter(name="includesPatterns")
    def includes_patterns(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "includes_patterns")


@pulumi.output_type
class PermissionTargetsBuildActions(dict):
    def __init__(__self__, *,
                 groups: Optional[Sequence['outputs.PermissionTargetsBuildActionsGroup']] = None,
                 users: Optional[Sequence['outputs.PermissionTargetsBuildActionsUser']] = None):
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence['outputs.PermissionTargetsBuildActionsGroup']]:
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def users(self) -> Optional[Sequence['outputs.PermissionTargetsBuildActionsUser']]:
        return pulumi.get(self, "users")


@pulumi.output_type
class PermissionTargetsBuildActionsGroup(dict):
    def __init__(__self__, *,
                 name: str,
                 permissions: Sequence[str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def permissions(self) -> Sequence[str]:
        return pulumi.get(self, "permissions")


@pulumi.output_type
class PermissionTargetsBuildActionsUser(dict):
    def __init__(__self__, *,
                 name: str,
                 permissions: Sequence[str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def permissions(self) -> Sequence[str]:
        return pulumi.get(self, "permissions")


@pulumi.output_type
class PermissionTargetsReleaseBundle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludesPatterns":
            suggest = "excludes_patterns"
        elif key == "includesPatterns":
            suggest = "includes_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PermissionTargetsReleaseBundle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PermissionTargetsReleaseBundle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PermissionTargetsReleaseBundle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 repositories: Sequence[str],
                 actions: Optional['outputs.PermissionTargetsReleaseBundleActions'] = None,
                 excludes_patterns: Optional[Sequence[str]] = None,
                 includes_patterns: Optional[Sequence[str]] = None):
        pulumi.set(__self__, "repositories", repositories)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if excludes_patterns is not None:
            pulumi.set(__self__, "excludes_patterns", excludes_patterns)
        if includes_patterns is not None:
            pulumi.set(__self__, "includes_patterns", includes_patterns)

    @property
    @pulumi.getter
    def repositories(self) -> Sequence[str]:
        return pulumi.get(self, "repositories")

    @property
    @pulumi.getter
    def actions(self) -> Optional['outputs.PermissionTargetsReleaseBundleActions']:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="excludesPatterns")
    def excludes_patterns(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "excludes_patterns")

    @property
    @pulumi.getter(name="includesPatterns")
    def includes_patterns(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "includes_patterns")


@pulumi.output_type
class PermissionTargetsReleaseBundleActions(dict):
    def __init__(__self__, *,
                 groups: Optional[Sequence['outputs.PermissionTargetsReleaseBundleActionsGroup']] = None,
                 users: Optional[Sequence['outputs.PermissionTargetsReleaseBundleActionsUser']] = None):
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence['outputs.PermissionTargetsReleaseBundleActionsGroup']]:
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def users(self) -> Optional[Sequence['outputs.PermissionTargetsReleaseBundleActionsUser']]:
        return pulumi.get(self, "users")


@pulumi.output_type
class PermissionTargetsReleaseBundleActionsGroup(dict):
    def __init__(__self__, *,
                 name: str,
                 permissions: Sequence[str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def permissions(self) -> Sequence[str]:
        return pulumi.get(self, "permissions")


@pulumi.output_type
class PermissionTargetsReleaseBundleActionsUser(dict):
    def __init__(__self__, *,
                 name: str,
                 permissions: Sequence[str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def permissions(self) -> Sequence[str]:
        return pulumi.get(self, "permissions")


@pulumi.output_type
class PermissionTargetsRepo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludesPatterns":
            suggest = "excludes_patterns"
        elif key == "includesPatterns":
            suggest = "includes_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PermissionTargetsRepo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PermissionTargetsRepo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PermissionTargetsRepo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 repositories: Sequence[str],
                 actions: Optional['outputs.PermissionTargetsRepoActions'] = None,
                 excludes_patterns: Optional[Sequence[str]] = None,
                 includes_patterns: Optional[Sequence[str]] = None):
        pulumi.set(__self__, "repositories", repositories)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if excludes_patterns is not None:
            pulumi.set(__self__, "excludes_patterns", excludes_patterns)
        if includes_patterns is not None:
            pulumi.set(__self__, "includes_patterns", includes_patterns)

    @property
    @pulumi.getter
    def repositories(self) -> Sequence[str]:
        return pulumi.get(self, "repositories")

    @property
    @pulumi.getter
    def actions(self) -> Optional['outputs.PermissionTargetsRepoActions']:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="excludesPatterns")
    def excludes_patterns(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "excludes_patterns")

    @property
    @pulumi.getter(name="includesPatterns")
    def includes_patterns(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "includes_patterns")


@pulumi.output_type
class PermissionTargetsRepoActions(dict):
    def __init__(__self__, *,
                 groups: Optional[Sequence['outputs.PermissionTargetsRepoActionsGroup']] = None,
                 users: Optional[Sequence['outputs.PermissionTargetsRepoActionsUser']] = None):
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence['outputs.PermissionTargetsRepoActionsGroup']]:
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def users(self) -> Optional[Sequence['outputs.PermissionTargetsRepoActionsUser']]:
        return pulumi.get(self, "users")


@pulumi.output_type
class PermissionTargetsRepoActionsGroup(dict):
    def __init__(__self__, *,
                 name: str,
                 permissions: Sequence[str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def permissions(self) -> Sequence[str]:
        return pulumi.get(self, "permissions")


@pulumi.output_type
class PermissionTargetsRepoActionsUser(dict):
    def __init__(__self__, *,
                 name: str,
                 permissions: Sequence[str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def permissions(self) -> Sequence[str]:
        return pulumi.get(self, "permissions")


@pulumi.output_type
class PushReplicationReplication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pathPrefix":
            suggest = "path_prefix"
        elif key == "socketTimeoutMillis":
            suggest = "socket_timeout_millis"
        elif key == "syncDeletes":
            suggest = "sync_deletes"
        elif key == "syncProperties":
            suggest = "sync_properties"
        elif key == "syncStatistics":
            suggest = "sync_statistics"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PushReplicationReplication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PushReplicationReplication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PushReplicationReplication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 password: Optional[str] = None,
                 path_prefix: Optional[str] = None,
                 socket_timeout_millis: Optional[int] = None,
                 sync_deletes: Optional[bool] = None,
                 sync_properties: Optional[bool] = None,
                 sync_statistics: Optional[bool] = None,
                 url: Optional[str] = None,
                 username: Optional[str] = None):
        """
        :param str password: Requires password encryption to be turned off `POST /api/system/decrypt`
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if path_prefix is not None:
            pulumi.set(__self__, "path_prefix", path_prefix)
        if socket_timeout_millis is not None:
            pulumi.set(__self__, "socket_timeout_millis", socket_timeout_millis)
        if sync_deletes is not None:
            pulumi.set(__self__, "sync_deletes", sync_deletes)
        if sync_properties is not None:
            pulumi.set(__self__, "sync_properties", sync_properties)
        if sync_statistics is not None:
            pulumi.set(__self__, "sync_statistics", sync_statistics)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        Requires password encryption to be turned off `POST /api/system/decrypt`
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="pathPrefix")
    def path_prefix(self) -> Optional[str]:
        return pulumi.get(self, "path_prefix")

    @property
    @pulumi.getter(name="socketTimeoutMillis")
    def socket_timeout_millis(self) -> Optional[int]:
        return pulumi.get(self, "socket_timeout_millis")

    @property
    @pulumi.getter(name="syncDeletes")
    def sync_deletes(self) -> Optional[bool]:
        return pulumi.get(self, "sync_deletes")

    @property
    @pulumi.getter(name="syncProperties")
    def sync_properties(self) -> Optional[bool]:
        return pulumi.get(self, "sync_properties")

    @property
    @pulumi.getter(name="syncStatistics")
    def sync_statistics(self) -> Optional[bool]:
        return pulumi.get(self, "sync_statistics")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        return pulumi.get(self, "username")


@pulumi.output_type
class RemoteCargoRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteCargoRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteCargoRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteCargoRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteDockerRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteDockerRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteDockerRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteDockerRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteHelmRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteHelmRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteHelmRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteHelmRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteNpmRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteNpmRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteNpmRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteNpmRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemotePypiRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemotePypiRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemotePypiRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemotePypiRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteRepositoryContentSynchronisation(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ReplicationConfigReplication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pathPrefix":
            suggest = "path_prefix"
        elif key == "socketTimeoutMillis":
            suggest = "socket_timeout_millis"
        elif key == "syncDeletes":
            suggest = "sync_deletes"
        elif key == "syncProperties":
            suggest = "sync_properties"
        elif key == "syncStatistics":
            suggest = "sync_statistics"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReplicationConfigReplication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReplicationConfigReplication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReplicationConfigReplication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 password: Optional[str] = None,
                 path_prefix: Optional[str] = None,
                 socket_timeout_millis: Optional[int] = None,
                 sync_deletes: Optional[bool] = None,
                 sync_properties: Optional[bool] = None,
                 sync_statistics: Optional[bool] = None,
                 url: Optional[str] = None,
                 username: Optional[str] = None):
        """
        :param str password: Requires password encryption to be turned off `POST /api/system/decrypt`
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if path_prefix is not None:
            pulumi.set(__self__, "path_prefix", path_prefix)
        if socket_timeout_millis is not None:
            pulumi.set(__self__, "socket_timeout_millis", socket_timeout_millis)
        if sync_deletes is not None:
            pulumi.set(__self__, "sync_deletes", sync_deletes)
        if sync_properties is not None:
            pulumi.set(__self__, "sync_properties", sync_properties)
        if sync_statistics is not None:
            pulumi.set(__self__, "sync_statistics", sync_statistics)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        Requires password encryption to be turned off `POST /api/system/decrypt`
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="pathPrefix")
    def path_prefix(self) -> Optional[str]:
        return pulumi.get(self, "path_prefix")

    @property
    @pulumi.getter(name="socketTimeoutMillis")
    def socket_timeout_millis(self) -> Optional[int]:
        return pulumi.get(self, "socket_timeout_millis")

    @property
    @pulumi.getter(name="syncDeletes")
    def sync_deletes(self) -> Optional[bool]:
        return pulumi.get(self, "sync_deletes")

    @property
    @pulumi.getter(name="syncProperties")
    def sync_properties(self) -> Optional[bool]:
        return pulumi.get(self, "sync_properties")

    @property
    @pulumi.getter(name="syncStatistics")
    def sync_statistics(self) -> Optional[bool]:
        return pulumi.get(self, "sync_statistics")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        return pulumi.get(self, "username")


@pulumi.output_type
class XrayPolicyRule(dict):
    def __init__(__self__, *,
                 criteria: 'outputs.XrayPolicyRuleCriteria',
                 name: str,
                 priority: int,
                 actions: Optional['outputs.XrayPolicyRuleActions'] = None):
        """
        :param 'XrayPolicyRuleCriteriaArgs' criteria: (Required) Nested block describing the criteria for the policy. Described below.
        :param str name: (Required) Name of the rule
        :param int priority: (Required) Integer describing the rule priority
        :param 'XrayPolicyRuleActionsArgs' actions: (Required) Nested block describing the actions to be applied by the policy. Described below.
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)

    @property
    @pulumi.getter
    def criteria(self) -> 'outputs.XrayPolicyRuleCriteria':
        """
        (Required) Nested block describing the criteria for the policy. Described below.
        """
        return pulumi.get(self, "criteria")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        (Required) Name of the rule
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        (Required) Integer describing the rule priority
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def actions(self) -> Optional['outputs.XrayPolicyRuleActions']:
        """
        (Required) Nested block describing the actions to be applied by the policy. Described below.
        """
        return pulumi.get(self, "actions")


@pulumi.output_type
class XrayPolicyRuleActions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blockDownload":
            suggest = "block_download"
        elif key == "customSeverity":
            suggest = "custom_severity"
        elif key == "failBuild":
            suggest = "fail_build"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in XrayPolicyRuleActions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        XrayPolicyRuleActions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        XrayPolicyRuleActions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 block_download: 'outputs.XrayPolicyRuleActionsBlockDownload',
                 custom_severity: Optional[str] = None,
                 fail_build: Optional[bool] = None,
                 mails: Optional[Sequence[str]] = None,
                 webhooks: Optional[Sequence[str]] = None):
        """
        :param 'XrayPolicyRuleActionsBlockDownloadArgs' block_download: (Optional) Nested block describing artifacts that should be blocked for download if a violation is triggered. Described below.
        :param str custom_severity: (Optional) The severity of violation to be triggered if the `criteria` are met.
        :param bool fail_build: (Optional) Whether or not the related CI build should be marked as failed if a violation is triggered. This option is only available when the policy is applied to an `xray_watch` resource with a `type` of `builds`.
        :param Sequence[str] mails: (Optional) A list of email addressed that will get emailed when a violation is triggered.
        :param Sequence[str] webhooks: (Optional) A list of Xray-configured webhook URLs to be invoked if a violation is triggered.
        """
        pulumi.set(__self__, "block_download", block_download)
        if custom_severity is not None:
            pulumi.set(__self__, "custom_severity", custom_severity)
        if fail_build is not None:
            pulumi.set(__self__, "fail_build", fail_build)
        if mails is not None:
            pulumi.set(__self__, "mails", mails)
        if webhooks is not None:
            pulumi.set(__self__, "webhooks", webhooks)

    @property
    @pulumi.getter(name="blockDownload")
    def block_download(self) -> 'outputs.XrayPolicyRuleActionsBlockDownload':
        """
        (Optional) Nested block describing artifacts that should be blocked for download if a violation is triggered. Described below.
        """
        return pulumi.get(self, "block_download")

    @property
    @pulumi.getter(name="customSeverity")
    def custom_severity(self) -> Optional[str]:
        """
        (Optional) The severity of violation to be triggered if the `criteria` are met.
        """
        return pulumi.get(self, "custom_severity")

    @property
    @pulumi.getter(name="failBuild")
    def fail_build(self) -> Optional[bool]:
        """
        (Optional) Whether or not the related CI build should be marked as failed if a violation is triggered. This option is only available when the policy is applied to an `xray_watch` resource with a `type` of `builds`.
        """
        return pulumi.get(self, "fail_build")

    @property
    @pulumi.getter
    def mails(self) -> Optional[Sequence[str]]:
        """
        (Optional) A list of email addressed that will get emailed when a violation is triggered.
        """
        return pulumi.get(self, "mails")

    @property
    @pulumi.getter
    def webhooks(self) -> Optional[Sequence[str]]:
        """
        (Optional) A list of Xray-configured webhook URLs to be invoked if a violation is triggered.
        """
        return pulumi.get(self, "webhooks")


@pulumi.output_type
class XrayPolicyRuleActionsBlockDownload(dict):
    def __init__(__self__, *,
                 active: bool,
                 unscanned: bool):
        """
        :param bool active: Whether or not to block download of artifacts that meet the artifact and severity `filters` for the associated `xray_watch` resource.
        :param bool unscanned: Whether or not to block download of artifacts that meet the artifact `filters` for the associated `xray_watch` resource but have not been scanned yet.
        """
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "unscanned", unscanned)

    @property
    @pulumi.getter
    def active(self) -> bool:
        """
        Whether or not to block download of artifacts that meet the artifact and severity `filters` for the associated `xray_watch` resource.
        """
        return pulumi.get(self, "active")

    @property
    @pulumi.getter
    def unscanned(self) -> bool:
        """
        Whether or not to block download of artifacts that meet the artifact `filters` for the associated `xray_watch` resource but have not been scanned yet.
        """
        return pulumi.get(self, "unscanned")


@pulumi.output_type
class XrayPolicyRuleCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowUnknown":
            suggest = "allow_unknown"
        elif key == "allowedLicenses":
            suggest = "allowed_licenses"
        elif key == "bannedLicenses":
            suggest = "banned_licenses"
        elif key == "cvssRange":
            suggest = "cvss_range"
        elif key == "minSeverity":
            suggest = "min_severity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in XrayPolicyRuleCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        XrayPolicyRuleCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        XrayPolicyRuleCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_unknown: Optional[bool] = None,
                 allowed_licenses: Optional[Sequence[str]] = None,
                 banned_licenses: Optional[Sequence[str]] = None,
                 cvss_range: Optional['outputs.XrayPolicyRuleCriteriaCvssRange'] = None,
                 min_severity: Optional[str] = None):
        """
        :param bool allow_unknown: (Optional) Whether or not to allow components whose license cannot be determined (`true` or `false`).
        :param Sequence[str] allowed_licenses: (Optional) A list of OSS license names that may be attached to a component.
        :param Sequence[str] banned_licenses: (Optional) A list of OSS license names that may not be attached to a component.
        :param 'XrayPolicyRuleCriteriaCvssRangeArgs' cvss_range: (Optional) Nested block describing a CVS score range to be impacted. Defined below.
        :param str min_severity: (Optional) The minimum security vulnerability severity that will be impacted by the policy.
        """
        if allow_unknown is not None:
            pulumi.set(__self__, "allow_unknown", allow_unknown)
        if allowed_licenses is not None:
            pulumi.set(__self__, "allowed_licenses", allowed_licenses)
        if banned_licenses is not None:
            pulumi.set(__self__, "banned_licenses", banned_licenses)
        if cvss_range is not None:
            pulumi.set(__self__, "cvss_range", cvss_range)
        if min_severity is not None:
            pulumi.set(__self__, "min_severity", min_severity)

    @property
    @pulumi.getter(name="allowUnknown")
    def allow_unknown(self) -> Optional[bool]:
        """
        (Optional) Whether or not to allow components whose license cannot be determined (`true` or `false`).
        """
        return pulumi.get(self, "allow_unknown")

    @property
    @pulumi.getter(name="allowedLicenses")
    def allowed_licenses(self) -> Optional[Sequence[str]]:
        """
        (Optional) A list of OSS license names that may be attached to a component.
        """
        return pulumi.get(self, "allowed_licenses")

    @property
    @pulumi.getter(name="bannedLicenses")
    def banned_licenses(self) -> Optional[Sequence[str]]:
        """
        (Optional) A list of OSS license names that may not be attached to a component.
        """
        return pulumi.get(self, "banned_licenses")

    @property
    @pulumi.getter(name="cvssRange")
    def cvss_range(self) -> Optional['outputs.XrayPolicyRuleCriteriaCvssRange']:
        """
        (Optional) Nested block describing a CVS score range to be impacted. Defined below.
        """
        return pulumi.get(self, "cvss_range")

    @property
    @pulumi.getter(name="minSeverity")
    def min_severity(self) -> Optional[str]:
        """
        (Optional) The minimum security vulnerability severity that will be impacted by the policy.
        """
        return pulumi.get(self, "min_severity")


@pulumi.output_type
class XrayPolicyRuleCriteriaCvssRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in XrayPolicyRuleCriteriaCvssRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        XrayPolicyRuleCriteriaCvssRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        XrayPolicyRuleCriteriaCvssRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: int,
                 to: int):
        """
        :param int from_: (Required) The beginning of the range of CVS scores (from 1-10) to flag.
        :param int to: (Required) The end of the range of CVS scores (from 1-10) to flag.
        """
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> int:
        """
        (Required) The beginning of the range of CVS scores (from 1-10) to flag.
        """
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> int:
        """
        (Required) The end of the range of CVS scores (from 1-10) to flag.
        """
        return pulumi.get(self, "to")


@pulumi.output_type
class XrayWatchAssignedPolicy(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str):
        """
        :param str name: The name of the policy that will be applied
        :param str type: The type of the policy
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the policy that will be applied
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the policy
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class XrayWatchResource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "binMgrId":
            suggest = "bin_mgr_id"
        elif key == "repoType":
            suggest = "repo_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in XrayWatchResource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        XrayWatchResource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        XrayWatchResource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 type: str,
                 bin_mgr_id: Optional[str] = None,
                 filters: Optional[Sequence['outputs.XrayWatchResourceFilter']] = None,
                 repo_type: Optional[str] = None):
        """
        :param str name: A name describing the resource
        :param str type: Type of resource to be watched
        :param str bin_mgr_id: The ID number of a binary manager resource
        :param Sequence['XrayWatchResourceFilterArgs'] filters: Nested argument describing filters to be applied. Defined below.
        :param str repo_type: Type of repository (e.g. local or remote)
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if bin_mgr_id is not None:
            pulumi.set(__self__, "bin_mgr_id", bin_mgr_id)
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if repo_type is not None:
            pulumi.set(__self__, "repo_type", repo_type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A name describing the resource
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of resource to be watched
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="binMgrId")
    def bin_mgr_id(self) -> Optional[str]:
        """
        The ID number of a binary manager resource
        """
        return pulumi.get(self, "bin_mgr_id")

    @property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.XrayWatchResourceFilter']]:
        """
        Nested argument describing filters to be applied. Defined below.
        """
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter(name="repoType")
    def repo_type(self) -> Optional[str]:
        """
        Type of repository (e.g. local or remote)
        """
        return pulumi.get(self, "repo_type")


@pulumi.output_type
class XrayWatchResourceFilter(dict):
    def __init__(__self__, *,
                 type: str,
                 value: str):
        """
        :param str type: The type of filter, such as `regex` or `package-type`
        :param str value: The value of the filter, such as the text of the regex or name of the package type
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of filter, such as `regex` or `package-type`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value of the filter, such as the text of the regex or name of the package type
        """
        return pulumi.get(self, "value")


