# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'AccessTokenAdminToken',
    'ArtifactCustomWebhookCriteria',
    'ArtifactCustomWebhookHandler',
    'ArtifactPropertyCustomWebhookCriteria',
    'ArtifactPropertyCustomWebhookHandler',
    'ArtifactPropertyWebhookCriteria',
    'ArtifactPropertyWebhookHandler',
    'ArtifactWebhookCriteria',
    'ArtifactWebhookHandler',
    'ArtifactoryReleaseBundleCustomWebhookCriteria',
    'ArtifactoryReleaseBundleCustomWebhookHandler',
    'ArtifactoryReleaseBundleWebhookCriteria',
    'ArtifactoryReleaseBundleWebhookHandler',
    'BuildCustomWebhookCriteria',
    'BuildCustomWebhookHandler',
    'BuildWebhookCriteria',
    'BuildWebhookHandler',
    'DistributionCustomWebhookCriteria',
    'DistributionCustomWebhookHandler',
    'DistributionWebhookCriteria',
    'DistributionWebhookHandler',
    'DockerCustomWebhookCriteria',
    'DockerCustomWebhookHandler',
    'DockerWebhookCriteria',
    'DockerWebhookHandler',
    'FederatedAlpineRepositoryMember',
    'FederatedBowerRepositoryMember',
    'FederatedCargoRepositoryMember',
    'FederatedChefRepositoryMember',
    'FederatedCocoapodsRepositoryMember',
    'FederatedComposerRepositoryMember',
    'FederatedConanRepositoryMember',
    'FederatedCondaRepositoryMember',
    'FederatedCranRepositoryMember',
    'FederatedDebianRepositoryMember',
    'FederatedDockerRepositoryMember',
    'FederatedDockerV1RepositoryMember',
    'FederatedDockerV2RepositoryMember',
    'FederatedGemsRepositoryMember',
    'FederatedGenericRepositoryMember',
    'FederatedGitltfsRepositoryMember',
    'FederatedGoRepositoryMember',
    'FederatedGradleRepositoryMember',
    'FederatedHelmRepositoryMember',
    'FederatedIvyRepositoryMember',
    'FederatedMavenRepositoryMember',
    'FederatedNpmRepositoryMember',
    'FederatedNugetRepositoryMember',
    'FederatedOpkgRepositoryMember',
    'FederatedPuppetRepositoryMember',
    'FederatedPypiRepositoryMember',
    'FederatedRpmRepositoryMember',
    'FederatedSbtRepositoryMember',
    'FederatedSwiftRepositoryMember',
    'FederatedTerraformModuleRepositoryMember',
    'FederatedTerraformProviderRepositoryMember',
    'FederatedVagrantRepositoryMember',
    'LocalRepositoryMultiReplicationReplication',
    'OauthSettingsOauthProvider',
    'PermissionTargetBuild',
    'PermissionTargetBuildAction',
    'PermissionTargetBuildActionGroup',
    'PermissionTargetBuildActionUser',
    'PermissionTargetReleaseBundle',
    'PermissionTargetReleaseBundleAction',
    'PermissionTargetReleaseBundleActionGroup',
    'PermissionTargetReleaseBundleActionUser',
    'PermissionTargetRepo',
    'PermissionTargetRepoAction',
    'PermissionTargetRepoActionGroup',
    'PermissionTargetRepoActionUser',
    'PropertySetProperty',
    'PropertySetPropertyPredefinedValue',
    'PushReplicationReplication',
    'ReleaseBundleCustomWebhookCriteria',
    'ReleaseBundleCustomWebhookHandler',
    'ReleaseBundleWebhookCriteria',
    'ReleaseBundleWebhookHandler',
    'RemoteAlpineRepositoryContentSynchronisation',
    'RemoteBowerRepositoryContentSynchronisation',
    'RemoteCargoRepositoryContentSynchronisation',
    'RemoteChefRepositoryContentSynchronisation',
    'RemoteCocoapodsRepositoryContentSynchronisation',
    'RemoteComposerRepositoryContentSynchronisation',
    'RemoteConanRepositoryContentSynchronisation',
    'RemoteCondaRepositoryContentSynchronisation',
    'RemoteCranRepositoryContentSynchronisation',
    'RemoteDebianRepositoryContentSynchronisation',
    'RemoteDockerRepositoryContentSynchronisation',
    'RemoteGemsRepositoryContentSynchronisation',
    'RemoteGenericRepositoryContentSynchronisation',
    'RemoteGitlfsRepositoryContentSynchronisation',
    'RemoteGoRepositoryContentSynchronisation',
    'RemoteGradleRepositoryContentSynchronisation',
    'RemoteHelmRepositoryContentSynchronisation',
    'RemoteHuggingfacemlRepositoryContentSynchronisation',
    'RemoteIvyRepositoryContentSynchronisation',
    'RemoteMavenRepositoryContentSynchronisation',
    'RemoteNpmRepositoryContentSynchronisation',
    'RemoteNugetRepositoryContentSynchronisation',
    'RemoteOpkgRepositoryContentSynchronisation',
    'RemoteP2RepositoryContentSynchronisation',
    'RemotePubRepositoryContentSynchronisation',
    'RemotePuppetRepositoryContentSynchronisation',
    'RemotePypiRepositoryContentSynchronisation',
    'RemoteRpmRepositoryContentSynchronisation',
    'RemoteSbtRepositoryContentSynchronisation',
    'RemoteSwiftRepositoryContentSynchronisation',
    'RemoteTerraformRepositoryContentSynchronisation',
    'RemoteVcsRepositoryContentSynchronisation',
    'ReplicationConfigReplication',
    'GetFederatedAlpineRepositoryMemberResult',
    'GetFederatedBowerRepositoryMemberResult',
    'GetFederatedCargoRepositoryMemberResult',
    'GetFederatedChefRepositoryMemberResult',
    'GetFederatedCocoapodsRepositoryMemberResult',
    'GetFederatedComposerRepositoryMemberResult',
    'GetFederatedConanRepositoryMemberResult',
    'GetFederatedCondaRepositoryMemberResult',
    'GetFederatedCranRepositoryMemberResult',
    'GetFederatedDebianRepositoryMemberResult',
    'GetFederatedDockerRepositoryMemberResult',
    'GetFederatedDockerV1RepositoryMemberResult',
    'GetFederatedDockerV2RepositoryMemberResult',
    'GetFederatedGemsRepositoryMemberResult',
    'GetFederatedGenericRepositoryMemberResult',
    'GetFederatedGitlfsRepositoryMemberResult',
    'GetFederatedGoRepositoryMemberResult',
    'GetFederatedGradleRepositoryMemberResult',
    'GetFederatedHelmRepositoryMemberResult',
    'GetFederatedIvyRepositoryMemberResult',
    'GetFederatedMavenRepositoryMemberResult',
    'GetFederatedNpmRepositoryMemberResult',
    'GetFederatedNugetRepositoryMemberResult',
    'GetFederatedOpkgRepositoryMemberResult',
    'GetFederatedPuppetRepositoryMemberResult',
    'GetFederatedPypiRepositoryMemberResult',
    'GetFederatedRpmRepositoryMemberResult',
    'GetFederatedSbtRepositoryMemberResult',
    'GetFederatedSwiftRepositoryMemberResult',
    'GetFederatedTerraformModuleRepositoryMemberResult',
    'GetFederatedTerraformProviderRepositoryMemberResult',
    'GetFederatedVagrantRepositoryMemberResult',
    'GetPermissionTargetBuildResult',
    'GetPermissionTargetBuildActionsResult',
    'GetPermissionTargetBuildActionsGroupResult',
    'GetPermissionTargetBuildActionsUserResult',
    'GetPermissionTargetReleaseBundleResult',
    'GetPermissionTargetReleaseBundleActionsResult',
    'GetPermissionTargetReleaseBundleActionsGroupResult',
    'GetPermissionTargetReleaseBundleActionsUserResult',
    'GetPermissionTargetRepoResult',
    'GetPermissionTargetRepoActionsResult',
    'GetPermissionTargetRepoActionsGroupResult',
    'GetPermissionTargetRepoActionsUserResult',
    'GetRemoteAlpineRepositoryContentSynchronisationResult',
    'GetRemoteBowerRepositoryContentSynchronisationResult',
    'GetRemoteCargoRepositoryContentSynchronisationResult',
    'GetRemoteChefRepositoryContentSynchronisationResult',
    'GetRemoteCocoapodsRepositoryContentSynchronisationResult',
    'GetRemoteComposerRepositoryContentSynchronisationResult',
    'GetRemoteConanRepositoryContentSynchronisationResult',
    'GetRemoteCondaRepositoryContentSynchronisationResult',
    'GetRemoteCranRepositoryContentSynchronisationResult',
    'GetRemoteDebianRepositoryContentSynchronisationResult',
    'GetRemoteDockerRepositoryContentSynchronisationResult',
    'GetRemoteGemsRepositoryContentSynchronisationResult',
    'GetRemoteGenericRepositoryContentSynchronisationResult',
    'GetRemoteGitlfsRepositoryContentSynchronisationResult',
    'GetRemoteGoRepositoryContentSynchronisationResult',
    'GetRemoteGradleRepositoryContentSynchronisationResult',
    'GetRemoteHelmRepositoryContentSynchronisationResult',
    'GetRemoteIvyRepositoryContentSynchronisationResult',
    'GetRemoteMavenRepositoryContentSynchronisationResult',
    'GetRemoteNpmRepositoryContentSynchronisationResult',
    'GetRemoteNugetRepositoryContentSynchronisationResult',
    'GetRemoteOpkgRepositoryContentSynchronisationResult',
    'GetRemoteP2RepositoryContentSynchronisationResult',
    'GetRemotePubRepositoryContentSynchronisationResult',
    'GetRemotePuppetRepositoryContentSynchronisationResult',
    'GetRemotePypiRepositoryContentSynchronisationResult',
    'GetRemoteRpmRepositoryContentSynchronisationResult',
    'GetRemoteSbtRepositoryContentSynchronisationResult',
    'GetRemoteSwiftRepositoryContentSynchronisationResult',
    'GetRemoteTerraformRepositoryContentSynchronisationResult',
    'GetRemoteVcsRepositoryContentSynchronisationResult',
]

@pulumi.output_type
class AccessTokenAdminToken(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceId":
            suggest = "instance_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessTokenAdminToken. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessTokenAdminToken.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessTokenAdminToken.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_id: str):
        pulumi.set(__self__, "instance_id", instance_id)

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> str:
        return pulumi.get(self, "instance_id")


@pulumi.output_type
class ArtifactCustomWebhookCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyLocal":
            suggest = "any_local"
        elif key == "anyRemote":
            suggest = "any_remote"
        elif key == "repoKeys":
            suggest = "repo_keys"
        elif key == "excludePatterns":
            suggest = "exclude_patterns"
        elif key == "includePatterns":
            suggest = "include_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ArtifactCustomWebhookCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ArtifactCustomWebhookCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ArtifactCustomWebhookCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_local: bool,
                 any_remote: bool,
                 repo_keys: Sequence[str],
                 exclude_patterns: Optional[Sequence[str]] = None,
                 include_patterns: Optional[Sequence[str]] = None):
        """
        :param bool any_local: Trigger on any local repo.
        :param bool any_remote: Trigger on any remote repo.
        :param Sequence[str] repo_keys: Trigger on this list of repo keys.
        :param Sequence[str] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        :param Sequence[str] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        pulumi.set(__self__, "any_local", any_local)
        pulumi.set(__self__, "any_remote", any_remote)
        pulumi.set(__self__, "repo_keys", repo_keys)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @property
    @pulumi.getter(name="anyLocal")
    def any_local(self) -> bool:
        """
        Trigger on any local repo.
        """
        return pulumi.get(self, "any_local")

    @property
    @pulumi.getter(name="anyRemote")
    def any_remote(self) -> bool:
        """
        Trigger on any remote repo.
        """
        return pulumi.get(self, "any_remote")

    @property
    @pulumi.getter(name="repoKeys")
    def repo_keys(self) -> Sequence[str]:
        """
        Trigger on this list of repo keys.
        """
        return pulumi.get(self, "repo_keys")

    @property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[Sequence[str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "exclude_patterns")

    @property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[Sequence[str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "include_patterns")


@pulumi.output_type
class ArtifactCustomWebhookHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpHeaders":
            suggest = "http_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ArtifactCustomWebhookHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ArtifactCustomWebhookHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ArtifactCustomWebhookHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: str,
                 http_headers: Optional[Mapping[str, str]] = None,
                 payload: Optional[str] = None,
                 proxy: Optional[str] = None,
                 secrets: Optional[Mapping[str, str]] = None):
        """
        :param str url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param Mapping[str, str] http_headers: HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        :param str proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param Mapping[str, str] secrets: Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example: 
               
               ```python
               import pulumi
               ```
        """
        pulumi.set(__self__, "url", url)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Mapping[str, str]]:
        """
        HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        """
        return pulumi.get(self, "http_headers")

    @property
    @pulumi.getter
    def payload(self) -> Optional[str]:
        return pulumi.get(self, "payload")

    @property
    @pulumi.getter
    def proxy(self) -> Optional[str]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @property
    @pulumi.getter
    def secrets(self) -> Optional[Mapping[str, str]]:
        """
        Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example: 

        ```python
        import pulumi
        ```
        """
        return pulumi.get(self, "secrets")


@pulumi.output_type
class ArtifactPropertyCustomWebhookCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyLocal":
            suggest = "any_local"
        elif key == "anyRemote":
            suggest = "any_remote"
        elif key == "repoKeys":
            suggest = "repo_keys"
        elif key == "excludePatterns":
            suggest = "exclude_patterns"
        elif key == "includePatterns":
            suggest = "include_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ArtifactPropertyCustomWebhookCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ArtifactPropertyCustomWebhookCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ArtifactPropertyCustomWebhookCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_local: bool,
                 any_remote: bool,
                 repo_keys: Sequence[str],
                 exclude_patterns: Optional[Sequence[str]] = None,
                 include_patterns: Optional[Sequence[str]] = None):
        """
        :param bool any_local: Trigger on any local repo.
        :param bool any_remote: Trigger on any remote repo.
        :param Sequence[str] repo_keys: Trigger on this list of repo keys.
        :param Sequence[str] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        :param Sequence[str] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        pulumi.set(__self__, "any_local", any_local)
        pulumi.set(__self__, "any_remote", any_remote)
        pulumi.set(__self__, "repo_keys", repo_keys)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @property
    @pulumi.getter(name="anyLocal")
    def any_local(self) -> bool:
        """
        Trigger on any local repo.
        """
        return pulumi.get(self, "any_local")

    @property
    @pulumi.getter(name="anyRemote")
    def any_remote(self) -> bool:
        """
        Trigger on any remote repo.
        """
        return pulumi.get(self, "any_remote")

    @property
    @pulumi.getter(name="repoKeys")
    def repo_keys(self) -> Sequence[str]:
        """
        Trigger on this list of repo keys.
        """
        return pulumi.get(self, "repo_keys")

    @property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[Sequence[str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "exclude_patterns")

    @property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[Sequence[str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "include_patterns")


@pulumi.output_type
class ArtifactPropertyCustomWebhookHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpHeaders":
            suggest = "http_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ArtifactPropertyCustomWebhookHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ArtifactPropertyCustomWebhookHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ArtifactPropertyCustomWebhookHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: str,
                 http_headers: Optional[Mapping[str, str]] = None,
                 payload: Optional[str] = None,
                 proxy: Optional[str] = None,
                 secrets: Optional[Mapping[str, str]] = None):
        """
        :param str url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param Mapping[str, str] http_headers: HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        :param str proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param Mapping[str, str] secrets: Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
               
               ```python
               import pulumi
               ```
        """
        pulumi.set(__self__, "url", url)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Mapping[str, str]]:
        """
        HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        """
        return pulumi.get(self, "http_headers")

    @property
    @pulumi.getter
    def payload(self) -> Optional[str]:
        return pulumi.get(self, "payload")

    @property
    @pulumi.getter
    def proxy(self) -> Optional[str]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @property
    @pulumi.getter
    def secrets(self) -> Optional[Mapping[str, str]]:
        """
        Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:

        ```python
        import pulumi
        ```
        """
        return pulumi.get(self, "secrets")


@pulumi.output_type
class ArtifactPropertyWebhookCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyLocal":
            suggest = "any_local"
        elif key == "anyRemote":
            suggest = "any_remote"
        elif key == "repoKeys":
            suggest = "repo_keys"
        elif key == "excludePatterns":
            suggest = "exclude_patterns"
        elif key == "includePatterns":
            suggest = "include_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ArtifactPropertyWebhookCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ArtifactPropertyWebhookCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ArtifactPropertyWebhookCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_local: bool,
                 any_remote: bool,
                 repo_keys: Sequence[str],
                 exclude_patterns: Optional[Sequence[str]] = None,
                 include_patterns: Optional[Sequence[str]] = None):
        """
        :param bool any_local: Trigger on any local repo.
        :param bool any_remote: Trigger on any remote repo.
        :param Sequence[str] repo_keys: Trigger on this list of repo keys.
        :param Sequence[str] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        :param Sequence[str] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        pulumi.set(__self__, "any_local", any_local)
        pulumi.set(__self__, "any_remote", any_remote)
        pulumi.set(__self__, "repo_keys", repo_keys)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @property
    @pulumi.getter(name="anyLocal")
    def any_local(self) -> bool:
        """
        Trigger on any local repo.
        """
        return pulumi.get(self, "any_local")

    @property
    @pulumi.getter(name="anyRemote")
    def any_remote(self) -> bool:
        """
        Trigger on any remote repo.
        """
        return pulumi.get(self, "any_remote")

    @property
    @pulumi.getter(name="repoKeys")
    def repo_keys(self) -> Sequence[str]:
        """
        Trigger on this list of repo keys.
        """
        return pulumi.get(self, "repo_keys")

    @property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[Sequence[str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "exclude_patterns")

    @property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[Sequence[str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "include_patterns")


@pulumi.output_type
class ArtifactPropertyWebhookHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customHttpHeaders":
            suggest = "custom_http_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ArtifactPropertyWebhookHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ArtifactPropertyWebhookHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ArtifactPropertyWebhookHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: str,
                 custom_http_headers: Optional[Mapping[str, str]] = None,
                 proxy: Optional[str] = None,
                 secret: Optional[str] = None):
        """
        :param str url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param Mapping[str, str] custom_http_headers: Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        :param str proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param str secret: Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        pulumi.set(__self__, "url", url)
        if custom_http_headers is not None:
            pulumi.set(__self__, "custom_http_headers", custom_http_headers)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="customHttpHeaders")
    def custom_http_headers(self) -> Optional[Mapping[str, str]]:
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        return pulumi.get(self, "custom_http_headers")

    @property
    @pulumi.getter
    def proxy(self) -> Optional[str]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @property
    @pulumi.getter
    def secret(self) -> Optional[str]:
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class ArtifactWebhookCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyLocal":
            suggest = "any_local"
        elif key == "anyRemote":
            suggest = "any_remote"
        elif key == "repoKeys":
            suggest = "repo_keys"
        elif key == "excludePatterns":
            suggest = "exclude_patterns"
        elif key == "includePatterns":
            suggest = "include_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ArtifactWebhookCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ArtifactWebhookCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ArtifactWebhookCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_local: bool,
                 any_remote: bool,
                 repo_keys: Sequence[str],
                 exclude_patterns: Optional[Sequence[str]] = None,
                 include_patterns: Optional[Sequence[str]] = None):
        """
        :param bool any_local: Trigger on any local repo.
        :param bool any_remote: Trigger on any remote repo.
        :param Sequence[str] repo_keys: Trigger on this list of repo keys.
        :param Sequence[str] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        :param Sequence[str] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        pulumi.set(__self__, "any_local", any_local)
        pulumi.set(__self__, "any_remote", any_remote)
        pulumi.set(__self__, "repo_keys", repo_keys)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @property
    @pulumi.getter(name="anyLocal")
    def any_local(self) -> bool:
        """
        Trigger on any local repo.
        """
        return pulumi.get(self, "any_local")

    @property
    @pulumi.getter(name="anyRemote")
    def any_remote(self) -> bool:
        """
        Trigger on any remote repo.
        """
        return pulumi.get(self, "any_remote")

    @property
    @pulumi.getter(name="repoKeys")
    def repo_keys(self) -> Sequence[str]:
        """
        Trigger on this list of repo keys.
        """
        return pulumi.get(self, "repo_keys")

    @property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[Sequence[str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "exclude_patterns")

    @property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[Sequence[str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "include_patterns")


@pulumi.output_type
class ArtifactWebhookHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customHttpHeaders":
            suggest = "custom_http_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ArtifactWebhookHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ArtifactWebhookHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ArtifactWebhookHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: str,
                 custom_http_headers: Optional[Mapping[str, str]] = None,
                 proxy: Optional[str] = None,
                 secret: Optional[str] = None):
        """
        :param str url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param Mapping[str, str] custom_http_headers: Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        :param str proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param str secret: Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        pulumi.set(__self__, "url", url)
        if custom_http_headers is not None:
            pulumi.set(__self__, "custom_http_headers", custom_http_headers)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="customHttpHeaders")
    def custom_http_headers(self) -> Optional[Mapping[str, str]]:
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        return pulumi.get(self, "custom_http_headers")

    @property
    @pulumi.getter
    def proxy(self) -> Optional[str]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @property
    @pulumi.getter
    def secret(self) -> Optional[str]:
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class ArtifactoryReleaseBundleCustomWebhookCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyReleaseBundle":
            suggest = "any_release_bundle"
        elif key == "registeredReleaseBundleNames":
            suggest = "registered_release_bundle_names"
        elif key == "excludePatterns":
            suggest = "exclude_patterns"
        elif key == "includePatterns":
            suggest = "include_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ArtifactoryReleaseBundleCustomWebhookCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ArtifactoryReleaseBundleCustomWebhookCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ArtifactoryReleaseBundleCustomWebhookCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_release_bundle: bool,
                 registered_release_bundle_names: Sequence[str],
                 exclude_patterns: Optional[Sequence[str]] = None,
                 include_patterns: Optional[Sequence[str]] = None):
        """
        :param bool any_release_bundle: Trigger on any release bundle
        :param Sequence[str] registered_release_bundle_names: Trigger on this list of release bundle names
        :param Sequence[str] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`
        :param Sequence[str] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`
        """
        pulumi.set(__self__, "any_release_bundle", any_release_bundle)
        pulumi.set(__self__, "registered_release_bundle_names", registered_release_bundle_names)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @property
    @pulumi.getter(name="anyReleaseBundle")
    def any_release_bundle(self) -> bool:
        """
        Trigger on any release bundle
        """
        return pulumi.get(self, "any_release_bundle")

    @property
    @pulumi.getter(name="registeredReleaseBundleNames")
    def registered_release_bundle_names(self) -> Sequence[str]:
        """
        Trigger on this list of release bundle names
        """
        return pulumi.get(self, "registered_release_bundle_names")

    @property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[Sequence[str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`
        """
        return pulumi.get(self, "exclude_patterns")

    @property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[Sequence[str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`
        """
        return pulumi.get(self, "include_patterns")


@pulumi.output_type
class ArtifactoryReleaseBundleCustomWebhookHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpHeaders":
            suggest = "http_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ArtifactoryReleaseBundleCustomWebhookHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ArtifactoryReleaseBundleCustomWebhookHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ArtifactoryReleaseBundleCustomWebhookHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: str,
                 http_headers: Optional[Mapping[str, str]] = None,
                 payload: Optional[str] = None,
                 proxy: Optional[str] = None,
                 secrets: Optional[Mapping[str, str]] = None):
        """
        :param str url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param Mapping[str, str] http_headers: HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        :param str proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param Mapping[str, str] secrets: Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
               
               ```python
               import pulumi
               ```
        """
        pulumi.set(__self__, "url", url)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Mapping[str, str]]:
        """
        HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        """
        return pulumi.get(self, "http_headers")

    @property
    @pulumi.getter
    def payload(self) -> Optional[str]:
        return pulumi.get(self, "payload")

    @property
    @pulumi.getter
    def proxy(self) -> Optional[str]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @property
    @pulumi.getter
    def secrets(self) -> Optional[Mapping[str, str]]:
        """
        Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:

        ```python
        import pulumi
        ```
        """
        return pulumi.get(self, "secrets")


@pulumi.output_type
class ArtifactoryReleaseBundleWebhookCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyReleaseBundle":
            suggest = "any_release_bundle"
        elif key == "registeredReleaseBundleNames":
            suggest = "registered_release_bundle_names"
        elif key == "excludePatterns":
            suggest = "exclude_patterns"
        elif key == "includePatterns":
            suggest = "include_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ArtifactoryReleaseBundleWebhookCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ArtifactoryReleaseBundleWebhookCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ArtifactoryReleaseBundleWebhookCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_release_bundle: bool,
                 registered_release_bundle_names: Sequence[str],
                 exclude_patterns: Optional[Sequence[str]] = None,
                 include_patterns: Optional[Sequence[str]] = None):
        """
        :param bool any_release_bundle: Trigger on any release bundle
        :param Sequence[str] registered_release_bundle_names: Trigger on this list of release bundle names
        :param Sequence[str] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`
        :param Sequence[str] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`
        """
        pulumi.set(__self__, "any_release_bundle", any_release_bundle)
        pulumi.set(__self__, "registered_release_bundle_names", registered_release_bundle_names)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @property
    @pulumi.getter(name="anyReleaseBundle")
    def any_release_bundle(self) -> bool:
        """
        Trigger on any release bundle
        """
        return pulumi.get(self, "any_release_bundle")

    @property
    @pulumi.getter(name="registeredReleaseBundleNames")
    def registered_release_bundle_names(self) -> Sequence[str]:
        """
        Trigger on this list of release bundle names
        """
        return pulumi.get(self, "registered_release_bundle_names")

    @property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[Sequence[str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`
        """
        return pulumi.get(self, "exclude_patterns")

    @property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[Sequence[str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`
        """
        return pulumi.get(self, "include_patterns")


@pulumi.output_type
class ArtifactoryReleaseBundleWebhookHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customHttpHeaders":
            suggest = "custom_http_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ArtifactoryReleaseBundleWebhookHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ArtifactoryReleaseBundleWebhookHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ArtifactoryReleaseBundleWebhookHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: str,
                 custom_http_headers: Optional[Mapping[str, str]] = None,
                 proxy: Optional[str] = None,
                 secret: Optional[str] = None):
        """
        :param str url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param Mapping[str, str] custom_http_headers: Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        :param str proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param str secret: Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        pulumi.set(__self__, "url", url)
        if custom_http_headers is not None:
            pulumi.set(__self__, "custom_http_headers", custom_http_headers)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="customHttpHeaders")
    def custom_http_headers(self) -> Optional[Mapping[str, str]]:
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        return pulumi.get(self, "custom_http_headers")

    @property
    @pulumi.getter
    def proxy(self) -> Optional[str]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @property
    @pulumi.getter
    def secret(self) -> Optional[str]:
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class BuildCustomWebhookCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyBuild":
            suggest = "any_build"
        elif key == "selectedBuilds":
            suggest = "selected_builds"
        elif key == "excludePatterns":
            suggest = "exclude_patterns"
        elif key == "includePatterns":
            suggest = "include_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BuildCustomWebhookCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BuildCustomWebhookCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BuildCustomWebhookCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_build: bool,
                 selected_builds: Sequence[str],
                 exclude_patterns: Optional[Sequence[str]] = None,
                 include_patterns: Optional[Sequence[str]] = None):
        """
        :param bool any_build: Trigger on any build.
        :param Sequence[str] selected_builds: Trigger on this list of build names.
        :param Sequence[str] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        :param Sequence[str] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        pulumi.set(__self__, "any_build", any_build)
        pulumi.set(__self__, "selected_builds", selected_builds)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @property
    @pulumi.getter(name="anyBuild")
    def any_build(self) -> bool:
        """
        Trigger on any build.
        """
        return pulumi.get(self, "any_build")

    @property
    @pulumi.getter(name="selectedBuilds")
    def selected_builds(self) -> Sequence[str]:
        """
        Trigger on this list of build names.
        """
        return pulumi.get(self, "selected_builds")

    @property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[Sequence[str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "exclude_patterns")

    @property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[Sequence[str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "include_patterns")


@pulumi.output_type
class BuildCustomWebhookHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpHeaders":
            suggest = "http_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BuildCustomWebhookHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BuildCustomWebhookHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BuildCustomWebhookHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: str,
                 http_headers: Optional[Mapping[str, str]] = None,
                 payload: Optional[str] = None,
                 proxy: Optional[str] = None,
                 secrets: Optional[Mapping[str, str]] = None):
        """
        :param str url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param Mapping[str, str] http_headers: HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        :param str proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param Mapping[str, str] secrets: Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
               
               ```python
               import pulumi
               ```
        """
        pulumi.set(__self__, "url", url)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Mapping[str, str]]:
        """
        HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        """
        return pulumi.get(self, "http_headers")

    @property
    @pulumi.getter
    def payload(self) -> Optional[str]:
        return pulumi.get(self, "payload")

    @property
    @pulumi.getter
    def proxy(self) -> Optional[str]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @property
    @pulumi.getter
    def secrets(self) -> Optional[Mapping[str, str]]:
        """
        Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:

        ```python
        import pulumi
        ```
        """
        return pulumi.get(self, "secrets")


@pulumi.output_type
class BuildWebhookCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyBuild":
            suggest = "any_build"
        elif key == "selectedBuilds":
            suggest = "selected_builds"
        elif key == "excludePatterns":
            suggest = "exclude_patterns"
        elif key == "includePatterns":
            suggest = "include_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BuildWebhookCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BuildWebhookCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BuildWebhookCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_build: bool,
                 selected_builds: Sequence[str],
                 exclude_patterns: Optional[Sequence[str]] = None,
                 include_patterns: Optional[Sequence[str]] = None):
        """
        :param bool any_build: Trigger on any build.
        :param Sequence[str] selected_builds: Trigger on this list of build names.
        :param Sequence[str] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        :param Sequence[str] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        pulumi.set(__self__, "any_build", any_build)
        pulumi.set(__self__, "selected_builds", selected_builds)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @property
    @pulumi.getter(name="anyBuild")
    def any_build(self) -> bool:
        """
        Trigger on any build.
        """
        return pulumi.get(self, "any_build")

    @property
    @pulumi.getter(name="selectedBuilds")
    def selected_builds(self) -> Sequence[str]:
        """
        Trigger on this list of build names.
        """
        return pulumi.get(self, "selected_builds")

    @property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[Sequence[str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "exclude_patterns")

    @property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[Sequence[str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "include_patterns")


@pulumi.output_type
class BuildWebhookHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customHttpHeaders":
            suggest = "custom_http_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BuildWebhookHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BuildWebhookHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BuildWebhookHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: str,
                 custom_http_headers: Optional[Mapping[str, str]] = None,
                 proxy: Optional[str] = None,
                 secret: Optional[str] = None):
        """
        :param str url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param Mapping[str, str] custom_http_headers: Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        :param str proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param str secret: Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        pulumi.set(__self__, "url", url)
        if custom_http_headers is not None:
            pulumi.set(__self__, "custom_http_headers", custom_http_headers)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="customHttpHeaders")
    def custom_http_headers(self) -> Optional[Mapping[str, str]]:
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        return pulumi.get(self, "custom_http_headers")

    @property
    @pulumi.getter
    def proxy(self) -> Optional[str]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @property
    @pulumi.getter
    def secret(self) -> Optional[str]:
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class DistributionCustomWebhookCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyReleaseBundle":
            suggest = "any_release_bundle"
        elif key == "registeredReleaseBundleNames":
            suggest = "registered_release_bundle_names"
        elif key == "excludePatterns":
            suggest = "exclude_patterns"
        elif key == "includePatterns":
            suggest = "include_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DistributionCustomWebhookCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DistributionCustomWebhookCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DistributionCustomWebhookCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_release_bundle: bool,
                 registered_release_bundle_names: Sequence[str],
                 exclude_patterns: Optional[Sequence[str]] = None,
                 include_patterns: Optional[Sequence[str]] = None):
        """
        :param bool any_release_bundle: Trigger on any release bundle.
        :param Sequence[str] registered_release_bundle_names: Trigger on this list of release bundle names.
        :param Sequence[str] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        :param Sequence[str] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        pulumi.set(__self__, "any_release_bundle", any_release_bundle)
        pulumi.set(__self__, "registered_release_bundle_names", registered_release_bundle_names)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @property
    @pulumi.getter(name="anyReleaseBundle")
    def any_release_bundle(self) -> bool:
        """
        Trigger on any release bundle.
        """
        return pulumi.get(self, "any_release_bundle")

    @property
    @pulumi.getter(name="registeredReleaseBundleNames")
    def registered_release_bundle_names(self) -> Sequence[str]:
        """
        Trigger on this list of release bundle names.
        """
        return pulumi.get(self, "registered_release_bundle_names")

    @property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[Sequence[str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "exclude_patterns")

    @property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[Sequence[str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "include_patterns")


@pulumi.output_type
class DistributionCustomWebhookHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpHeaders":
            suggest = "http_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DistributionCustomWebhookHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DistributionCustomWebhookHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DistributionCustomWebhookHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: str,
                 http_headers: Optional[Mapping[str, str]] = None,
                 payload: Optional[str] = None,
                 proxy: Optional[str] = None,
                 secrets: Optional[Mapping[str, str]] = None):
        """
        :param str url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param Mapping[str, str] http_headers: HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        :param str proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param Mapping[str, str] secrets: Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
               
               ```python
               import pulumi
               ```
        """
        pulumi.set(__self__, "url", url)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Mapping[str, str]]:
        """
        HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        """
        return pulumi.get(self, "http_headers")

    @property
    @pulumi.getter
    def payload(self) -> Optional[str]:
        return pulumi.get(self, "payload")

    @property
    @pulumi.getter
    def proxy(self) -> Optional[str]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @property
    @pulumi.getter
    def secrets(self) -> Optional[Mapping[str, str]]:
        """
        Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:

        ```python
        import pulumi
        ```
        """
        return pulumi.get(self, "secrets")


@pulumi.output_type
class DistributionWebhookCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyReleaseBundle":
            suggest = "any_release_bundle"
        elif key == "registeredReleaseBundleNames":
            suggest = "registered_release_bundle_names"
        elif key == "excludePatterns":
            suggest = "exclude_patterns"
        elif key == "includePatterns":
            suggest = "include_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DistributionWebhookCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DistributionWebhookCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DistributionWebhookCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_release_bundle: bool,
                 registered_release_bundle_names: Sequence[str],
                 exclude_patterns: Optional[Sequence[str]] = None,
                 include_patterns: Optional[Sequence[str]] = None):
        """
        :param bool any_release_bundle: Trigger on any release bundle.
        :param Sequence[str] registered_release_bundle_names: Trigger on this list of release bundle names.
        :param Sequence[str] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        :param Sequence[str] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        pulumi.set(__self__, "any_release_bundle", any_release_bundle)
        pulumi.set(__self__, "registered_release_bundle_names", registered_release_bundle_names)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @property
    @pulumi.getter(name="anyReleaseBundle")
    def any_release_bundle(self) -> bool:
        """
        Trigger on any release bundle.
        """
        return pulumi.get(self, "any_release_bundle")

    @property
    @pulumi.getter(name="registeredReleaseBundleNames")
    def registered_release_bundle_names(self) -> Sequence[str]:
        """
        Trigger on this list of release bundle names.
        """
        return pulumi.get(self, "registered_release_bundle_names")

    @property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[Sequence[str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "exclude_patterns")

    @property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[Sequence[str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "include_patterns")


@pulumi.output_type
class DistributionWebhookHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customHttpHeaders":
            suggest = "custom_http_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DistributionWebhookHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DistributionWebhookHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DistributionWebhookHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: str,
                 custom_http_headers: Optional[Mapping[str, str]] = None,
                 proxy: Optional[str] = None,
                 secret: Optional[str] = None):
        """
        :param str url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param Mapping[str, str] custom_http_headers: Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        :param str proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param str secret: Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        pulumi.set(__self__, "url", url)
        if custom_http_headers is not None:
            pulumi.set(__self__, "custom_http_headers", custom_http_headers)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="customHttpHeaders")
    def custom_http_headers(self) -> Optional[Mapping[str, str]]:
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        return pulumi.get(self, "custom_http_headers")

    @property
    @pulumi.getter
    def proxy(self) -> Optional[str]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @property
    @pulumi.getter
    def secret(self) -> Optional[str]:
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class DockerCustomWebhookCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyLocal":
            suggest = "any_local"
        elif key == "anyRemote":
            suggest = "any_remote"
        elif key == "repoKeys":
            suggest = "repo_keys"
        elif key == "excludePatterns":
            suggest = "exclude_patterns"
        elif key == "includePatterns":
            suggest = "include_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DockerCustomWebhookCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DockerCustomWebhookCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DockerCustomWebhookCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_local: bool,
                 any_remote: bool,
                 repo_keys: Sequence[str],
                 exclude_patterns: Optional[Sequence[str]] = None,
                 include_patterns: Optional[Sequence[str]] = None):
        """
        :param bool any_local: Trigger on any local repo.
        :param bool any_remote: Trigger on any remote repo.
        :param Sequence[str] repo_keys: Trigger on this list of repo keys.
        :param Sequence[str] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        :param Sequence[str] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        pulumi.set(__self__, "any_local", any_local)
        pulumi.set(__self__, "any_remote", any_remote)
        pulumi.set(__self__, "repo_keys", repo_keys)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @property
    @pulumi.getter(name="anyLocal")
    def any_local(self) -> bool:
        """
        Trigger on any local repo.
        """
        return pulumi.get(self, "any_local")

    @property
    @pulumi.getter(name="anyRemote")
    def any_remote(self) -> bool:
        """
        Trigger on any remote repo.
        """
        return pulumi.get(self, "any_remote")

    @property
    @pulumi.getter(name="repoKeys")
    def repo_keys(self) -> Sequence[str]:
        """
        Trigger on this list of repo keys.
        """
        return pulumi.get(self, "repo_keys")

    @property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[Sequence[str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "exclude_patterns")

    @property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[Sequence[str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "include_patterns")


@pulumi.output_type
class DockerCustomWebhookHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpHeaders":
            suggest = "http_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DockerCustomWebhookHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DockerCustomWebhookHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DockerCustomWebhookHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: str,
                 http_headers: Optional[Mapping[str, str]] = None,
                 payload: Optional[str] = None,
                 proxy: Optional[str] = None,
                 secrets: Optional[Mapping[str, str]] = None):
        """
        :param str url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param Mapping[str, str] http_headers: HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        :param str proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param Mapping[str, str] secrets: Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
               
               ```python
               import pulumi
               ```
        """
        pulumi.set(__self__, "url", url)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Mapping[str, str]]:
        """
        HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        """
        return pulumi.get(self, "http_headers")

    @property
    @pulumi.getter
    def payload(self) -> Optional[str]:
        return pulumi.get(self, "payload")

    @property
    @pulumi.getter
    def proxy(self) -> Optional[str]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @property
    @pulumi.getter
    def secrets(self) -> Optional[Mapping[str, str]]:
        """
        Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:

        ```python
        import pulumi
        ```
        """
        return pulumi.get(self, "secrets")


@pulumi.output_type
class DockerWebhookCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyLocal":
            suggest = "any_local"
        elif key == "anyRemote":
            suggest = "any_remote"
        elif key == "repoKeys":
            suggest = "repo_keys"
        elif key == "excludePatterns":
            suggest = "exclude_patterns"
        elif key == "includePatterns":
            suggest = "include_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DockerWebhookCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DockerWebhookCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DockerWebhookCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_local: bool,
                 any_remote: bool,
                 repo_keys: Sequence[str],
                 exclude_patterns: Optional[Sequence[str]] = None,
                 include_patterns: Optional[Sequence[str]] = None):
        """
        :param bool any_local: Trigger on any local repo.
        :param bool any_remote: Trigger on any remote repo.
        :param Sequence[str] repo_keys: Trigger on this list of repo keys.
        :param Sequence[str] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        :param Sequence[str] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        pulumi.set(__self__, "any_local", any_local)
        pulumi.set(__self__, "any_remote", any_remote)
        pulumi.set(__self__, "repo_keys", repo_keys)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @property
    @pulumi.getter(name="anyLocal")
    def any_local(self) -> bool:
        """
        Trigger on any local repo.
        """
        return pulumi.get(self, "any_local")

    @property
    @pulumi.getter(name="anyRemote")
    def any_remote(self) -> bool:
        """
        Trigger on any remote repo.
        """
        return pulumi.get(self, "any_remote")

    @property
    @pulumi.getter(name="repoKeys")
    def repo_keys(self) -> Sequence[str]:
        """
        Trigger on this list of repo keys.
        """
        return pulumi.get(self, "repo_keys")

    @property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[Sequence[str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "exclude_patterns")

    @property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[Sequence[str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "include_patterns")


@pulumi.output_type
class DockerWebhookHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customHttpHeaders":
            suggest = "custom_http_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DockerWebhookHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DockerWebhookHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DockerWebhookHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: str,
                 custom_http_headers: Optional[Mapping[str, str]] = None,
                 proxy: Optional[str] = None,
                 secret: Optional[str] = None):
        """
        :param str url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param Mapping[str, str] custom_http_headers: Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        :param str proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param str secret: Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        pulumi.set(__self__, "url", url)
        if custom_http_headers is not None:
            pulumi.set(__self__, "custom_http_headers", custom_http_headers)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="customHttpHeaders")
    def custom_http_headers(self) -> Optional[Mapping[str, str]]:
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        return pulumi.get(self, "custom_http_headers")

    @property
    @pulumi.getter
    def proxy(self) -> Optional[str]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @property
    @pulumi.getter
    def secret(self) -> Optional[str]:
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class FederatedAlpineRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedBowerRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedCargoRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedChefRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedCocoapodsRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedComposerRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedConanRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedCondaRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedCranRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedDebianRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedDockerRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedDockerV1RepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedDockerV2RepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedGemsRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedGenericRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedGitltfsRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedGoRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedGradleRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedHelmRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedIvyRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedMavenRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedNpmRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedNugetRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedOpkgRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedPuppetRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedPypiRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedRpmRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedSbtRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedSwiftRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedTerraformModuleRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedTerraformProviderRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedVagrantRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class LocalRepositoryMultiReplicationReplication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "checkBinaryExistenceInFilestore":
            suggest = "check_binary_existence_in_filestore"
        elif key == "excludePathPrefixPattern":
            suggest = "exclude_path_prefix_pattern"
        elif key == "includePathPrefixPattern":
            suggest = "include_path_prefix_pattern"
        elif key == "replicationKey":
            suggest = "replication_key"
        elif key == "socketTimeoutMillis":
            suggest = "socket_timeout_millis"
        elif key == "syncDeletes":
            suggest = "sync_deletes"
        elif key == "syncProperties":
            suggest = "sync_properties"
        elif key == "syncStatistics":
            suggest = "sync_statistics"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LocalRepositoryMultiReplicationReplication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LocalRepositoryMultiReplicationReplication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LocalRepositoryMultiReplicationReplication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: str,
                 username: str,
                 check_binary_existence_in_filestore: Optional[bool] = None,
                 enabled: Optional[bool] = None,
                 exclude_path_prefix_pattern: Optional[str] = None,
                 include_path_prefix_pattern: Optional[str] = None,
                 password: Optional[str] = None,
                 proxy: Optional[str] = None,
                 replication_key: Optional[str] = None,
                 socket_timeout_millis: Optional[int] = None,
                 sync_deletes: Optional[bool] = None,
                 sync_properties: Optional[bool] = None,
                 sync_statistics: Optional[bool] = None):
        """
        :param str url: The URL of the target local repository on a remote Artifactory server. Use the format `https://<artifactory_url>/artifactory/<repository_name>`.
        :param str username: Username on the remote Artifactory instance.
        :param bool check_binary_existence_in_filestore: Enabling the `check_binary_existence_in_filestore` flag requires an Enterprise Plus license. When true, enables distributed checksum storage. For more information, see [Optimizing Repository Replication with Checksum-Based Storage](https://www.jfrog.com/confluence/display/JFROG/Repository+Replication#RepositoryReplication-OptimizingRepositoryReplicationUsingStorageLevelSynchronizationOptions).
        :param bool enabled: When set, enables replication of this repository to the target specified in `url` attribute. Default value is `true`.
        :param str exclude_path_prefix_pattern: List of artifact patterns to exclude when evaluating artifact requests, in the form of `x/y/**/z/*`. By default, no artifacts are excluded.
        :param str include_path_prefix_pattern: List of artifact patterns to include when evaluating artifact requests in the form of `x/y/**/z/*`. When used, only artifacts matching one of the include patterns are served. By default, all artifacts are included `(**/*)`.
        :param str password: Use either the HTTP authentication password or [identity token](https://www.jfrog.com/confluence/display/JFROG/User+Profile#UserProfile-IdentityTokenidentitytoken).
        :param str proxy: Proxy key from Artifactory Proxies settings. The proxy configuration will be used when communicating with the remote instance.
        :param str replication_key: Replication ID, the value is unknown until the resource is created. Can't be set or updated.
        :param int socket_timeout_millis: The network timeout in milliseconds to use for remote operations. Default value is `15000`.
        :param bool sync_deletes: When set, items that were deleted locally should also be deleted remotely (also applies to properties metadata). Note that enabling this option, will delete artifacts on the target that do not exist in the source repository. Default value is `false`.
        :param bool sync_properties: When set, the task also synchronizes the properties of replicated artifacts. Default value is `true`.
        :param bool sync_statistics: When set, the task also synchronizes artifact download statistics. Set to avoid inadvertent cleanup at the target instance when setting up replication for disaster recovery. Default value is `false`
        """
        pulumi.set(__self__, "url", url)
        pulumi.set(__self__, "username", username)
        if check_binary_existence_in_filestore is not None:
            pulumi.set(__self__, "check_binary_existence_in_filestore", check_binary_existence_in_filestore)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if exclude_path_prefix_pattern is not None:
            pulumi.set(__self__, "exclude_path_prefix_pattern", exclude_path_prefix_pattern)
        if include_path_prefix_pattern is not None:
            pulumi.set(__self__, "include_path_prefix_pattern", include_path_prefix_pattern)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if replication_key is not None:
            pulumi.set(__self__, "replication_key", replication_key)
        if socket_timeout_millis is not None:
            pulumi.set(__self__, "socket_timeout_millis", socket_timeout_millis)
        if sync_deletes is not None:
            pulumi.set(__self__, "sync_deletes", sync_deletes)
        if sync_properties is not None:
            pulumi.set(__self__, "sync_properties", sync_properties)
        if sync_statistics is not None:
            pulumi.set(__self__, "sync_statistics", sync_statistics)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The URL of the target local repository on a remote Artifactory server. Use the format `https://<artifactory_url>/artifactory/<repository_name>`.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Username on the remote Artifactory instance.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="checkBinaryExistenceInFilestore")
    def check_binary_existence_in_filestore(self) -> Optional[bool]:
        """
        Enabling the `check_binary_existence_in_filestore` flag requires an Enterprise Plus license. When true, enables distributed checksum storage. For more information, see [Optimizing Repository Replication with Checksum-Based Storage](https://www.jfrog.com/confluence/display/JFROG/Repository+Replication#RepositoryReplication-OptimizingRepositoryReplicationUsingStorageLevelSynchronizationOptions).
        """
        return pulumi.get(self, "check_binary_existence_in_filestore")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        When set, enables replication of this repository to the target specified in `url` attribute. Default value is `true`.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="excludePathPrefixPattern")
    def exclude_path_prefix_pattern(self) -> Optional[str]:
        """
        List of artifact patterns to exclude when evaluating artifact requests, in the form of `x/y/**/z/*`. By default, no artifacts are excluded.
        """
        return pulumi.get(self, "exclude_path_prefix_pattern")

    @property
    @pulumi.getter(name="includePathPrefixPattern")
    def include_path_prefix_pattern(self) -> Optional[str]:
        """
        List of artifact patterns to include when evaluating artifact requests in the form of `x/y/**/z/*`. When used, only artifacts matching one of the include patterns are served. By default, all artifacts are included `(**/*)`.
        """
        return pulumi.get(self, "include_path_prefix_pattern")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        Use either the HTTP authentication password or [identity token](https://www.jfrog.com/confluence/display/JFROG/User+Profile#UserProfile-IdentityTokenidentitytoken).
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def proxy(self) -> Optional[str]:
        """
        Proxy key from Artifactory Proxies settings. The proxy configuration will be used when communicating with the remote instance.
        """
        return pulumi.get(self, "proxy")

    @property
    @pulumi.getter(name="replicationKey")
    def replication_key(self) -> Optional[str]:
        """
        Replication ID, the value is unknown until the resource is created. Can't be set or updated.
        """
        return pulumi.get(self, "replication_key")

    @property
    @pulumi.getter(name="socketTimeoutMillis")
    def socket_timeout_millis(self) -> Optional[int]:
        """
        The network timeout in milliseconds to use for remote operations. Default value is `15000`.
        """
        return pulumi.get(self, "socket_timeout_millis")

    @property
    @pulumi.getter(name="syncDeletes")
    def sync_deletes(self) -> Optional[bool]:
        """
        When set, items that were deleted locally should also be deleted remotely (also applies to properties metadata). Note that enabling this option, will delete artifacts on the target that do not exist in the source repository. Default value is `false`.
        """
        return pulumi.get(self, "sync_deletes")

    @property
    @pulumi.getter(name="syncProperties")
    def sync_properties(self) -> Optional[bool]:
        """
        When set, the task also synchronizes the properties of replicated artifacts. Default value is `true`.
        """
        return pulumi.get(self, "sync_properties")

    @property
    @pulumi.getter(name="syncStatistics")
    def sync_statistics(self) -> Optional[bool]:
        """
        When set, the task also synchronizes artifact download statistics. Set to avoid inadvertent cleanup at the target instance when setting up replication for disaster recovery. Default value is `false`
        """
        return pulumi.get(self, "sync_statistics")


@pulumi.output_type
class OauthSettingsOauthProvider(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiUrl":
            suggest = "api_url"
        elif key == "authUrl":
            suggest = "auth_url"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "tokenUrl":
            suggest = "token_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OauthSettingsOauthProvider. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OauthSettingsOauthProvider.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OauthSettingsOauthProvider.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_url: str,
                 auth_url: str,
                 client_id: str,
                 client_secret: str,
                 name: str,
                 token_url: str,
                 type: str,
                 enabled: Optional[bool] = None):
        """
        :param str api_url: OAuth user info endpoint for the IdP.
        :param str auth_url: OAuth authorization endpoint for the IdP.
        :param str client_id: OAuth client ID configured on the IdP.
        :param str client_secret: OAuth client secret configured on the IdP.
        :param str name: Name of the Artifactory OAuth provider.
        :param str token_url: OAuth token endpoint for the IdP.
        :param str type: Type of OAuth provider. (e.g., `github`, `google`, `cloudfoundry`, or `openId`)
        :param bool enabled: Enable the Artifactory OAuth provider.  Default value is `true`.
        """
        pulumi.set(__self__, "api_url", api_url)
        pulumi.set(__self__, "auth_url", auth_url)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "token_url", token_url)
        pulumi.set(__self__, "type", type)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="apiUrl")
    def api_url(self) -> str:
        """
        OAuth user info endpoint for the IdP.
        """
        return pulumi.get(self, "api_url")

    @property
    @pulumi.getter(name="authUrl")
    def auth_url(self) -> str:
        """
        OAuth authorization endpoint for the IdP.
        """
        return pulumi.get(self, "auth_url")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        OAuth client ID configured on the IdP.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        OAuth client secret configured on the IdP.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the Artifactory OAuth provider.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="tokenUrl")
    def token_url(self) -> str:
        """
        OAuth token endpoint for the IdP.
        """
        return pulumi.get(self, "token_url")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of OAuth provider. (e.g., `github`, `google`, `cloudfoundry`, or `openId`)
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Enable the Artifactory OAuth provider.  Default value is `true`.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class PermissionTargetBuild(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludesPatterns":
            suggest = "excludes_patterns"
        elif key == "includesPatterns":
            suggest = "includes_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PermissionTargetBuild. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PermissionTargetBuild.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PermissionTargetBuild.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 repositories: Sequence[str],
                 actions: Optional[Sequence['outputs.PermissionTargetBuildAction']] = None,
                 excludes_patterns: Optional[Sequence[str]] = None,
                 includes_patterns: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] repositories: List of repositories this permission target is applicable for. You can specify the name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        :param Sequence[str] excludes_patterns: Pattern of artifacts to exclude.
        :param Sequence[str] includes_patterns: Pattern of artifacts to include.
        """
        pulumi.set(__self__, "repositories", repositories)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if excludes_patterns is not None:
            pulumi.set(__self__, "excludes_patterns", excludes_patterns)
        if includes_patterns is not None:
            pulumi.set(__self__, "includes_patterns", includes_patterns)

    @property
    @pulumi.getter
    def repositories(self) -> Sequence[str]:
        """
        List of repositories this permission target is applicable for. You can specify the name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        """
        return pulumi.get(self, "repositories")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.PermissionTargetBuildAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="excludesPatterns")
    def excludes_patterns(self) -> Optional[Sequence[str]]:
        """
        Pattern of artifacts to exclude.
        """
        return pulumi.get(self, "excludes_patterns")

    @property
    @pulumi.getter(name="includesPatterns")
    def includes_patterns(self) -> Optional[Sequence[str]]:
        """
        Pattern of artifacts to include.
        """
        return pulumi.get(self, "includes_patterns")


@pulumi.output_type
class PermissionTargetBuildAction(dict):
    def __init__(__self__, *,
                 groups: Optional[Sequence['outputs.PermissionTargetBuildActionGroup']] = None,
                 users: Optional[Sequence['outputs.PermissionTargetBuildActionUser']] = None):
        """
        :param Sequence['PermissionTargetBuildActionGroupArgs'] groups: Groups this permission applies for.
        :param Sequence['PermissionTargetBuildActionUserArgs'] users: Users this permission target applies for.
        """
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence['outputs.PermissionTargetBuildActionGroup']]:
        """
        Groups this permission applies for.
        """
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def users(self) -> Optional[Sequence['outputs.PermissionTargetBuildActionUser']]:
        """
        Users this permission target applies for.
        """
        return pulumi.get(self, "users")


@pulumi.output_type
class PermissionTargetBuildActionGroup(dict):
    def __init__(__self__, *,
                 name: str,
                 permissions: Sequence[str]):
        """
        :param str name: Name of permission.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of permission.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def permissions(self) -> Sequence[str]:
        return pulumi.get(self, "permissions")


@pulumi.output_type
class PermissionTargetBuildActionUser(dict):
    def __init__(__self__, *,
                 name: str,
                 permissions: Sequence[str]):
        """
        :param str name: Name of permission.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of permission.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def permissions(self) -> Sequence[str]:
        return pulumi.get(self, "permissions")


@pulumi.output_type
class PermissionTargetReleaseBundle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludesPatterns":
            suggest = "excludes_patterns"
        elif key == "includesPatterns":
            suggest = "includes_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PermissionTargetReleaseBundle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PermissionTargetReleaseBundle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PermissionTargetReleaseBundle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 repositories: Sequence[str],
                 actions: Optional[Sequence['outputs.PermissionTargetReleaseBundleAction']] = None,
                 excludes_patterns: Optional[Sequence[str]] = None,
                 includes_patterns: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] repositories: List of repositories this permission target is applicable for. You can specify the name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        :param Sequence[str] excludes_patterns: Pattern of artifacts to exclude.
        :param Sequence[str] includes_patterns: Pattern of artifacts to include.
        """
        pulumi.set(__self__, "repositories", repositories)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if excludes_patterns is not None:
            pulumi.set(__self__, "excludes_patterns", excludes_patterns)
        if includes_patterns is not None:
            pulumi.set(__self__, "includes_patterns", includes_patterns)

    @property
    @pulumi.getter
    def repositories(self) -> Sequence[str]:
        """
        List of repositories this permission target is applicable for. You can specify the name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        """
        return pulumi.get(self, "repositories")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.PermissionTargetReleaseBundleAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="excludesPatterns")
    def excludes_patterns(self) -> Optional[Sequence[str]]:
        """
        Pattern of artifacts to exclude.
        """
        return pulumi.get(self, "excludes_patterns")

    @property
    @pulumi.getter(name="includesPatterns")
    def includes_patterns(self) -> Optional[Sequence[str]]:
        """
        Pattern of artifacts to include.
        """
        return pulumi.get(self, "includes_patterns")


@pulumi.output_type
class PermissionTargetReleaseBundleAction(dict):
    def __init__(__self__, *,
                 groups: Optional[Sequence['outputs.PermissionTargetReleaseBundleActionGroup']] = None,
                 users: Optional[Sequence['outputs.PermissionTargetReleaseBundleActionUser']] = None):
        """
        :param Sequence['PermissionTargetReleaseBundleActionGroupArgs'] groups: Groups this permission applies for.
        :param Sequence['PermissionTargetReleaseBundleActionUserArgs'] users: Users this permission target applies for.
        """
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence['outputs.PermissionTargetReleaseBundleActionGroup']]:
        """
        Groups this permission applies for.
        """
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def users(self) -> Optional[Sequence['outputs.PermissionTargetReleaseBundleActionUser']]:
        """
        Users this permission target applies for.
        """
        return pulumi.get(self, "users")


@pulumi.output_type
class PermissionTargetReleaseBundleActionGroup(dict):
    def __init__(__self__, *,
                 name: str,
                 permissions: Sequence[str]):
        """
        :param str name: Name of permission.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of permission.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def permissions(self) -> Sequence[str]:
        return pulumi.get(self, "permissions")


@pulumi.output_type
class PermissionTargetReleaseBundleActionUser(dict):
    def __init__(__self__, *,
                 name: str,
                 permissions: Sequence[str]):
        """
        :param str name: Name of permission.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of permission.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def permissions(self) -> Sequence[str]:
        return pulumi.get(self, "permissions")


@pulumi.output_type
class PermissionTargetRepo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludesPatterns":
            suggest = "excludes_patterns"
        elif key == "includesPatterns":
            suggest = "includes_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PermissionTargetRepo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PermissionTargetRepo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PermissionTargetRepo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 repositories: Sequence[str],
                 actions: Optional[Sequence['outputs.PermissionTargetRepoAction']] = None,
                 excludes_patterns: Optional[Sequence[str]] = None,
                 includes_patterns: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] repositories: List of repositories this permission target is applicable for. You can specify the name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        :param Sequence[str] excludes_patterns: Pattern of artifacts to exclude.
        :param Sequence[str] includes_patterns: Pattern of artifacts to include.
        """
        pulumi.set(__self__, "repositories", repositories)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if excludes_patterns is not None:
            pulumi.set(__self__, "excludes_patterns", excludes_patterns)
        if includes_patterns is not None:
            pulumi.set(__self__, "includes_patterns", includes_patterns)

    @property
    @pulumi.getter
    def repositories(self) -> Sequence[str]:
        """
        List of repositories this permission target is applicable for. You can specify the name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        """
        return pulumi.get(self, "repositories")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.PermissionTargetRepoAction']]:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="excludesPatterns")
    def excludes_patterns(self) -> Optional[Sequence[str]]:
        """
        Pattern of artifacts to exclude.
        """
        return pulumi.get(self, "excludes_patterns")

    @property
    @pulumi.getter(name="includesPatterns")
    def includes_patterns(self) -> Optional[Sequence[str]]:
        """
        Pattern of artifacts to include.
        """
        return pulumi.get(self, "includes_patterns")


@pulumi.output_type
class PermissionTargetRepoAction(dict):
    def __init__(__self__, *,
                 groups: Optional[Sequence['outputs.PermissionTargetRepoActionGroup']] = None,
                 users: Optional[Sequence['outputs.PermissionTargetRepoActionUser']] = None):
        """
        :param Sequence['PermissionTargetRepoActionGroupArgs'] groups: Groups this permission applies for.
        :param Sequence['PermissionTargetRepoActionUserArgs'] users: Users this permission target applies for.
        """
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence['outputs.PermissionTargetRepoActionGroup']]:
        """
        Groups this permission applies for.
        """
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def users(self) -> Optional[Sequence['outputs.PermissionTargetRepoActionUser']]:
        """
        Users this permission target applies for.
        """
        return pulumi.get(self, "users")


@pulumi.output_type
class PermissionTargetRepoActionGroup(dict):
    def __init__(__self__, *,
                 name: str,
                 permissions: Sequence[str]):
        """
        :param str name: Name of permission.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of permission.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def permissions(self) -> Sequence[str]:
        return pulumi.get(self, "permissions")


@pulumi.output_type
class PermissionTargetRepoActionUser(dict):
    def __init__(__self__, *,
                 name: str,
                 permissions: Sequence[str]):
        """
        :param str name: Name of permission.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of permission.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def permissions(self) -> Sequence[str]:
        return pulumi.get(self, "permissions")


@pulumi.output_type
class PropertySetProperty(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "predefinedValues":
            suggest = "predefined_values"
        elif key == "closedPredefinedValues":
            suggest = "closed_predefined_values"
        elif key == "multipleChoice":
            suggest = "multiple_choice"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PropertySetProperty. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PropertySetProperty.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PropertySetProperty.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 predefined_values: Sequence['outputs.PropertySetPropertyPredefinedValue'],
                 closed_predefined_values: Optional[bool] = None,
                 multiple_choice: Optional[bool] = None):
        """
        :param str name: Predefined property name.
        :param Sequence['PropertySetPropertyPredefinedValueArgs'] predefined_values: Properties in the property set.
        :param bool closed_predefined_values: Disables `multiple_choice` if set to `false` at the same time with multiple_choice set to `true`. Default value is `false`
        :param bool multiple_choice: Defines if user can select multiple values. `closed_predefined_values` should be set to `true`. Default value is `false`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "predefined_values", predefined_values)
        if closed_predefined_values is not None:
            pulumi.set(__self__, "closed_predefined_values", closed_predefined_values)
        if multiple_choice is not None:
            pulumi.set(__self__, "multiple_choice", multiple_choice)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Predefined property name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="predefinedValues")
    def predefined_values(self) -> Sequence['outputs.PropertySetPropertyPredefinedValue']:
        """
        Properties in the property set.
        """
        return pulumi.get(self, "predefined_values")

    @property
    @pulumi.getter(name="closedPredefinedValues")
    def closed_predefined_values(self) -> Optional[bool]:
        """
        Disables `multiple_choice` if set to `false` at the same time with multiple_choice set to `true`. Default value is `false`
        """
        return pulumi.get(self, "closed_predefined_values")

    @property
    @pulumi.getter(name="multipleChoice")
    def multiple_choice(self) -> Optional[bool]:
        """
        Defines if user can select multiple values. `closed_predefined_values` should be set to `true`. Default value is `false`.
        """
        return pulumi.get(self, "multiple_choice")


@pulumi.output_type
class PropertySetPropertyPredefinedValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultValue":
            suggest = "default_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PropertySetPropertyPredefinedValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PropertySetPropertyPredefinedValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PropertySetPropertyPredefinedValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_value: bool,
                 name: str):
        """
        :param bool default_value: Whether the value is selected by default in the UI.
        :param str name: Predefined property name.
        """
        pulumi.set(__self__, "default_value", default_value)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> bool:
        """
        Whether the value is selected by default in the UI.
        """
        return pulumi.get(self, "default_value")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Predefined property name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class PushReplicationReplication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "checkBinaryExistenceInFilestore":
            suggest = "check_binary_existence_in_filestore"
        elif key == "pathPrefix":
            suggest = "path_prefix"
        elif key == "socketTimeoutMillis":
            suggest = "socket_timeout_millis"
        elif key == "syncDeletes":
            suggest = "sync_deletes"
        elif key == "syncProperties":
            suggest = "sync_properties"
        elif key == "syncStatistics":
            suggest = "sync_statistics"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PushReplicationReplication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PushReplicationReplication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PushReplicationReplication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 password: str,
                 url: str,
                 username: str,
                 check_binary_existence_in_filestore: Optional[bool] = None,
                 enabled: Optional[bool] = None,
                 path_prefix: Optional[str] = None,
                 proxy: Optional[str] = None,
                 socket_timeout_millis: Optional[int] = None,
                 sync_deletes: Optional[bool] = None,
                 sync_properties: Optional[bool] = None,
                 sync_statistics: Optional[bool] = None):
        """
        :param str password: Required for local repository, but not needed for remote repository.
        :param str url: The URL of the target local repository on a remote Artifactory server. Required for local repository, but not needed for remote repository.
        :param str username: Required for local repository, but not needed for remote repository.
        :param bool check_binary_existence_in_filestore: When true, enables distributed checksum storage. For more information, see
               [Optimizing Repository Replication with Checksum-Based Storage](https://www.jfrog.com/confluence/display/JFROG/Repository+Replication#RepositoryReplication-OptimizingRepositoryReplicationUsingStorageLevelSynchronizationOptions).
        :param bool enabled: When set, this replication will be enabled when saved.
        :param str path_prefix: Only artifacts that located in path that matches the subpath within the remote repository will be replicated.
        :param str proxy: Proxy key from Artifactory Proxies settings. The proxy configuration will be used when communicating with the remote instance.
        :param int socket_timeout_millis: The network timeout in milliseconds to use for remote operations.
        :param bool sync_deletes: When set, items that were deleted locally should also be deleted remotely (also applies to properties metadata).
               Note that enabling this option, will delete artifacts on the target that do not exist in the source repository.
        :param bool sync_properties: When set, the task also synchronizes the properties of replicated artifacts.
        :param bool sync_statistics: When set, artifact download statistics will also be replicated. Set to avoid inadvertent cleanup at the target instance when setting up replication for disaster recovery.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "url", url)
        pulumi.set(__self__, "username", username)
        if check_binary_existence_in_filestore is not None:
            pulumi.set(__self__, "check_binary_existence_in_filestore", check_binary_existence_in_filestore)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if path_prefix is not None:
            pulumi.set(__self__, "path_prefix", path_prefix)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if socket_timeout_millis is not None:
            pulumi.set(__self__, "socket_timeout_millis", socket_timeout_millis)
        if sync_deletes is not None:
            pulumi.set(__self__, "sync_deletes", sync_deletes)
        if sync_properties is not None:
            pulumi.set(__self__, "sync_properties", sync_properties)
        if sync_statistics is not None:
            pulumi.set(__self__, "sync_statistics", sync_statistics)

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        Required for local repository, but not needed for remote repository.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The URL of the target local repository on a remote Artifactory server. Required for local repository, but not needed for remote repository.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Required for local repository, but not needed for remote repository.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="checkBinaryExistenceInFilestore")
    def check_binary_existence_in_filestore(self) -> Optional[bool]:
        """
        When true, enables distributed checksum storage. For more information, see
        [Optimizing Repository Replication with Checksum-Based Storage](https://www.jfrog.com/confluence/display/JFROG/Repository+Replication#RepositoryReplication-OptimizingRepositoryReplicationUsingStorageLevelSynchronizationOptions).
        """
        return pulumi.get(self, "check_binary_existence_in_filestore")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        When set, this replication will be enabled when saved.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="pathPrefix")
    def path_prefix(self) -> Optional[str]:
        """
        Only artifacts that located in path that matches the subpath within the remote repository will be replicated.
        """
        return pulumi.get(self, "path_prefix")

    @property
    @pulumi.getter
    def proxy(self) -> Optional[str]:
        """
        Proxy key from Artifactory Proxies settings. The proxy configuration will be used when communicating with the remote instance.
        """
        return pulumi.get(self, "proxy")

    @property
    @pulumi.getter(name="socketTimeoutMillis")
    def socket_timeout_millis(self) -> Optional[int]:
        """
        The network timeout in milliseconds to use for remote operations.
        """
        return pulumi.get(self, "socket_timeout_millis")

    @property
    @pulumi.getter(name="syncDeletes")
    def sync_deletes(self) -> Optional[bool]:
        """
        When set, items that were deleted locally should also be deleted remotely (also applies to properties metadata).
        Note that enabling this option, will delete artifacts on the target that do not exist in the source repository.
        """
        return pulumi.get(self, "sync_deletes")

    @property
    @pulumi.getter(name="syncProperties")
    def sync_properties(self) -> Optional[bool]:
        """
        When set, the task also synchronizes the properties of replicated artifacts.
        """
        return pulumi.get(self, "sync_properties")

    @property
    @pulumi.getter(name="syncStatistics")
    def sync_statistics(self) -> Optional[bool]:
        """
        When set, artifact download statistics will also be replicated. Set to avoid inadvertent cleanup at the target instance when setting up replication for disaster recovery.
        """
        return pulumi.get(self, "sync_statistics")


@pulumi.output_type
class ReleaseBundleCustomWebhookCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyReleaseBundle":
            suggest = "any_release_bundle"
        elif key == "registeredReleaseBundleNames":
            suggest = "registered_release_bundle_names"
        elif key == "excludePatterns":
            suggest = "exclude_patterns"
        elif key == "includePatterns":
            suggest = "include_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReleaseBundleCustomWebhookCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReleaseBundleCustomWebhookCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReleaseBundleCustomWebhookCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_release_bundle: bool,
                 registered_release_bundle_names: Sequence[str],
                 exclude_patterns: Optional[Sequence[str]] = None,
                 include_patterns: Optional[Sequence[str]] = None):
        """
        :param bool any_release_bundle: Trigger on any release bundle.
        :param Sequence[str] registered_release_bundle_names: Trigger on this list of release bundle names.
        :param Sequence[str] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: "org/apache/**".
        :param Sequence[str] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: "org/apache/**".
        """
        pulumi.set(__self__, "any_release_bundle", any_release_bundle)
        pulumi.set(__self__, "registered_release_bundle_names", registered_release_bundle_names)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @property
    @pulumi.getter(name="anyReleaseBundle")
    def any_release_bundle(self) -> bool:
        """
        Trigger on any release bundle.
        """
        return pulumi.get(self, "any_release_bundle")

    @property
    @pulumi.getter(name="registeredReleaseBundleNames")
    def registered_release_bundle_names(self) -> Sequence[str]:
        """
        Trigger on this list of release bundle names.
        """
        return pulumi.get(self, "registered_release_bundle_names")

    @property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[Sequence[str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: "org/apache/**".
        """
        return pulumi.get(self, "exclude_patterns")

    @property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[Sequence[str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: "org/apache/**".
        """
        return pulumi.get(self, "include_patterns")


@pulumi.output_type
class ReleaseBundleCustomWebhookHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpHeaders":
            suggest = "http_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReleaseBundleCustomWebhookHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReleaseBundleCustomWebhookHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReleaseBundleCustomWebhookHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: str,
                 http_headers: Optional[Mapping[str, str]] = None,
                 payload: Optional[str] = None,
                 proxy: Optional[str] = None,
                 secrets: Optional[Mapping[str, str]] = None):
        """
        :param str url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param Mapping[str, str] http_headers: HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        :param str proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param Mapping[str, str] secrets: Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
               
               ```python
               import pulumi
               ```
        """
        pulumi.set(__self__, "url", url)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Mapping[str, str]]:
        """
        HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        """
        return pulumi.get(self, "http_headers")

    @property
    @pulumi.getter
    def payload(self) -> Optional[str]:
        return pulumi.get(self, "payload")

    @property
    @pulumi.getter
    def proxy(self) -> Optional[str]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @property
    @pulumi.getter
    def secrets(self) -> Optional[Mapping[str, str]]:
        """
        Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:

        ```python
        import pulumi
        ```
        """
        return pulumi.get(self, "secrets")


@pulumi.output_type
class ReleaseBundleWebhookCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyReleaseBundle":
            suggest = "any_release_bundle"
        elif key == "registeredReleaseBundleNames":
            suggest = "registered_release_bundle_names"
        elif key == "excludePatterns":
            suggest = "exclude_patterns"
        elif key == "includePatterns":
            suggest = "include_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReleaseBundleWebhookCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReleaseBundleWebhookCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReleaseBundleWebhookCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_release_bundle: bool,
                 registered_release_bundle_names: Sequence[str],
                 exclude_patterns: Optional[Sequence[str]] = None,
                 include_patterns: Optional[Sequence[str]] = None):
        """
        :param bool any_release_bundle: Trigger on any release bundle.
        :param Sequence[str] registered_release_bundle_names: Trigger on this list of release bundle names.
        :param Sequence[str] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: "org/apache/**".
        :param Sequence[str] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: "org/apache/**".
        """
        pulumi.set(__self__, "any_release_bundle", any_release_bundle)
        pulumi.set(__self__, "registered_release_bundle_names", registered_release_bundle_names)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @property
    @pulumi.getter(name="anyReleaseBundle")
    def any_release_bundle(self) -> bool:
        """
        Trigger on any release bundle.
        """
        return pulumi.get(self, "any_release_bundle")

    @property
    @pulumi.getter(name="registeredReleaseBundleNames")
    def registered_release_bundle_names(self) -> Sequence[str]:
        """
        Trigger on this list of release bundle names.
        """
        return pulumi.get(self, "registered_release_bundle_names")

    @property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[Sequence[str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: "org/apache/**".
        """
        return pulumi.get(self, "exclude_patterns")

    @property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[Sequence[str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: "org/apache/**".
        """
        return pulumi.get(self, "include_patterns")


@pulumi.output_type
class ReleaseBundleWebhookHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customHttpHeaders":
            suggest = "custom_http_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReleaseBundleWebhookHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReleaseBundleWebhookHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReleaseBundleWebhookHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: str,
                 custom_http_headers: Optional[Mapping[str, str]] = None,
                 proxy: Optional[str] = None,
                 secret: Optional[str] = None):
        """
        :param str url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param Mapping[str, str] custom_http_headers: Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        :param str proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param str secret: Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        pulumi.set(__self__, "url", url)
        if custom_http_headers is not None:
            pulumi.set(__self__, "custom_http_headers", custom_http_headers)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="customHttpHeaders")
    def custom_http_headers(self) -> Optional[Mapping[str, str]]:
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        return pulumi.get(self, "custom_http_headers")

    @property
    @pulumi.getter
    def proxy(self) -> Optional[str]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @property
    @pulumi.getter
    def secret(self) -> Optional[str]:
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class RemoteAlpineRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteAlpineRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteAlpineRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteAlpineRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteBowerRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteBowerRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteBowerRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteBowerRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteCargoRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteCargoRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteCargoRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteCargoRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteChefRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteChefRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteChefRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteChefRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteCocoapodsRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteCocoapodsRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteCocoapodsRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteCocoapodsRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteComposerRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteComposerRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteComposerRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteComposerRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteConanRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteConanRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteConanRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteConanRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteCondaRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteCondaRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteCondaRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteCondaRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteCranRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteCranRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteCranRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteCranRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteDebianRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteDebianRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteDebianRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteDebianRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteDockerRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteDockerRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteDockerRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteDockerRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteGemsRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteGemsRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteGemsRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteGemsRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteGenericRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteGenericRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteGenericRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteGenericRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteGitlfsRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteGitlfsRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteGitlfsRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteGitlfsRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteGoRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteGoRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteGoRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteGoRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteGradleRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteGradleRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteGradleRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteGradleRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteHelmRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteHelmRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteHelmRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteHelmRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteHuggingfacemlRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteHuggingfacemlRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteHuggingfacemlRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteHuggingfacemlRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteIvyRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteIvyRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteIvyRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteIvyRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteMavenRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteMavenRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteMavenRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteMavenRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteNpmRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteNpmRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteNpmRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteNpmRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteNugetRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteNugetRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteNugetRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteNugetRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteOpkgRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteOpkgRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteOpkgRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteOpkgRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteP2RepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteP2RepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteP2RepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteP2RepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemotePubRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemotePubRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemotePubRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemotePubRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemotePuppetRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemotePuppetRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemotePuppetRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemotePuppetRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemotePypiRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemotePypiRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemotePypiRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemotePypiRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteRpmRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteRpmRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteRpmRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteRpmRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteSbtRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteSbtRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteSbtRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteSbtRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteSwiftRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteSwiftRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteSwiftRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteSwiftRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteTerraformRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteTerraformRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteTerraformRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteTerraformRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteVcsRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteVcsRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteVcsRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteVcsRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class ReplicationConfigReplication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pathPrefix":
            suggest = "path_prefix"
        elif key == "socketTimeoutMillis":
            suggest = "socket_timeout_millis"
        elif key == "syncDeletes":
            suggest = "sync_deletes"
        elif key == "syncProperties":
            suggest = "sync_properties"
        elif key == "syncStatistics":
            suggest = "sync_statistics"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReplicationConfigReplication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReplicationConfigReplication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReplicationConfigReplication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 password: Optional[str] = None,
                 path_prefix: Optional[str] = None,
                 proxy: Optional[str] = None,
                 socket_timeout_millis: Optional[int] = None,
                 sync_deletes: Optional[bool] = None,
                 sync_properties: Optional[bool] = None,
                 sync_statistics: Optional[bool] = None,
                 url: Optional[str] = None,
                 username: Optional[str] = None):
        """
        :param str password: Requires password encryption to be turned off `POST /api/system/decrypt`.
        :param str proxy: Proxy key from Artifactory Proxies setting
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if path_prefix is not None:
            pulumi.set(__self__, "path_prefix", path_prefix)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if socket_timeout_millis is not None:
            pulumi.set(__self__, "socket_timeout_millis", socket_timeout_millis)
        if sync_deletes is not None:
            pulumi.set(__self__, "sync_deletes", sync_deletes)
        if sync_properties is not None:
            pulumi.set(__self__, "sync_properties", sync_properties)
        if sync_statistics is not None:
            pulumi.set(__self__, "sync_statistics", sync_statistics)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        Requires password encryption to be turned off `POST /api/system/decrypt`.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="pathPrefix")
    def path_prefix(self) -> Optional[str]:
        return pulumi.get(self, "path_prefix")

    @property
    @pulumi.getter
    def proxy(self) -> Optional[str]:
        """
        Proxy key from Artifactory Proxies setting
        """
        return pulumi.get(self, "proxy")

    @property
    @pulumi.getter(name="socketTimeoutMillis")
    def socket_timeout_millis(self) -> Optional[int]:
        return pulumi.get(self, "socket_timeout_millis")

    @property
    @pulumi.getter(name="syncDeletes")
    def sync_deletes(self) -> Optional[bool]:
        return pulumi.get(self, "sync_deletes")

    @property
    @pulumi.getter(name="syncProperties")
    def sync_properties(self) -> Optional[bool]:
        return pulumi.get(self, "sync_properties")

    @property
    @pulumi.getter(name="syncStatistics")
    def sync_statistics(self) -> Optional[bool]:
        return pulumi.get(self, "sync_statistics")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        return pulumi.get(self, "username")


@pulumi.output_type
class GetFederatedAlpineRepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetFederatedBowerRepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetFederatedCargoRepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetFederatedChefRepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetFederatedCocoapodsRepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetFederatedComposerRepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetFederatedConanRepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetFederatedCondaRepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetFederatedCranRepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetFederatedDebianRepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetFederatedDockerRepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        return pulumi.get(self, "url")


@pulumi.output_type
class GetFederatedDockerV1RepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetFederatedDockerV2RepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetFederatedGemsRepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetFederatedGenericRepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetFederatedGitlfsRepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetFederatedGoRepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetFederatedGradleRepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetFederatedHelmRepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetFederatedIvyRepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetFederatedMavenRepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetFederatedNpmRepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetFederatedNugetRepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetFederatedOpkgRepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetFederatedPuppetRepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetFederatedPypiRepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetFederatedRpmRepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetFederatedSbtRepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetFederatedSwiftRepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetFederatedTerraformModuleRepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetFederatedTerraformProviderRepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetFederatedVagrantRepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetPermissionTargetBuildResult(dict):
    def __init__(__self__, *,
                 repositories: Sequence[str],
                 actions: Optional['outputs.GetPermissionTargetBuildActionsResult'] = None,
                 excludes_patterns: Optional[Sequence[str]] = None,
                 includes_patterns: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] repositories: List of repositories this permission target is applicable for. You can specify the
               name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote
               repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        :param Sequence[str] excludes_patterns: Pattern of artifacts to exclude.
        :param Sequence[str] includes_patterns: Pattern of artifacts to include.
        """
        pulumi.set(__self__, "repositories", repositories)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if excludes_patterns is not None:
            pulumi.set(__self__, "excludes_patterns", excludes_patterns)
        if includes_patterns is not None:
            pulumi.set(__self__, "includes_patterns", includes_patterns)

    @property
    @pulumi.getter
    def repositories(self) -> Sequence[str]:
        """
        List of repositories this permission target is applicable for. You can specify the
        name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote
        repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        """
        return pulumi.get(self, "repositories")

    @property
    @pulumi.getter
    def actions(self) -> Optional['outputs.GetPermissionTargetBuildActionsResult']:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="excludesPatterns")
    def excludes_patterns(self) -> Optional[Sequence[str]]:
        """
        Pattern of artifacts to exclude.
        """
        return pulumi.get(self, "excludes_patterns")

    @property
    @pulumi.getter(name="includesPatterns")
    def includes_patterns(self) -> Optional[Sequence[str]]:
        """
        Pattern of artifacts to include.
        """
        return pulumi.get(self, "includes_patterns")


@pulumi.output_type
class GetPermissionTargetBuildActionsResult(dict):
    def __init__(__self__, *,
                 groups: Optional[Sequence['outputs.GetPermissionTargetBuildActionsGroupResult']] = None,
                 users: Optional[Sequence['outputs.GetPermissionTargetBuildActionsUserResult']] = None):
        """
        :param Sequence['GetPermissionTargetBuildActionsGroupArgs'] groups: Groups this permission applies for.
        :param Sequence['GetPermissionTargetBuildActionsUserArgs'] users: Users this permission target applies for.
        """
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence['outputs.GetPermissionTargetBuildActionsGroupResult']]:
        """
        Groups this permission applies for.
        """
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def users(self) -> Optional[Sequence['outputs.GetPermissionTargetBuildActionsUserResult']]:
        """
        Users this permission target applies for.
        """
        return pulumi.get(self, "users")


@pulumi.output_type
class GetPermissionTargetBuildActionsGroupResult(dict):
    def __init__(__self__, *,
                 name: str,
                 permissions: Sequence[str]):
        """
        :param str name: Name of the permission target.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the permission target.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def permissions(self) -> Sequence[str]:
        return pulumi.get(self, "permissions")


@pulumi.output_type
class GetPermissionTargetBuildActionsUserResult(dict):
    def __init__(__self__, *,
                 name: str,
                 permissions: Sequence[str]):
        """
        :param str name: Name of the permission target.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the permission target.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def permissions(self) -> Sequence[str]:
        return pulumi.get(self, "permissions")


@pulumi.output_type
class GetPermissionTargetReleaseBundleResult(dict):
    def __init__(__self__, *,
                 repositories: Sequence[str],
                 actions: Optional['outputs.GetPermissionTargetReleaseBundleActionsResult'] = None,
                 excludes_patterns: Optional[Sequence[str]] = None,
                 includes_patterns: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] repositories: List of repositories this permission target is applicable for. You can specify the
               name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote
               repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        :param Sequence[str] excludes_patterns: Pattern of artifacts to exclude.
        :param Sequence[str] includes_patterns: Pattern of artifacts to include.
        """
        pulumi.set(__self__, "repositories", repositories)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if excludes_patterns is not None:
            pulumi.set(__self__, "excludes_patterns", excludes_patterns)
        if includes_patterns is not None:
            pulumi.set(__self__, "includes_patterns", includes_patterns)

    @property
    @pulumi.getter
    def repositories(self) -> Sequence[str]:
        """
        List of repositories this permission target is applicable for. You can specify the
        name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote
        repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        """
        return pulumi.get(self, "repositories")

    @property
    @pulumi.getter
    def actions(self) -> Optional['outputs.GetPermissionTargetReleaseBundleActionsResult']:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="excludesPatterns")
    def excludes_patterns(self) -> Optional[Sequence[str]]:
        """
        Pattern of artifacts to exclude.
        """
        return pulumi.get(self, "excludes_patterns")

    @property
    @pulumi.getter(name="includesPatterns")
    def includes_patterns(self) -> Optional[Sequence[str]]:
        """
        Pattern of artifacts to include.
        """
        return pulumi.get(self, "includes_patterns")


@pulumi.output_type
class GetPermissionTargetReleaseBundleActionsResult(dict):
    def __init__(__self__, *,
                 groups: Optional[Sequence['outputs.GetPermissionTargetReleaseBundleActionsGroupResult']] = None,
                 users: Optional[Sequence['outputs.GetPermissionTargetReleaseBundleActionsUserResult']] = None):
        """
        :param Sequence['GetPermissionTargetReleaseBundleActionsGroupArgs'] groups: Groups this permission applies for.
        :param Sequence['GetPermissionTargetReleaseBundleActionsUserArgs'] users: Users this permission target applies for.
        """
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence['outputs.GetPermissionTargetReleaseBundleActionsGroupResult']]:
        """
        Groups this permission applies for.
        """
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def users(self) -> Optional[Sequence['outputs.GetPermissionTargetReleaseBundleActionsUserResult']]:
        """
        Users this permission target applies for.
        """
        return pulumi.get(self, "users")


@pulumi.output_type
class GetPermissionTargetReleaseBundleActionsGroupResult(dict):
    def __init__(__self__, *,
                 name: str,
                 permissions: Sequence[str]):
        """
        :param str name: Name of the permission target.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the permission target.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def permissions(self) -> Sequence[str]:
        return pulumi.get(self, "permissions")


@pulumi.output_type
class GetPermissionTargetReleaseBundleActionsUserResult(dict):
    def __init__(__self__, *,
                 name: str,
                 permissions: Sequence[str]):
        """
        :param str name: Name of the permission target.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the permission target.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def permissions(self) -> Sequence[str]:
        return pulumi.get(self, "permissions")


@pulumi.output_type
class GetPermissionTargetRepoResult(dict):
    def __init__(__self__, *,
                 repositories: Sequence[str],
                 actions: Optional['outputs.GetPermissionTargetRepoActionsResult'] = None,
                 excludes_patterns: Optional[Sequence[str]] = None,
                 includes_patterns: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] repositories: List of repositories this permission target is applicable for. You can specify the
               name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote
               repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        :param Sequence[str] excludes_patterns: Pattern of artifacts to exclude.
        :param Sequence[str] includes_patterns: Pattern of artifacts to include.
        """
        pulumi.set(__self__, "repositories", repositories)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if excludes_patterns is not None:
            pulumi.set(__self__, "excludes_patterns", excludes_patterns)
        if includes_patterns is not None:
            pulumi.set(__self__, "includes_patterns", includes_patterns)

    @property
    @pulumi.getter
    def repositories(self) -> Sequence[str]:
        """
        List of repositories this permission target is applicable for. You can specify the
        name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote
        repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        """
        return pulumi.get(self, "repositories")

    @property
    @pulumi.getter
    def actions(self) -> Optional['outputs.GetPermissionTargetRepoActionsResult']:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="excludesPatterns")
    def excludes_patterns(self) -> Optional[Sequence[str]]:
        """
        Pattern of artifacts to exclude.
        """
        return pulumi.get(self, "excludes_patterns")

    @property
    @pulumi.getter(name="includesPatterns")
    def includes_patterns(self) -> Optional[Sequence[str]]:
        """
        Pattern of artifacts to include.
        """
        return pulumi.get(self, "includes_patterns")


@pulumi.output_type
class GetPermissionTargetRepoActionsResult(dict):
    def __init__(__self__, *,
                 groups: Optional[Sequence['outputs.GetPermissionTargetRepoActionsGroupResult']] = None,
                 users: Optional[Sequence['outputs.GetPermissionTargetRepoActionsUserResult']] = None):
        """
        :param Sequence['GetPermissionTargetRepoActionsGroupArgs'] groups: Groups this permission applies for.
        :param Sequence['GetPermissionTargetRepoActionsUserArgs'] users: Users this permission target applies for.
        """
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence['outputs.GetPermissionTargetRepoActionsGroupResult']]:
        """
        Groups this permission applies for.
        """
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def users(self) -> Optional[Sequence['outputs.GetPermissionTargetRepoActionsUserResult']]:
        """
        Users this permission target applies for.
        """
        return pulumi.get(self, "users")


@pulumi.output_type
class GetPermissionTargetRepoActionsGroupResult(dict):
    def __init__(__self__, *,
                 name: str,
                 permissions: Sequence[str]):
        """
        :param str name: Name of the permission target.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the permission target.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def permissions(self) -> Sequence[str]:
        return pulumi.get(self, "permissions")


@pulumi.output_type
class GetPermissionTargetRepoActionsUserResult(dict):
    def __init__(__self__, *,
                 name: str,
                 permissions: Sequence[str]):
        """
        :param str name: Name of the permission target.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the permission target.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def permissions(self) -> Sequence[str]:
        return pulumi.get(self, "permissions")


@pulumi.output_type
class GetRemoteAlpineRepositoryContentSynchronisationResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class GetRemoteBowerRepositoryContentSynchronisationResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class GetRemoteCargoRepositoryContentSynchronisationResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class GetRemoteChefRepositoryContentSynchronisationResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class GetRemoteCocoapodsRepositoryContentSynchronisationResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class GetRemoteComposerRepositoryContentSynchronisationResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class GetRemoteConanRepositoryContentSynchronisationResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class GetRemoteCondaRepositoryContentSynchronisationResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class GetRemoteCranRepositoryContentSynchronisationResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class GetRemoteDebianRepositoryContentSynchronisationResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class GetRemoteDockerRepositoryContentSynchronisationResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class GetRemoteGemsRepositoryContentSynchronisationResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class GetRemoteGenericRepositoryContentSynchronisationResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class GetRemoteGitlfsRepositoryContentSynchronisationResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class GetRemoteGoRepositoryContentSynchronisationResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class GetRemoteGradleRepositoryContentSynchronisationResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class GetRemoteHelmRepositoryContentSynchronisationResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class GetRemoteIvyRepositoryContentSynchronisationResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class GetRemoteMavenRepositoryContentSynchronisationResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class GetRemoteNpmRepositoryContentSynchronisationResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class GetRemoteNugetRepositoryContentSynchronisationResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class GetRemoteOpkgRepositoryContentSynchronisationResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class GetRemoteP2RepositoryContentSynchronisationResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class GetRemotePubRepositoryContentSynchronisationResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class GetRemotePuppetRepositoryContentSynchronisationResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class GetRemotePypiRepositoryContentSynchronisationResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class GetRemoteRpmRepositoryContentSynchronisationResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class GetRemoteSbtRepositoryContentSynchronisationResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class GetRemoteSwiftRepositoryContentSynchronisationResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class GetRemoteTerraformRepositoryContentSynchronisationResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class GetRemoteVcsRepositoryContentSynchronisationResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


