# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs

__all__ = [
    'ArchivePolicySearchCriteria',
    'ArtifactCustomWebhookCriteria',
    'ArtifactCustomWebhookHandler',
    'ArtifactLifecycleCustomWebhookHandler',
    'ArtifactLifecycleWebhookHandler',
    'ArtifactPropertyCustomWebhookCriteria',
    'ArtifactPropertyCustomWebhookHandler',
    'ArtifactPropertyWebhookCriteria',
    'ArtifactPropertyWebhookHandler',
    'ArtifactWebhookCriteria',
    'ArtifactWebhookHandler',
    'ArtifactoryReleaseBundleCustomWebhookCriteria',
    'ArtifactoryReleaseBundleCustomWebhookHandler',
    'ArtifactoryReleaseBundleWebhookCriteria',
    'ArtifactoryReleaseBundleWebhookHandler',
    'BuildCustomWebhookCriteria',
    'BuildCustomWebhookHandler',
    'BuildWebhookCriteria',
    'BuildWebhookHandler',
    'DestinationCustomWebhookCriteria',
    'DestinationCustomWebhookHandler',
    'DestinationWebhookCriteria',
    'DestinationWebhookHandler',
    'DistributionCustomWebhookCriteria',
    'DistributionCustomWebhookHandler',
    'DistributionWebhookCriteria',
    'DistributionWebhookHandler',
    'DockerCustomWebhookCriteria',
    'DockerCustomWebhookHandler',
    'DockerWebhookCriteria',
    'DockerWebhookHandler',
    'FederatedAlpineRepositoryMember',
    'FederatedAnsibleRepositoryMember',
    'FederatedBowerRepositoryMember',
    'FederatedCargoRepositoryMember',
    'FederatedChefRepositoryMember',
    'FederatedCocoapodsRepositoryMember',
    'FederatedComposerRepositoryMember',
    'FederatedConanRepositoryMember',
    'FederatedCondaRepositoryMember',
    'FederatedCranRepositoryMember',
    'FederatedDebianRepositoryMember',
    'FederatedDockerRepositoryMember',
    'FederatedDockerV1RepositoryMember',
    'FederatedDockerV2RepositoryMember',
    'FederatedGemsRepositoryMember',
    'FederatedGenericRepositoryMember',
    'FederatedGitltfsRepositoryMember',
    'FederatedGoRepositoryMember',
    'FederatedGradleRepositoryMember',
    'FederatedHelmRepositoryMember',
    'FederatedHelmociRepositoryMember',
    'FederatedHuggingfacemlRepositoryMember',
    'FederatedIvyRepositoryMember',
    'FederatedMavenRepositoryMember',
    'FederatedNpmRepositoryMember',
    'FederatedNugetRepositoryMember',
    'FederatedOciRepositoryMember',
    'FederatedOpkgRepositoryMember',
    'FederatedPuppetRepositoryMember',
    'FederatedPypiRepositoryMember',
    'FederatedRpmRepositoryMember',
    'FederatedSbtRepositoryMember',
    'FederatedSwiftRepositoryMember',
    'FederatedTerraformModuleRepositoryMember',
    'FederatedTerraformProviderRepositoryMember',
    'FederatedVagrantRepositoryMember',
    'LocalRepositoryMultiReplicationReplication',
    'ManagedUserPasswordPolicy',
    'OauthSettingsOauthProvider',
    'PackageCleanupPolicySearchCriteria',
    'PermissionTargetBuild',
    'PermissionTargetBuildActions',
    'PermissionTargetBuildActionsGroup',
    'PermissionTargetBuildActionsUser',
    'PermissionTargetReleaseBundle',
    'PermissionTargetReleaseBundleActions',
    'PermissionTargetReleaseBundleActionsGroup',
    'PermissionTargetReleaseBundleActionsUser',
    'PermissionTargetRepo',
    'PermissionTargetRepoActions',
    'PermissionTargetRepoActionsGroup',
    'PermissionTargetRepoActionsUser',
    'PropertySetProperty',
    'PropertySetPropertyPredefinedValue',
    'PushReplicationReplication',
    'ReleaseBundleCustomWebhookCriteria',
    'ReleaseBundleCustomWebhookHandler',
    'ReleaseBundleV2CleanupPolicySearchCriteria',
    'ReleaseBundleV2CleanupPolicySearchCriteriaReleaseBundle',
    'ReleaseBundleV2CustomWebhookCriteria',
    'ReleaseBundleV2CustomWebhookHandler',
    'ReleaseBundleV2PromotionCustomWebhookCriteria',
    'ReleaseBundleV2PromotionCustomWebhookHandler',
    'ReleaseBundleV2PromotionWebhookCriteria',
    'ReleaseBundleV2PromotionWebhookHandler',
    'ReleaseBundleV2Source',
    'ReleaseBundleV2SourceArtifact',
    'ReleaseBundleV2SourceBuild',
    'ReleaseBundleV2SourceReleaseBundle',
    'ReleaseBundleV2WebhookCriteria',
    'ReleaseBundleV2WebhookHandler',
    'ReleaseBundleWebhookCriteria',
    'ReleaseBundleWebhookHandler',
    'RemoteAlpineRepositoryContentSynchronisation',
    'RemoteAnsibleRepositoryContentSynchronisation',
    'RemoteBowerRepositoryContentSynchronisation',
    'RemoteCargoRepositoryContentSynchronisation',
    'RemoteChefRepositoryContentSynchronisation',
    'RemoteCocoapodsRepositoryContentSynchronisation',
    'RemoteComposerRepositoryContentSynchronisation',
    'RemoteConanRepositoryContentSynchronisation',
    'RemoteCondaRepositoryContentSynchronisation',
    'RemoteCranRepositoryContentSynchronisation',
    'RemoteDebianRepositoryContentSynchronisation',
    'RemoteDockerRepositoryContentSynchronisation',
    'RemoteGemsRepositoryContentSynchronisation',
    'RemoteGenericRepositoryContentSynchronisation',
    'RemoteGitlfsRepositoryContentSynchronisation',
    'RemoteGoRepositoryContentSynchronisation',
    'RemoteGradleRepositoryContentSynchronisation',
    'RemoteHelmRepositoryContentSynchronisation',
    'RemoteHelmociRepositoryContentSynchronisation',
    'RemoteHuggingfacemlRepositoryContentSynchronisation',
    'RemoteIvyRepositoryContentSynchronisation',
    'RemoteMavenRepositoryContentSynchronisation',
    'RemoteNpmRepositoryContentSynchronisation',
    'RemoteNugetRepositoryContentSynchronisation',
    'RemoteOciRepositoryContentSynchronisation',
    'RemoteOpkgRepositoryContentSynchronisation',
    'RemoteP2RepositoryContentSynchronisation',
    'RemotePubRepositoryContentSynchronisation',
    'RemotePuppetRepositoryContentSynchronisation',
    'RemotePypiRepositoryContentSynchronisation',
    'RemoteRpmRepositoryContentSynchronisation',
    'RemoteSbtRepositoryContentSynchronisation',
    'RemoteSwiftRepositoryContentSynchronisation',
    'RemoteTerraformRepositoryContentSynchronisation',
    'RemoteVcsRepositoryContentSynchronisation',
    'UnmanagedUserPasswordPolicy',
    'UserCustomWebhookHandler',
    'UserPasswordPolicy',
    'UserWebhookHandler',
    'VaultConfigurationConfig',
    'VaultConfigurationConfigAuth',
    'VaultConfigurationConfigMount',
    'GetFederatedAlpineRepositoryMemberResult',
    'GetFederatedAnsibleRepositoryMemberResult',
    'GetFederatedBowerRepositoryMemberResult',
    'GetFederatedCargoRepositoryMemberResult',
    'GetFederatedChefRepositoryMemberResult',
    'GetFederatedCocoapodsRepositoryMemberResult',
    'GetFederatedComposerRepositoryMemberResult',
    'GetFederatedConanRepositoryMemberResult',
    'GetFederatedCondaRepositoryMemberResult',
    'GetFederatedCranRepositoryMemberResult',
    'GetFederatedDebianRepositoryMemberResult',
    'GetFederatedDockerRepositoryMemberResult',
    'GetFederatedDockerV1RepositoryMemberResult',
    'GetFederatedDockerV2RepositoryMemberResult',
    'GetFederatedGemsRepositoryMemberResult',
    'GetFederatedGenericRepositoryMemberResult',
    'GetFederatedGitlfsRepositoryMemberResult',
    'GetFederatedGoRepositoryMemberResult',
    'GetFederatedGradleRepositoryMemberResult',
    'GetFederatedHelmRepositoryMemberResult',
    'GetFederatedHelmociRepositoryMemberResult',
    'GetFederatedHuggingfacemlRepositoryMemberResult',
    'GetFederatedIvyRepositoryMemberResult',
    'GetFederatedMavenRepositoryMemberResult',
    'GetFederatedNpmRepositoryMemberResult',
    'GetFederatedNugetRepositoryMemberResult',
    'GetFederatedOciRepositoryMemberResult',
    'GetFederatedOpkgRepositoryMemberResult',
    'GetFederatedPuppetRepositoryMemberResult',
    'GetFederatedPypiRepositoryMemberResult',
    'GetFederatedRpmRepositoryMemberResult',
    'GetFederatedSbtRepositoryMemberResult',
    'GetFederatedSwiftRepositoryMemberResult',
    'GetFederatedTerraformModuleRepositoryMemberResult',
    'GetFederatedTerraformProviderRepositoryMemberResult',
    'GetFederatedVagrantRepositoryMemberResult',
    'GetFileListFileResult',
    'GetFileListFileMetadataTimestampsResult',
    'GetPermissionTargetBuildResult',
    'GetPermissionTargetBuildActionsResult',
    'GetPermissionTargetBuildActionsGroupResult',
    'GetPermissionTargetBuildActionsUserResult',
    'GetPermissionTargetReleaseBundleResult',
    'GetPermissionTargetReleaseBundleActionsResult',
    'GetPermissionTargetReleaseBundleActionsGroupResult',
    'GetPermissionTargetReleaseBundleActionsUserResult',
    'GetPermissionTargetRepoResult',
    'GetPermissionTargetRepoActionsResult',
    'GetPermissionTargetRepoActionsGroupResult',
    'GetPermissionTargetRepoActionsUserResult',
    'GetRemoteAlpineRepositoryContentSynchronisationResult',
    'GetRemoteAnsibleRepositoryContentSynchronisationResult',
    'GetRemoteBowerRepositoryContentSynchronisationResult',
    'GetRemoteCargoRepositoryContentSynchronisationResult',
    'GetRemoteChefRepositoryContentSynchronisationResult',
    'GetRemoteCocoapodsRepositoryContentSynchronisationResult',
    'GetRemoteComposerRepositoryContentSynchronisationResult',
    'GetRemoteConanRepositoryContentSynchronisationResult',
    'GetRemoteCondaRepositoryContentSynchronisationResult',
    'GetRemoteCranRepositoryContentSynchronisationResult',
    'GetRemoteDebianRepositoryContentSynchronisationResult',
    'GetRemoteDockerRepositoryContentSynchronisationResult',
    'GetRemoteGenericRepositoryContentSynchronisationResult',
    'GetRemoteGitlfsRepositoryContentSynchronisationResult',
    'GetRemoteGoRepositoryContentSynchronisationResult',
    'GetRemoteGradleRepositoryContentSynchronisationResult',
    'GetRemoteHelmRepositoryContentSynchronisationResult',
    'GetRemoteHelmociRepositoryContentSynchronisationResult',
    'GetRemoteIvyRepositoryContentSynchronisationResult',
    'GetRemoteMavenRepositoryContentSynchronisationResult',
    'GetRemoteNpmRepositoryContentSynchronisationResult',
    'GetRemoteNugetRepositoryContentSynchronisationResult',
    'GetRemoteOciRepositoryContentSynchronisationResult',
    'GetRemoteOpkgRepositoryContentSynchronisationResult',
    'GetRemoteP2RepositoryContentSynchronisationResult',
    'GetRemotePubRepositoryContentSynchronisationResult',
    'GetRemotePuppetRepositoryContentSynchronisationResult',
    'GetRemotePypiRepositoryContentSynchronisationResult',
    'GetRemoteRpmRepositoryContentSynchronisationResult',
    'GetRemoteSbtRepositoryContentSynchronisationResult',
    'GetRemoteSwiftRepositoryContentSynchronisationResult',
    'GetRemoteTerraformRepositoryContentSynchronisationResult',
    'GetRemoteVcsRepositoryContentSynchronisationResult',
    'GetRepositoriesRepoResult',
]

@pulumi.output_type
class ArchivePolicySearchCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPackages":
            suggest = "included_packages"
        elif key == "packageTypes":
            suggest = "package_types"
        elif key == "createdBeforeInMonths":
            suggest = "created_before_in_months"
        elif key == "excludedPackages":
            suggest = "excluded_packages"
        elif key == "excludedRepos":
            suggest = "excluded_repos"
        elif key == "includeAllProjects":
            suggest = "include_all_projects"
        elif key == "includedProjects":
            suggest = "included_projects"
        elif key == "keepLastNVersions":
            suggest = "keep_last_n_versions"
        elif key == "lastDownloadedBeforeInMonths":
            suggest = "last_downloaded_before_in_months"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ArchivePolicySearchCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ArchivePolicySearchCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ArchivePolicySearchCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 included_packages: Sequence[_builtins.str],
                 package_types: Sequence[_builtins.str],
                 repos: Sequence[_builtins.str],
                 created_before_in_months: Optional[_builtins.int] = None,
                 excluded_packages: Optional[Sequence[_builtins.str]] = None,
                 excluded_repos: Optional[Sequence[_builtins.str]] = None,
                 include_all_projects: Optional[_builtins.bool] = None,
                 included_projects: Optional[Sequence[_builtins.str]] = None,
                 keep_last_n_versions: Optional[_builtins.int] = None,
                 last_downloaded_before_in_months: Optional[_builtins.int] = None):
        """
        :param Sequence[_builtins.str] included_packages: Specify a pattern for a package name or an explicit package name. It accept only single element which can be specific package or pattern, and for including all packages use `**`. Example: `included_packages = ["**"]`
        :param Sequence[_builtins.str] repos: Specify one or more patterns for the repository name(s) on which you want the archive policy to run. You can also specify explicit repository names. Specifying at least one pattern or explicit name is required. Only packages in repositories that match the pattern or explicit name will be archived. For including all repos use `**`. Example: `repos = ["**"]`
        :param _builtins.int created_before_in_months: The archive policy will archive packages based on how long ago they were created. For example, if this parameter is 2 then packages created more than 2 months ago will be archived as part of the policy.
        :param Sequence[_builtins.str] excluded_packages: Specify explicit package names that you want excluded from the policy. Only Name explicit names (and not patterns) are accepted.
        :param Sequence[_builtins.str] excluded_repos: Specify patterns for repository names or explicit repository names that you want excluded from the archive policy.
        :param _builtins.bool include_all_projects: Set this value to `true` if you want the policy to run on all Artifactory projects. The default value is `false`.
        :param Sequence[_builtins.str] included_projects: List of projects on which you want this policy to run. To include repositories that are not assigned to any project, enter the project key `default`.
               
               ~>This setting is relevant only on the global level, for Platform Admins.
        :param _builtins.int keep_last_n_versions: Set a value for the number of latest versions to keep. The archive policy will remove all versions before the number you select here. The latest version is always excluded.
               
               ~>Versions are determined by creation date.
               
               ~>Not all package types support this condition. If you include a package type in your policy that is not compatible with this condition, a validation error (400) is returned. For information on which package types support this condition, see here.
        :param _builtins.int last_downloaded_before_in_months: The archive policy will archive packages based on how long ago they were downloaded. For example, if this parameter is 5 then packages downloaded more than 5 months ago will be archived as part of the policy.
               
               ~>JFrog recommends using the `last_downloaded_before_in_months` condition to ensure that packages currently in use are not archived.
        """
        pulumi.set(__self__, "included_packages", included_packages)
        pulumi.set(__self__, "package_types", package_types)
        pulumi.set(__self__, "repos", repos)
        if created_before_in_months is not None:
            pulumi.set(__self__, "created_before_in_months", created_before_in_months)
        if excluded_packages is not None:
            pulumi.set(__self__, "excluded_packages", excluded_packages)
        if excluded_repos is not None:
            pulumi.set(__self__, "excluded_repos", excluded_repos)
        if include_all_projects is not None:
            pulumi.set(__self__, "include_all_projects", include_all_projects)
        if included_projects is not None:
            pulumi.set(__self__, "included_projects", included_projects)
        if keep_last_n_versions is not None:
            pulumi.set(__self__, "keep_last_n_versions", keep_last_n_versions)
        if last_downloaded_before_in_months is not None:
            pulumi.set(__self__, "last_downloaded_before_in_months", last_downloaded_before_in_months)

    @_builtins.property
    @pulumi.getter(name="includedPackages")
    def included_packages(self) -> Sequence[_builtins.str]:
        """
        Specify a pattern for a package name or an explicit package name. It accept only single element which can be specific package or pattern, and for including all packages use `**`. Example: `included_packages = ["**"]`
        """
        return pulumi.get(self, "included_packages")

    @_builtins.property
    @pulumi.getter(name="packageTypes")
    def package_types(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "package_types")

    @_builtins.property
    @pulumi.getter
    def repos(self) -> Sequence[_builtins.str]:
        """
        Specify one or more patterns for the repository name(s) on which you want the archive policy to run. You can also specify explicit repository names. Specifying at least one pattern or explicit name is required. Only packages in repositories that match the pattern or explicit name will be archived. For including all repos use `**`. Example: `repos = ["**"]`
        """
        return pulumi.get(self, "repos")

    @_builtins.property
    @pulumi.getter(name="createdBeforeInMonths")
    def created_before_in_months(self) -> Optional[_builtins.int]:
        """
        The archive policy will archive packages based on how long ago they were created. For example, if this parameter is 2 then packages created more than 2 months ago will be archived as part of the policy.
        """
        return pulumi.get(self, "created_before_in_months")

    @_builtins.property
    @pulumi.getter(name="excludedPackages")
    def excluded_packages(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specify explicit package names that you want excluded from the policy. Only Name explicit names (and not patterns) are accepted.
        """
        return pulumi.get(self, "excluded_packages")

    @_builtins.property
    @pulumi.getter(name="excludedRepos")
    def excluded_repos(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specify patterns for repository names or explicit repository names that you want excluded from the archive policy.
        """
        return pulumi.get(self, "excluded_repos")

    @_builtins.property
    @pulumi.getter(name="includeAllProjects")
    def include_all_projects(self) -> Optional[_builtins.bool]:
        """
        Set this value to `true` if you want the policy to run on all Artifactory projects. The default value is `false`.
        """
        return pulumi.get(self, "include_all_projects")

    @_builtins.property
    @pulumi.getter(name="includedProjects")
    def included_projects(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of projects on which you want this policy to run. To include repositories that are not assigned to any project, enter the project key `default`.

        ~>This setting is relevant only on the global level, for Platform Admins.
        """
        return pulumi.get(self, "included_projects")

    @_builtins.property
    @pulumi.getter(name="keepLastNVersions")
    def keep_last_n_versions(self) -> Optional[_builtins.int]:
        """
        Set a value for the number of latest versions to keep. The archive policy will remove all versions before the number you select here. The latest version is always excluded.

        ~>Versions are determined by creation date.

        ~>Not all package types support this condition. If you include a package type in your policy that is not compatible with this condition, a validation error (400) is returned. For information on which package types support this condition, see here.
        """
        return pulumi.get(self, "keep_last_n_versions")

    @_builtins.property
    @pulumi.getter(name="lastDownloadedBeforeInMonths")
    def last_downloaded_before_in_months(self) -> Optional[_builtins.int]:
        """
        The archive policy will archive packages based on how long ago they were downloaded. For example, if this parameter is 5 then packages downloaded more than 5 months ago will be archived as part of the policy.

        ~>JFrog recommends using the `last_downloaded_before_in_months` condition to ensure that packages currently in use are not archived.
        """
        return pulumi.get(self, "last_downloaded_before_in_months")


@pulumi.output_type
class ArtifactCustomWebhookCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyFederated":
            suggest = "any_federated"
        elif key == "anyLocal":
            suggest = "any_local"
        elif key == "anyRemote":
            suggest = "any_remote"
        elif key == "repoKeys":
            suggest = "repo_keys"
        elif key == "excludePatterns":
            suggest = "exclude_patterns"
        elif key == "includePatterns":
            suggest = "include_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ArtifactCustomWebhookCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ArtifactCustomWebhookCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ArtifactCustomWebhookCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_federated: _builtins.bool,
                 any_local: _builtins.bool,
                 any_remote: _builtins.bool,
                 repo_keys: Sequence[_builtins.str],
                 exclude_patterns: Optional[Sequence[_builtins.str]] = None,
                 include_patterns: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.bool any_federated: Trigger on any federated repositories
        :param _builtins.bool any_local: Trigger on any local repo.
        :param _builtins.bool any_remote: Trigger on any remote repo.
        :param Sequence[_builtins.str] repo_keys: Trigger on this list of repo keys.
        :param Sequence[_builtins.str] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        :param Sequence[_builtins.str] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        pulumi.set(__self__, "any_federated", any_federated)
        pulumi.set(__self__, "any_local", any_local)
        pulumi.set(__self__, "any_remote", any_remote)
        pulumi.set(__self__, "repo_keys", repo_keys)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @_builtins.property
    @pulumi.getter(name="anyFederated")
    def any_federated(self) -> _builtins.bool:
        """
        Trigger on any federated repositories
        """
        return pulumi.get(self, "any_federated")

    @_builtins.property
    @pulumi.getter(name="anyLocal")
    def any_local(self) -> _builtins.bool:
        """
        Trigger on any local repo.
        """
        return pulumi.get(self, "any_local")

    @_builtins.property
    @pulumi.getter(name="anyRemote")
    def any_remote(self) -> _builtins.bool:
        """
        Trigger on any remote repo.
        """
        return pulumi.get(self, "any_remote")

    @_builtins.property
    @pulumi.getter(name="repoKeys")
    def repo_keys(self) -> Sequence[_builtins.str]:
        """
        Trigger on this list of repo keys.
        """
        return pulumi.get(self, "repo_keys")

    @_builtins.property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "exclude_patterns")

    @_builtins.property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "include_patterns")


@pulumi.output_type
class ArtifactCustomWebhookHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpHeaders":
            suggest = "http_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ArtifactCustomWebhookHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ArtifactCustomWebhookHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ArtifactCustomWebhookHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: _builtins.str,
                 http_headers: Optional[Mapping[str, _builtins.str]] = None,
                 method: Optional[_builtins.str] = None,
                 payload: Optional[_builtins.str] = None,
                 proxy: Optional[_builtins.str] = None,
                 secrets: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param Mapping[str, _builtins.str] http_headers: HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        :param _builtins.str method: Specifies the HTTP method for the URL that the Webhook invokes. Allowed values are: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`.
        :param _builtins.str payload: This attribute is used to build the request body. Used in custom webhooks
        :param _builtins.str proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param Mapping[str, _builtins.str] secrets: Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example: 
        """
        pulumi.set(__self__, "url", url)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        """
        return pulumi.get(self, "http_headers")

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[_builtins.str]:
        """
        Specifies the HTTP method for the URL that the Webhook invokes. Allowed values are: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`.
        """
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter
    def payload(self) -> Optional[_builtins.str]:
        """
        This attribute is used to build the request body. Used in custom webhooks
        """
        return pulumi.get(self, "payload")

    @_builtins.property
    @pulumi.getter
    def proxy(self) -> Optional[_builtins.str]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @_builtins.property
    @pulumi.getter
    def secrets(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example: 
        """
        return pulumi.get(self, "secrets")


@pulumi.output_type
class ArtifactLifecycleCustomWebhookHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpHeaders":
            suggest = "http_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ArtifactLifecycleCustomWebhookHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ArtifactLifecycleCustomWebhookHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ArtifactLifecycleCustomWebhookHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: _builtins.str,
                 http_headers: Optional[Mapping[str, _builtins.str]] = None,
                 method: Optional[_builtins.str] = None,
                 payload: Optional[_builtins.str] = None,
                 proxy: Optional[_builtins.str] = None,
                 secrets: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param Mapping[str, _builtins.str] http_headers: HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        :param _builtins.str method: Specifies the HTTP method for the URL that the Webhook invokes. Allowed values are: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`.
        :param _builtins.str payload: This attribute is used to build the request body. Used in custom webhooks
        :param _builtins.str proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param Mapping[str, _builtins.str] secrets: Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
        pulumi.set(__self__, "url", url)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        """
        return pulumi.get(self, "http_headers")

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[_builtins.str]:
        """
        Specifies the HTTP method for the URL that the Webhook invokes. Allowed values are: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`.
        """
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter
    def payload(self) -> Optional[_builtins.str]:
        """
        This attribute is used to build the request body. Used in custom webhooks
        """
        return pulumi.get(self, "payload")

    @_builtins.property
    @pulumi.getter
    def proxy(self) -> Optional[_builtins.str]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @_builtins.property
    @pulumi.getter
    def secrets(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
        return pulumi.get(self, "secrets")


@pulumi.output_type
class ArtifactLifecycleWebhookHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customHttpHeaders":
            suggest = "custom_http_headers"
        elif key == "useSecretForSigning":
            suggest = "use_secret_for_signing"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ArtifactLifecycleWebhookHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ArtifactLifecycleWebhookHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ArtifactLifecycleWebhookHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: _builtins.str,
                 custom_http_headers: Optional[Mapping[str, _builtins.str]] = None,
                 proxy: Optional[_builtins.str] = None,
                 secret: Optional[_builtins.str] = None,
                 use_secret_for_signing: Optional[_builtins.bool] = None):
        """
        :param _builtins.str url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param Mapping[str, _builtins.str] custom_http_headers: Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        :param _builtins.str proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param _builtins.str secret: Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        :param _builtins.bool use_secret_for_signing: When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        pulumi.set(__self__, "url", url)
        if custom_http_headers is not None:
            pulumi.set(__self__, "custom_http_headers", custom_http_headers)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if use_secret_for_signing is not None:
            pulumi.set(__self__, "use_secret_for_signing", use_secret_for_signing)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="customHttpHeaders")
    def custom_http_headers(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        return pulumi.get(self, "custom_http_headers")

    @_builtins.property
    @pulumi.getter
    def proxy(self) -> Optional[_builtins.str]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[_builtins.str]:
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter(name="useSecretForSigning")
    def use_secret_for_signing(self) -> Optional[_builtins.bool]:
        """
        When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        return pulumi.get(self, "use_secret_for_signing")


@pulumi.output_type
class ArtifactPropertyCustomWebhookCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyFederated":
            suggest = "any_federated"
        elif key == "anyLocal":
            suggest = "any_local"
        elif key == "anyRemote":
            suggest = "any_remote"
        elif key == "repoKeys":
            suggest = "repo_keys"
        elif key == "excludePatterns":
            suggest = "exclude_patterns"
        elif key == "includePatterns":
            suggest = "include_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ArtifactPropertyCustomWebhookCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ArtifactPropertyCustomWebhookCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ArtifactPropertyCustomWebhookCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_federated: _builtins.bool,
                 any_local: _builtins.bool,
                 any_remote: _builtins.bool,
                 repo_keys: Sequence[_builtins.str],
                 exclude_patterns: Optional[Sequence[_builtins.str]] = None,
                 include_patterns: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.bool any_federated: Trigger on any federated repositories
        :param _builtins.bool any_local: Trigger on any local repo.
        :param _builtins.bool any_remote: Trigger on any remote repo.
        :param Sequence[_builtins.str] repo_keys: Trigger on this list of repo keys.
        :param Sequence[_builtins.str] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        :param Sequence[_builtins.str] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        pulumi.set(__self__, "any_federated", any_federated)
        pulumi.set(__self__, "any_local", any_local)
        pulumi.set(__self__, "any_remote", any_remote)
        pulumi.set(__self__, "repo_keys", repo_keys)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @_builtins.property
    @pulumi.getter(name="anyFederated")
    def any_federated(self) -> _builtins.bool:
        """
        Trigger on any federated repositories
        """
        return pulumi.get(self, "any_federated")

    @_builtins.property
    @pulumi.getter(name="anyLocal")
    def any_local(self) -> _builtins.bool:
        """
        Trigger on any local repo.
        """
        return pulumi.get(self, "any_local")

    @_builtins.property
    @pulumi.getter(name="anyRemote")
    def any_remote(self) -> _builtins.bool:
        """
        Trigger on any remote repo.
        """
        return pulumi.get(self, "any_remote")

    @_builtins.property
    @pulumi.getter(name="repoKeys")
    def repo_keys(self) -> Sequence[_builtins.str]:
        """
        Trigger on this list of repo keys.
        """
        return pulumi.get(self, "repo_keys")

    @_builtins.property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "exclude_patterns")

    @_builtins.property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "include_patterns")


@pulumi.output_type
class ArtifactPropertyCustomWebhookHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpHeaders":
            suggest = "http_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ArtifactPropertyCustomWebhookHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ArtifactPropertyCustomWebhookHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ArtifactPropertyCustomWebhookHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: _builtins.str,
                 http_headers: Optional[Mapping[str, _builtins.str]] = None,
                 method: Optional[_builtins.str] = None,
                 payload: Optional[_builtins.str] = None,
                 proxy: Optional[_builtins.str] = None,
                 secrets: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param Mapping[str, _builtins.str] http_headers: HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        :param _builtins.str method: Specifies the HTTP method for the URL that the Webhook invokes. Allowed values are: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`.
        :param _builtins.str payload: This attribute is used to build the request body. Used in custom webhooks
        :param _builtins.str proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param Mapping[str, _builtins.str] secrets: Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
        pulumi.set(__self__, "url", url)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        """
        return pulumi.get(self, "http_headers")

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[_builtins.str]:
        """
        Specifies the HTTP method for the URL that the Webhook invokes. Allowed values are: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`.
        """
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter
    def payload(self) -> Optional[_builtins.str]:
        """
        This attribute is used to build the request body. Used in custom webhooks
        """
        return pulumi.get(self, "payload")

    @_builtins.property
    @pulumi.getter
    def proxy(self) -> Optional[_builtins.str]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @_builtins.property
    @pulumi.getter
    def secrets(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
        return pulumi.get(self, "secrets")


@pulumi.output_type
class ArtifactPropertyWebhookCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyFederated":
            suggest = "any_federated"
        elif key == "anyLocal":
            suggest = "any_local"
        elif key == "anyRemote":
            suggest = "any_remote"
        elif key == "repoKeys":
            suggest = "repo_keys"
        elif key == "excludePatterns":
            suggest = "exclude_patterns"
        elif key == "includePatterns":
            suggest = "include_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ArtifactPropertyWebhookCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ArtifactPropertyWebhookCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ArtifactPropertyWebhookCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_federated: _builtins.bool,
                 any_local: _builtins.bool,
                 any_remote: _builtins.bool,
                 repo_keys: Sequence[_builtins.str],
                 exclude_patterns: Optional[Sequence[_builtins.str]] = None,
                 include_patterns: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.bool any_federated: Trigger on any federated repo.
        :param _builtins.bool any_local: Trigger on any local repo.
        :param _builtins.bool any_remote: Trigger on any remote repo.
        :param Sequence[_builtins.str] repo_keys: Trigger on this list of repo keys.
        :param Sequence[_builtins.str] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        :param Sequence[_builtins.str] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        pulumi.set(__self__, "any_federated", any_federated)
        pulumi.set(__self__, "any_local", any_local)
        pulumi.set(__self__, "any_remote", any_remote)
        pulumi.set(__self__, "repo_keys", repo_keys)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @_builtins.property
    @pulumi.getter(name="anyFederated")
    def any_federated(self) -> _builtins.bool:
        """
        Trigger on any federated repo.
        """
        return pulumi.get(self, "any_federated")

    @_builtins.property
    @pulumi.getter(name="anyLocal")
    def any_local(self) -> _builtins.bool:
        """
        Trigger on any local repo.
        """
        return pulumi.get(self, "any_local")

    @_builtins.property
    @pulumi.getter(name="anyRemote")
    def any_remote(self) -> _builtins.bool:
        """
        Trigger on any remote repo.
        """
        return pulumi.get(self, "any_remote")

    @_builtins.property
    @pulumi.getter(name="repoKeys")
    def repo_keys(self) -> Sequence[_builtins.str]:
        """
        Trigger on this list of repo keys.
        """
        return pulumi.get(self, "repo_keys")

    @_builtins.property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "exclude_patterns")

    @_builtins.property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "include_patterns")


@pulumi.output_type
class ArtifactPropertyWebhookHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customHttpHeaders":
            suggest = "custom_http_headers"
        elif key == "useSecretForSigning":
            suggest = "use_secret_for_signing"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ArtifactPropertyWebhookHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ArtifactPropertyWebhookHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ArtifactPropertyWebhookHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: _builtins.str,
                 custom_http_headers: Optional[Mapping[str, _builtins.str]] = None,
                 proxy: Optional[_builtins.str] = None,
                 secret: Optional[_builtins.str] = None,
                 use_secret_for_signing: Optional[_builtins.bool] = None):
        """
        :param _builtins.str url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param Mapping[str, _builtins.str] custom_http_headers: Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        :param _builtins.str proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param _builtins.str secret: Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        :param _builtins.bool use_secret_for_signing: When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        pulumi.set(__self__, "url", url)
        if custom_http_headers is not None:
            pulumi.set(__self__, "custom_http_headers", custom_http_headers)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if use_secret_for_signing is not None:
            pulumi.set(__self__, "use_secret_for_signing", use_secret_for_signing)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="customHttpHeaders")
    def custom_http_headers(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        return pulumi.get(self, "custom_http_headers")

    @_builtins.property
    @pulumi.getter
    def proxy(self) -> Optional[_builtins.str]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[_builtins.str]:
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter(name="useSecretForSigning")
    def use_secret_for_signing(self) -> Optional[_builtins.bool]:
        """
        When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        return pulumi.get(self, "use_secret_for_signing")


@pulumi.output_type
class ArtifactWebhookCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyFederated":
            suggest = "any_federated"
        elif key == "anyLocal":
            suggest = "any_local"
        elif key == "anyRemote":
            suggest = "any_remote"
        elif key == "repoKeys":
            suggest = "repo_keys"
        elif key == "excludePatterns":
            suggest = "exclude_patterns"
        elif key == "includePatterns":
            suggest = "include_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ArtifactWebhookCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ArtifactWebhookCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ArtifactWebhookCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_federated: _builtins.bool,
                 any_local: _builtins.bool,
                 any_remote: _builtins.bool,
                 repo_keys: Sequence[_builtins.str],
                 exclude_patterns: Optional[Sequence[_builtins.str]] = None,
                 include_patterns: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.bool any_federated: Trigger on any federated repo.
        :param _builtins.bool any_local: Trigger on any local repo.
        :param _builtins.bool any_remote: Trigger on any remote repo.
        :param Sequence[_builtins.str] repo_keys: Trigger on this list of repo keys.
        :param Sequence[_builtins.str] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        :param Sequence[_builtins.str] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        pulumi.set(__self__, "any_federated", any_federated)
        pulumi.set(__self__, "any_local", any_local)
        pulumi.set(__self__, "any_remote", any_remote)
        pulumi.set(__self__, "repo_keys", repo_keys)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @_builtins.property
    @pulumi.getter(name="anyFederated")
    def any_federated(self) -> _builtins.bool:
        """
        Trigger on any federated repo.
        """
        return pulumi.get(self, "any_federated")

    @_builtins.property
    @pulumi.getter(name="anyLocal")
    def any_local(self) -> _builtins.bool:
        """
        Trigger on any local repo.
        """
        return pulumi.get(self, "any_local")

    @_builtins.property
    @pulumi.getter(name="anyRemote")
    def any_remote(self) -> _builtins.bool:
        """
        Trigger on any remote repo.
        """
        return pulumi.get(self, "any_remote")

    @_builtins.property
    @pulumi.getter(name="repoKeys")
    def repo_keys(self) -> Sequence[_builtins.str]:
        """
        Trigger on this list of repo keys.
        """
        return pulumi.get(self, "repo_keys")

    @_builtins.property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "exclude_patterns")

    @_builtins.property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "include_patterns")


@pulumi.output_type
class ArtifactWebhookHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customHttpHeaders":
            suggest = "custom_http_headers"
        elif key == "useSecretForSigning":
            suggest = "use_secret_for_signing"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ArtifactWebhookHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ArtifactWebhookHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ArtifactWebhookHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: _builtins.str,
                 custom_http_headers: Optional[Mapping[str, _builtins.str]] = None,
                 proxy: Optional[_builtins.str] = None,
                 secret: Optional[_builtins.str] = None,
                 use_secret_for_signing: Optional[_builtins.bool] = None):
        """
        :param _builtins.str url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param Mapping[str, _builtins.str] custom_http_headers: Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        :param _builtins.str proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param _builtins.str secret: Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        :param _builtins.bool use_secret_for_signing: When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        pulumi.set(__self__, "url", url)
        if custom_http_headers is not None:
            pulumi.set(__self__, "custom_http_headers", custom_http_headers)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if use_secret_for_signing is not None:
            pulumi.set(__self__, "use_secret_for_signing", use_secret_for_signing)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="customHttpHeaders")
    def custom_http_headers(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        return pulumi.get(self, "custom_http_headers")

    @_builtins.property
    @pulumi.getter
    def proxy(self) -> Optional[_builtins.str]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[_builtins.str]:
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter(name="useSecretForSigning")
    def use_secret_for_signing(self) -> Optional[_builtins.bool]:
        """
        When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        return pulumi.get(self, "use_secret_for_signing")


@pulumi.output_type
class ArtifactoryReleaseBundleCustomWebhookCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyReleaseBundle":
            suggest = "any_release_bundle"
        elif key == "registeredReleaseBundleNames":
            suggest = "registered_release_bundle_names"
        elif key == "excludePatterns":
            suggest = "exclude_patterns"
        elif key == "includePatterns":
            suggest = "include_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ArtifactoryReleaseBundleCustomWebhookCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ArtifactoryReleaseBundleCustomWebhookCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ArtifactoryReleaseBundleCustomWebhookCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_release_bundle: _builtins.bool,
                 registered_release_bundle_names: Sequence[_builtins.str],
                 exclude_patterns: Optional[Sequence[_builtins.str]] = None,
                 include_patterns: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.bool any_release_bundle: Trigger on any release bundle
        :param Sequence[_builtins.str] registered_release_bundle_names: Trigger on this list of release bundle names
        :param Sequence[_builtins.str] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`
        :param Sequence[_builtins.str] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`
        """
        pulumi.set(__self__, "any_release_bundle", any_release_bundle)
        pulumi.set(__self__, "registered_release_bundle_names", registered_release_bundle_names)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @_builtins.property
    @pulumi.getter(name="anyReleaseBundle")
    def any_release_bundle(self) -> _builtins.bool:
        """
        Trigger on any release bundle
        """
        return pulumi.get(self, "any_release_bundle")

    @_builtins.property
    @pulumi.getter(name="registeredReleaseBundleNames")
    def registered_release_bundle_names(self) -> Sequence[_builtins.str]:
        """
        Trigger on this list of release bundle names
        """
        return pulumi.get(self, "registered_release_bundle_names")

    @_builtins.property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`
        """
        return pulumi.get(self, "exclude_patterns")

    @_builtins.property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`
        """
        return pulumi.get(self, "include_patterns")


@pulumi.output_type
class ArtifactoryReleaseBundleCustomWebhookHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpHeaders":
            suggest = "http_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ArtifactoryReleaseBundleCustomWebhookHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ArtifactoryReleaseBundleCustomWebhookHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ArtifactoryReleaseBundleCustomWebhookHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: _builtins.str,
                 http_headers: Optional[Mapping[str, _builtins.str]] = None,
                 method: Optional[_builtins.str] = None,
                 payload: Optional[_builtins.str] = None,
                 proxy: Optional[_builtins.str] = None,
                 secrets: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param Mapping[str, _builtins.str] http_headers: HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        :param _builtins.str method: Specifies the HTTP method for the URL that the Webhook invokes. Allowed values are: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`.
        :param _builtins.str payload: This attribute is used to build the request body. Used in custom webhooks
        :param _builtins.str proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param Mapping[str, _builtins.str] secrets: Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
        pulumi.set(__self__, "url", url)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        """
        return pulumi.get(self, "http_headers")

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[_builtins.str]:
        """
        Specifies the HTTP method for the URL that the Webhook invokes. Allowed values are: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`.
        """
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter
    def payload(self) -> Optional[_builtins.str]:
        """
        This attribute is used to build the request body. Used in custom webhooks
        """
        return pulumi.get(self, "payload")

    @_builtins.property
    @pulumi.getter
    def proxy(self) -> Optional[_builtins.str]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @_builtins.property
    @pulumi.getter
    def secrets(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
        return pulumi.get(self, "secrets")


@pulumi.output_type
class ArtifactoryReleaseBundleWebhookCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyReleaseBundle":
            suggest = "any_release_bundle"
        elif key == "registeredReleaseBundleNames":
            suggest = "registered_release_bundle_names"
        elif key == "excludePatterns":
            suggest = "exclude_patterns"
        elif key == "includePatterns":
            suggest = "include_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ArtifactoryReleaseBundleWebhookCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ArtifactoryReleaseBundleWebhookCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ArtifactoryReleaseBundleWebhookCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_release_bundle: _builtins.bool,
                 registered_release_bundle_names: Sequence[_builtins.str],
                 exclude_patterns: Optional[Sequence[_builtins.str]] = None,
                 include_patterns: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.bool any_release_bundle: Trigger on any release bundle
        :param Sequence[_builtins.str] registered_release_bundle_names: Trigger on this list of release bundle names
        :param Sequence[_builtins.str] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`
        :param Sequence[_builtins.str] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`
        """
        pulumi.set(__self__, "any_release_bundle", any_release_bundle)
        pulumi.set(__self__, "registered_release_bundle_names", registered_release_bundle_names)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @_builtins.property
    @pulumi.getter(name="anyReleaseBundle")
    def any_release_bundle(self) -> _builtins.bool:
        """
        Trigger on any release bundle
        """
        return pulumi.get(self, "any_release_bundle")

    @_builtins.property
    @pulumi.getter(name="registeredReleaseBundleNames")
    def registered_release_bundle_names(self) -> Sequence[_builtins.str]:
        """
        Trigger on this list of release bundle names
        """
        return pulumi.get(self, "registered_release_bundle_names")

    @_builtins.property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`
        """
        return pulumi.get(self, "exclude_patterns")

    @_builtins.property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`
        """
        return pulumi.get(self, "include_patterns")


@pulumi.output_type
class ArtifactoryReleaseBundleWebhookHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customHttpHeaders":
            suggest = "custom_http_headers"
        elif key == "useSecretForSigning":
            suggest = "use_secret_for_signing"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ArtifactoryReleaseBundleWebhookHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ArtifactoryReleaseBundleWebhookHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ArtifactoryReleaseBundleWebhookHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: _builtins.str,
                 custom_http_headers: Optional[Mapping[str, _builtins.str]] = None,
                 proxy: Optional[_builtins.str] = None,
                 secret: Optional[_builtins.str] = None,
                 use_secret_for_signing: Optional[_builtins.bool] = None):
        """
        :param _builtins.str url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param Mapping[str, _builtins.str] custom_http_headers: Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        :param _builtins.str proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param _builtins.str secret: Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        :param _builtins.bool use_secret_for_signing: When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        pulumi.set(__self__, "url", url)
        if custom_http_headers is not None:
            pulumi.set(__self__, "custom_http_headers", custom_http_headers)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if use_secret_for_signing is not None:
            pulumi.set(__self__, "use_secret_for_signing", use_secret_for_signing)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="customHttpHeaders")
    def custom_http_headers(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        return pulumi.get(self, "custom_http_headers")

    @_builtins.property
    @pulumi.getter
    def proxy(self) -> Optional[_builtins.str]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[_builtins.str]:
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter(name="useSecretForSigning")
    def use_secret_for_signing(self) -> Optional[_builtins.bool]:
        """
        When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        return pulumi.get(self, "use_secret_for_signing")


@pulumi.output_type
class BuildCustomWebhookCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyBuild":
            suggest = "any_build"
        elif key == "selectedBuilds":
            suggest = "selected_builds"
        elif key == "excludePatterns":
            suggest = "exclude_patterns"
        elif key == "includePatterns":
            suggest = "include_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BuildCustomWebhookCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BuildCustomWebhookCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BuildCustomWebhookCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_build: _builtins.bool,
                 selected_builds: Sequence[_builtins.str],
                 exclude_patterns: Optional[Sequence[_builtins.str]] = None,
                 include_patterns: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.bool any_build: Trigger on any build.
        :param Sequence[_builtins.str] selected_builds: Trigger on this list of build names.
        :param Sequence[_builtins.str] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        :param Sequence[_builtins.str] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        pulumi.set(__self__, "any_build", any_build)
        pulumi.set(__self__, "selected_builds", selected_builds)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @_builtins.property
    @pulumi.getter(name="anyBuild")
    def any_build(self) -> _builtins.bool:
        """
        Trigger on any build.
        """
        return pulumi.get(self, "any_build")

    @_builtins.property
    @pulumi.getter(name="selectedBuilds")
    def selected_builds(self) -> Sequence[_builtins.str]:
        """
        Trigger on this list of build names.
        """
        return pulumi.get(self, "selected_builds")

    @_builtins.property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "exclude_patterns")

    @_builtins.property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "include_patterns")


@pulumi.output_type
class BuildCustomWebhookHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpHeaders":
            suggest = "http_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BuildCustomWebhookHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BuildCustomWebhookHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BuildCustomWebhookHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: _builtins.str,
                 http_headers: Optional[Mapping[str, _builtins.str]] = None,
                 method: Optional[_builtins.str] = None,
                 payload: Optional[_builtins.str] = None,
                 proxy: Optional[_builtins.str] = None,
                 secrets: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param Mapping[str, _builtins.str] http_headers: HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        :param _builtins.str method: Specifies the HTTP method for the URL that the Webhook invokes. Allowed values are: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`.
        :param _builtins.str payload: This attribute is used to build the request body. Used in custom webhooks
        :param _builtins.str proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param Mapping[str, _builtins.str] secrets: Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
        pulumi.set(__self__, "url", url)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        """
        return pulumi.get(self, "http_headers")

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[_builtins.str]:
        """
        Specifies the HTTP method for the URL that the Webhook invokes. Allowed values are: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`.
        """
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter
    def payload(self) -> Optional[_builtins.str]:
        """
        This attribute is used to build the request body. Used in custom webhooks
        """
        return pulumi.get(self, "payload")

    @_builtins.property
    @pulumi.getter
    def proxy(self) -> Optional[_builtins.str]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @_builtins.property
    @pulumi.getter
    def secrets(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
        return pulumi.get(self, "secrets")


@pulumi.output_type
class BuildWebhookCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyBuild":
            suggest = "any_build"
        elif key == "selectedBuilds":
            suggest = "selected_builds"
        elif key == "excludePatterns":
            suggest = "exclude_patterns"
        elif key == "includePatterns":
            suggest = "include_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BuildWebhookCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BuildWebhookCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BuildWebhookCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_build: _builtins.bool,
                 selected_builds: Sequence[_builtins.str],
                 exclude_patterns: Optional[Sequence[_builtins.str]] = None,
                 include_patterns: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.bool any_build: Trigger on any build.
        :param Sequence[_builtins.str] selected_builds: Trigger on this list of build names.
        :param Sequence[_builtins.str] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        :param Sequence[_builtins.str] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        pulumi.set(__self__, "any_build", any_build)
        pulumi.set(__self__, "selected_builds", selected_builds)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @_builtins.property
    @pulumi.getter(name="anyBuild")
    def any_build(self) -> _builtins.bool:
        """
        Trigger on any build.
        """
        return pulumi.get(self, "any_build")

    @_builtins.property
    @pulumi.getter(name="selectedBuilds")
    def selected_builds(self) -> Sequence[_builtins.str]:
        """
        Trigger on this list of build names.
        """
        return pulumi.get(self, "selected_builds")

    @_builtins.property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "exclude_patterns")

    @_builtins.property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "include_patterns")


@pulumi.output_type
class BuildWebhookHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customHttpHeaders":
            suggest = "custom_http_headers"
        elif key == "useSecretForSigning":
            suggest = "use_secret_for_signing"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BuildWebhookHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BuildWebhookHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BuildWebhookHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: _builtins.str,
                 custom_http_headers: Optional[Mapping[str, _builtins.str]] = None,
                 proxy: Optional[_builtins.str] = None,
                 secret: Optional[_builtins.str] = None,
                 use_secret_for_signing: Optional[_builtins.bool] = None):
        """
        :param _builtins.str url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param Mapping[str, _builtins.str] custom_http_headers: Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        :param _builtins.str proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param _builtins.str secret: Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        :param _builtins.bool use_secret_for_signing: When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        pulumi.set(__self__, "url", url)
        if custom_http_headers is not None:
            pulumi.set(__self__, "custom_http_headers", custom_http_headers)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if use_secret_for_signing is not None:
            pulumi.set(__self__, "use_secret_for_signing", use_secret_for_signing)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="customHttpHeaders")
    def custom_http_headers(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        return pulumi.get(self, "custom_http_headers")

    @_builtins.property
    @pulumi.getter
    def proxy(self) -> Optional[_builtins.str]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[_builtins.str]:
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter(name="useSecretForSigning")
    def use_secret_for_signing(self) -> Optional[_builtins.bool]:
        """
        When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        return pulumi.get(self, "use_secret_for_signing")


@pulumi.output_type
class DestinationCustomWebhookCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyReleaseBundle":
            suggest = "any_release_bundle"
        elif key == "registeredReleaseBundleNames":
            suggest = "registered_release_bundle_names"
        elif key == "excludePatterns":
            suggest = "exclude_patterns"
        elif key == "includePatterns":
            suggest = "include_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationCustomWebhookCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationCustomWebhookCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationCustomWebhookCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_release_bundle: _builtins.bool,
                 registered_release_bundle_names: Sequence[_builtins.str],
                 exclude_patterns: Optional[Sequence[_builtins.str]] = None,
                 include_patterns: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.bool any_release_bundle: Trigger on any release bundle
        :param Sequence[_builtins.str] registered_release_bundle_names: Trigger on this list of release bundle names
        :param Sequence[_builtins.str] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`
        :param Sequence[_builtins.str] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`
        """
        pulumi.set(__self__, "any_release_bundle", any_release_bundle)
        pulumi.set(__self__, "registered_release_bundle_names", registered_release_bundle_names)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @_builtins.property
    @pulumi.getter(name="anyReleaseBundle")
    def any_release_bundle(self) -> _builtins.bool:
        """
        Trigger on any release bundle
        """
        return pulumi.get(self, "any_release_bundle")

    @_builtins.property
    @pulumi.getter(name="registeredReleaseBundleNames")
    def registered_release_bundle_names(self) -> Sequence[_builtins.str]:
        """
        Trigger on this list of release bundle names
        """
        return pulumi.get(self, "registered_release_bundle_names")

    @_builtins.property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`
        """
        return pulumi.get(self, "exclude_patterns")

    @_builtins.property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`
        """
        return pulumi.get(self, "include_patterns")


@pulumi.output_type
class DestinationCustomWebhookHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpHeaders":
            suggest = "http_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationCustomWebhookHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationCustomWebhookHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationCustomWebhookHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: _builtins.str,
                 http_headers: Optional[Mapping[str, _builtins.str]] = None,
                 method: Optional[_builtins.str] = None,
                 payload: Optional[_builtins.str] = None,
                 proxy: Optional[_builtins.str] = None,
                 secrets: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param Mapping[str, _builtins.str] http_headers: HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        :param _builtins.str method: Specifies the HTTP method for the URL that the Webhook invokes. Allowed values are: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`.
        :param _builtins.str payload: This attribute is used to build the request body. Used in custom webhooks
        :param _builtins.str proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param Mapping[str, _builtins.str] secrets: Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
        pulumi.set(__self__, "url", url)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        """
        return pulumi.get(self, "http_headers")

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[_builtins.str]:
        """
        Specifies the HTTP method for the URL that the Webhook invokes. Allowed values are: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`.
        """
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter
    def payload(self) -> Optional[_builtins.str]:
        """
        This attribute is used to build the request body. Used in custom webhooks
        """
        return pulumi.get(self, "payload")

    @_builtins.property
    @pulumi.getter
    def proxy(self) -> Optional[_builtins.str]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @_builtins.property
    @pulumi.getter
    def secrets(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
        return pulumi.get(self, "secrets")


@pulumi.output_type
class DestinationWebhookCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyReleaseBundle":
            suggest = "any_release_bundle"
        elif key == "registeredReleaseBundleNames":
            suggest = "registered_release_bundle_names"
        elif key == "excludePatterns":
            suggest = "exclude_patterns"
        elif key == "includePatterns":
            suggest = "include_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationWebhookCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationWebhookCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationWebhookCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_release_bundle: _builtins.bool,
                 registered_release_bundle_names: Sequence[_builtins.str],
                 exclude_patterns: Optional[Sequence[_builtins.str]] = None,
                 include_patterns: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.bool any_release_bundle: Trigger on any release bundle
        :param Sequence[_builtins.str] registered_release_bundle_names: Trigger on this list of release bundle names
        :param Sequence[_builtins.str] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`
        :param Sequence[_builtins.str] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`
        """
        pulumi.set(__self__, "any_release_bundle", any_release_bundle)
        pulumi.set(__self__, "registered_release_bundle_names", registered_release_bundle_names)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @_builtins.property
    @pulumi.getter(name="anyReleaseBundle")
    def any_release_bundle(self) -> _builtins.bool:
        """
        Trigger on any release bundle
        """
        return pulumi.get(self, "any_release_bundle")

    @_builtins.property
    @pulumi.getter(name="registeredReleaseBundleNames")
    def registered_release_bundle_names(self) -> Sequence[_builtins.str]:
        """
        Trigger on this list of release bundle names
        """
        return pulumi.get(self, "registered_release_bundle_names")

    @_builtins.property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`
        """
        return pulumi.get(self, "exclude_patterns")

    @_builtins.property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`
        """
        return pulumi.get(self, "include_patterns")


@pulumi.output_type
class DestinationWebhookHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customHttpHeaders":
            suggest = "custom_http_headers"
        elif key == "useSecretForSigning":
            suggest = "use_secret_for_signing"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationWebhookHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationWebhookHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationWebhookHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: _builtins.str,
                 custom_http_headers: Optional[Mapping[str, _builtins.str]] = None,
                 proxy: Optional[_builtins.str] = None,
                 secret: Optional[_builtins.str] = None,
                 use_secret_for_signing: Optional[_builtins.bool] = None):
        """
        :param _builtins.str url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param Mapping[str, _builtins.str] custom_http_headers: Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        :param _builtins.str proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param _builtins.str secret: Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        :param _builtins.bool use_secret_for_signing: When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        pulumi.set(__self__, "url", url)
        if custom_http_headers is not None:
            pulumi.set(__self__, "custom_http_headers", custom_http_headers)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if use_secret_for_signing is not None:
            pulumi.set(__self__, "use_secret_for_signing", use_secret_for_signing)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="customHttpHeaders")
    def custom_http_headers(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        return pulumi.get(self, "custom_http_headers")

    @_builtins.property
    @pulumi.getter
    def proxy(self) -> Optional[_builtins.str]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[_builtins.str]:
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter(name="useSecretForSigning")
    def use_secret_for_signing(self) -> Optional[_builtins.bool]:
        """
        When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        return pulumi.get(self, "use_secret_for_signing")


@pulumi.output_type
class DistributionCustomWebhookCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyReleaseBundle":
            suggest = "any_release_bundle"
        elif key == "registeredReleaseBundleNames":
            suggest = "registered_release_bundle_names"
        elif key == "excludePatterns":
            suggest = "exclude_patterns"
        elif key == "includePatterns":
            suggest = "include_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DistributionCustomWebhookCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DistributionCustomWebhookCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DistributionCustomWebhookCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_release_bundle: _builtins.bool,
                 registered_release_bundle_names: Sequence[_builtins.str],
                 exclude_patterns: Optional[Sequence[_builtins.str]] = None,
                 include_patterns: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.bool any_release_bundle: Trigger on any release bundle.
        :param Sequence[_builtins.str] registered_release_bundle_names: Trigger on this list of release bundle names.
        :param Sequence[_builtins.str] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        :param Sequence[_builtins.str] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        pulumi.set(__self__, "any_release_bundle", any_release_bundle)
        pulumi.set(__self__, "registered_release_bundle_names", registered_release_bundle_names)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @_builtins.property
    @pulumi.getter(name="anyReleaseBundle")
    def any_release_bundle(self) -> _builtins.bool:
        """
        Trigger on any release bundle.
        """
        return pulumi.get(self, "any_release_bundle")

    @_builtins.property
    @pulumi.getter(name="registeredReleaseBundleNames")
    def registered_release_bundle_names(self) -> Sequence[_builtins.str]:
        """
        Trigger on this list of release bundle names.
        """
        return pulumi.get(self, "registered_release_bundle_names")

    @_builtins.property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "exclude_patterns")

    @_builtins.property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "include_patterns")


@pulumi.output_type
class DistributionCustomWebhookHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpHeaders":
            suggest = "http_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DistributionCustomWebhookHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DistributionCustomWebhookHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DistributionCustomWebhookHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: _builtins.str,
                 http_headers: Optional[Mapping[str, _builtins.str]] = None,
                 method: Optional[_builtins.str] = None,
                 payload: Optional[_builtins.str] = None,
                 proxy: Optional[_builtins.str] = None,
                 secrets: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param Mapping[str, _builtins.str] http_headers: HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        :param _builtins.str method: Specifies the HTTP method for the URL that the Webhook invokes. Allowed values are: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`.
        :param _builtins.str payload: This attribute is used to build the request body. Used in custom webhooks
        :param _builtins.str proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param Mapping[str, _builtins.str] secrets: Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
        pulumi.set(__self__, "url", url)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        """
        return pulumi.get(self, "http_headers")

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[_builtins.str]:
        """
        Specifies the HTTP method for the URL that the Webhook invokes. Allowed values are: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`.
        """
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter
    def payload(self) -> Optional[_builtins.str]:
        """
        This attribute is used to build the request body. Used in custom webhooks
        """
        return pulumi.get(self, "payload")

    @_builtins.property
    @pulumi.getter
    def proxy(self) -> Optional[_builtins.str]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @_builtins.property
    @pulumi.getter
    def secrets(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
        return pulumi.get(self, "secrets")


@pulumi.output_type
class DistributionWebhookCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyReleaseBundle":
            suggest = "any_release_bundle"
        elif key == "registeredReleaseBundleNames":
            suggest = "registered_release_bundle_names"
        elif key == "excludePatterns":
            suggest = "exclude_patterns"
        elif key == "includePatterns":
            suggest = "include_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DistributionWebhookCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DistributionWebhookCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DistributionWebhookCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_release_bundle: _builtins.bool,
                 registered_release_bundle_names: Sequence[_builtins.str],
                 exclude_patterns: Optional[Sequence[_builtins.str]] = None,
                 include_patterns: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.bool any_release_bundle: Trigger on any release bundle.
        :param Sequence[_builtins.str] registered_release_bundle_names: Trigger on this list of release bundle names.
        :param Sequence[_builtins.str] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        :param Sequence[_builtins.str] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        pulumi.set(__self__, "any_release_bundle", any_release_bundle)
        pulumi.set(__self__, "registered_release_bundle_names", registered_release_bundle_names)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @_builtins.property
    @pulumi.getter(name="anyReleaseBundle")
    def any_release_bundle(self) -> _builtins.bool:
        """
        Trigger on any release bundle.
        """
        return pulumi.get(self, "any_release_bundle")

    @_builtins.property
    @pulumi.getter(name="registeredReleaseBundleNames")
    def registered_release_bundle_names(self) -> Sequence[_builtins.str]:
        """
        Trigger on this list of release bundle names.
        """
        return pulumi.get(self, "registered_release_bundle_names")

    @_builtins.property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "exclude_patterns")

    @_builtins.property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "include_patterns")


@pulumi.output_type
class DistributionWebhookHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customHttpHeaders":
            suggest = "custom_http_headers"
        elif key == "useSecretForSigning":
            suggest = "use_secret_for_signing"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DistributionWebhookHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DistributionWebhookHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DistributionWebhookHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: _builtins.str,
                 custom_http_headers: Optional[Mapping[str, _builtins.str]] = None,
                 proxy: Optional[_builtins.str] = None,
                 secret: Optional[_builtins.str] = None,
                 use_secret_for_signing: Optional[_builtins.bool] = None):
        """
        :param _builtins.str url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param Mapping[str, _builtins.str] custom_http_headers: Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        :param _builtins.str proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param _builtins.str secret: Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        :param _builtins.bool use_secret_for_signing: When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        pulumi.set(__self__, "url", url)
        if custom_http_headers is not None:
            pulumi.set(__self__, "custom_http_headers", custom_http_headers)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if use_secret_for_signing is not None:
            pulumi.set(__self__, "use_secret_for_signing", use_secret_for_signing)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="customHttpHeaders")
    def custom_http_headers(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        return pulumi.get(self, "custom_http_headers")

    @_builtins.property
    @pulumi.getter
    def proxy(self) -> Optional[_builtins.str]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[_builtins.str]:
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter(name="useSecretForSigning")
    def use_secret_for_signing(self) -> Optional[_builtins.bool]:
        """
        When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        return pulumi.get(self, "use_secret_for_signing")


@pulumi.output_type
class DockerCustomWebhookCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyFederated":
            suggest = "any_federated"
        elif key == "anyLocal":
            suggest = "any_local"
        elif key == "anyRemote":
            suggest = "any_remote"
        elif key == "repoKeys":
            suggest = "repo_keys"
        elif key == "excludePatterns":
            suggest = "exclude_patterns"
        elif key == "includePatterns":
            suggest = "include_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DockerCustomWebhookCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DockerCustomWebhookCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DockerCustomWebhookCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_federated: _builtins.bool,
                 any_local: _builtins.bool,
                 any_remote: _builtins.bool,
                 repo_keys: Sequence[_builtins.str],
                 exclude_patterns: Optional[Sequence[_builtins.str]] = None,
                 include_patterns: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.bool any_federated: Trigger on any federated repositories
        :param _builtins.bool any_local: Trigger on any local repo.
        :param _builtins.bool any_remote: Trigger on any remote repo.
        :param Sequence[_builtins.str] repo_keys: Trigger on this list of repo keys.
        :param Sequence[_builtins.str] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        :param Sequence[_builtins.str] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        pulumi.set(__self__, "any_federated", any_federated)
        pulumi.set(__self__, "any_local", any_local)
        pulumi.set(__self__, "any_remote", any_remote)
        pulumi.set(__self__, "repo_keys", repo_keys)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @_builtins.property
    @pulumi.getter(name="anyFederated")
    def any_federated(self) -> _builtins.bool:
        """
        Trigger on any federated repositories
        """
        return pulumi.get(self, "any_federated")

    @_builtins.property
    @pulumi.getter(name="anyLocal")
    def any_local(self) -> _builtins.bool:
        """
        Trigger on any local repo.
        """
        return pulumi.get(self, "any_local")

    @_builtins.property
    @pulumi.getter(name="anyRemote")
    def any_remote(self) -> _builtins.bool:
        """
        Trigger on any remote repo.
        """
        return pulumi.get(self, "any_remote")

    @_builtins.property
    @pulumi.getter(name="repoKeys")
    def repo_keys(self) -> Sequence[_builtins.str]:
        """
        Trigger on this list of repo keys.
        """
        return pulumi.get(self, "repo_keys")

    @_builtins.property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "exclude_patterns")

    @_builtins.property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "include_patterns")


@pulumi.output_type
class DockerCustomWebhookHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpHeaders":
            suggest = "http_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DockerCustomWebhookHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DockerCustomWebhookHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DockerCustomWebhookHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: _builtins.str,
                 http_headers: Optional[Mapping[str, _builtins.str]] = None,
                 method: Optional[_builtins.str] = None,
                 payload: Optional[_builtins.str] = None,
                 proxy: Optional[_builtins.str] = None,
                 secrets: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param Mapping[str, _builtins.str] http_headers: HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        :param _builtins.str method: Specifies the HTTP method for the URL that the Webhook invokes. Allowed values are: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`.
        :param _builtins.str payload: This attribute is used to build the request body. Used in custom webhooks
        :param _builtins.str proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param Mapping[str, _builtins.str] secrets: Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
        pulumi.set(__self__, "url", url)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        """
        return pulumi.get(self, "http_headers")

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[_builtins.str]:
        """
        Specifies the HTTP method for the URL that the Webhook invokes. Allowed values are: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`.
        """
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter
    def payload(self) -> Optional[_builtins.str]:
        """
        This attribute is used to build the request body. Used in custom webhooks
        """
        return pulumi.get(self, "payload")

    @_builtins.property
    @pulumi.getter
    def proxy(self) -> Optional[_builtins.str]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @_builtins.property
    @pulumi.getter
    def secrets(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
        return pulumi.get(self, "secrets")


@pulumi.output_type
class DockerWebhookCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyFederated":
            suggest = "any_federated"
        elif key == "anyLocal":
            suggest = "any_local"
        elif key == "anyRemote":
            suggest = "any_remote"
        elif key == "repoKeys":
            suggest = "repo_keys"
        elif key == "excludePatterns":
            suggest = "exclude_patterns"
        elif key == "includePatterns":
            suggest = "include_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DockerWebhookCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DockerWebhookCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DockerWebhookCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_federated: _builtins.bool,
                 any_local: _builtins.bool,
                 any_remote: _builtins.bool,
                 repo_keys: Sequence[_builtins.str],
                 exclude_patterns: Optional[Sequence[_builtins.str]] = None,
                 include_patterns: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.bool any_federated: Trigger on any federated repo.
        :param _builtins.bool any_local: Trigger on any local repo.
        :param _builtins.bool any_remote: Trigger on any remote repo.
        :param Sequence[_builtins.str] repo_keys: Trigger on this list of repo keys.
        :param Sequence[_builtins.str] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        :param Sequence[_builtins.str] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        pulumi.set(__self__, "any_federated", any_federated)
        pulumi.set(__self__, "any_local", any_local)
        pulumi.set(__self__, "any_remote", any_remote)
        pulumi.set(__self__, "repo_keys", repo_keys)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @_builtins.property
    @pulumi.getter(name="anyFederated")
    def any_federated(self) -> _builtins.bool:
        """
        Trigger on any federated repo.
        """
        return pulumi.get(self, "any_federated")

    @_builtins.property
    @pulumi.getter(name="anyLocal")
    def any_local(self) -> _builtins.bool:
        """
        Trigger on any local repo.
        """
        return pulumi.get(self, "any_local")

    @_builtins.property
    @pulumi.getter(name="anyRemote")
    def any_remote(self) -> _builtins.bool:
        """
        Trigger on any remote repo.
        """
        return pulumi.get(self, "any_remote")

    @_builtins.property
    @pulumi.getter(name="repoKeys")
    def repo_keys(self) -> Sequence[_builtins.str]:
        """
        Trigger on this list of repo keys.
        """
        return pulumi.get(self, "repo_keys")

    @_builtins.property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "exclude_patterns")

    @_builtins.property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "include_patterns")


@pulumi.output_type
class DockerWebhookHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customHttpHeaders":
            suggest = "custom_http_headers"
        elif key == "useSecretForSigning":
            suggest = "use_secret_for_signing"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DockerWebhookHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DockerWebhookHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DockerWebhookHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: _builtins.str,
                 custom_http_headers: Optional[Mapping[str, _builtins.str]] = None,
                 proxy: Optional[_builtins.str] = None,
                 secret: Optional[_builtins.str] = None,
                 use_secret_for_signing: Optional[_builtins.bool] = None):
        """
        :param _builtins.str url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param Mapping[str, _builtins.str] custom_http_headers: Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        :param _builtins.str proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param _builtins.str secret: Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        :param _builtins.bool use_secret_for_signing: When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        pulumi.set(__self__, "url", url)
        if custom_http_headers is not None:
            pulumi.set(__self__, "custom_http_headers", custom_http_headers)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if use_secret_for_signing is not None:
            pulumi.set(__self__, "use_secret_for_signing", use_secret_for_signing)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="customHttpHeaders")
    def custom_http_headers(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        return pulumi.get(self, "custom_http_headers")

    @_builtins.property
    @pulumi.getter
    def proxy(self) -> Optional[_builtins.str]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[_builtins.str]:
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter(name="useSecretForSigning")
    def use_secret_for_signing(self) -> Optional[_builtins.bool]:
        """
        When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        return pulumi.get(self, "use_secret_for_signing")


@pulumi.output_type
class FederatedAlpineRepositoryMember(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FederatedAlpineRepositoryMember. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FederatedAlpineRepositoryMember.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FederatedAlpineRepositoryMember.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class FederatedAnsibleRepositoryMember(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FederatedAnsibleRepositoryMember. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FederatedAnsibleRepositoryMember.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FederatedAnsibleRepositoryMember.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class FederatedBowerRepositoryMember(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FederatedBowerRepositoryMember. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FederatedBowerRepositoryMember.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FederatedBowerRepositoryMember.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class FederatedCargoRepositoryMember(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FederatedCargoRepositoryMember. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FederatedCargoRepositoryMember.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FederatedCargoRepositoryMember.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class FederatedChefRepositoryMember(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FederatedChefRepositoryMember. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FederatedChefRepositoryMember.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FederatedChefRepositoryMember.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class FederatedCocoapodsRepositoryMember(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FederatedCocoapodsRepositoryMember. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FederatedCocoapodsRepositoryMember.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FederatedCocoapodsRepositoryMember.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class FederatedComposerRepositoryMember(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FederatedComposerRepositoryMember. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FederatedComposerRepositoryMember.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FederatedComposerRepositoryMember.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class FederatedConanRepositoryMember(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FederatedConanRepositoryMember. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FederatedConanRepositoryMember.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FederatedConanRepositoryMember.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class FederatedCondaRepositoryMember(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FederatedCondaRepositoryMember. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FederatedCondaRepositoryMember.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FederatedCondaRepositoryMember.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class FederatedCranRepositoryMember(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FederatedCranRepositoryMember. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FederatedCranRepositoryMember.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FederatedCranRepositoryMember.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class FederatedDebianRepositoryMember(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FederatedDebianRepositoryMember. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FederatedDebianRepositoryMember.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FederatedDebianRepositoryMember.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class FederatedDockerRepositoryMember(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FederatedDockerRepositoryMember. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FederatedDockerRepositoryMember.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FederatedDockerRepositoryMember.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class FederatedDockerV1RepositoryMember(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FederatedDockerV1RepositoryMember. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FederatedDockerV1RepositoryMember.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FederatedDockerV1RepositoryMember.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class FederatedDockerV2RepositoryMember(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FederatedDockerV2RepositoryMember. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FederatedDockerV2RepositoryMember.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FederatedDockerV2RepositoryMember.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class FederatedGemsRepositoryMember(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FederatedGemsRepositoryMember. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FederatedGemsRepositoryMember.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FederatedGemsRepositoryMember.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class FederatedGenericRepositoryMember(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FederatedGenericRepositoryMember. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FederatedGenericRepositoryMember.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FederatedGenericRepositoryMember.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class FederatedGitltfsRepositoryMember(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FederatedGitltfsRepositoryMember. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FederatedGitltfsRepositoryMember.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FederatedGitltfsRepositoryMember.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class FederatedGoRepositoryMember(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FederatedGoRepositoryMember. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FederatedGoRepositoryMember.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FederatedGoRepositoryMember.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class FederatedGradleRepositoryMember(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FederatedGradleRepositoryMember. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FederatedGradleRepositoryMember.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FederatedGradleRepositoryMember.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class FederatedHelmRepositoryMember(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FederatedHelmRepositoryMember. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FederatedHelmRepositoryMember.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FederatedHelmRepositoryMember.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class FederatedHelmociRepositoryMember(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FederatedHelmociRepositoryMember. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FederatedHelmociRepositoryMember.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FederatedHelmociRepositoryMember.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class FederatedHuggingfacemlRepositoryMember(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FederatedHuggingfacemlRepositoryMember. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FederatedHuggingfacemlRepositoryMember.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FederatedHuggingfacemlRepositoryMember.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class FederatedIvyRepositoryMember(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FederatedIvyRepositoryMember. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FederatedIvyRepositoryMember.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FederatedIvyRepositoryMember.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class FederatedMavenRepositoryMember(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FederatedMavenRepositoryMember. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FederatedMavenRepositoryMember.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FederatedMavenRepositoryMember.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class FederatedNpmRepositoryMember(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FederatedNpmRepositoryMember. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FederatedNpmRepositoryMember.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FederatedNpmRepositoryMember.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class FederatedNugetRepositoryMember(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FederatedNugetRepositoryMember. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FederatedNugetRepositoryMember.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FederatedNugetRepositoryMember.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class FederatedOciRepositoryMember(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FederatedOciRepositoryMember. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FederatedOciRepositoryMember.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FederatedOciRepositoryMember.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class FederatedOpkgRepositoryMember(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FederatedOpkgRepositoryMember. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FederatedOpkgRepositoryMember.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FederatedOpkgRepositoryMember.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class FederatedPuppetRepositoryMember(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FederatedPuppetRepositoryMember. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FederatedPuppetRepositoryMember.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FederatedPuppetRepositoryMember.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class FederatedPypiRepositoryMember(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FederatedPypiRepositoryMember. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FederatedPypiRepositoryMember.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FederatedPypiRepositoryMember.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class FederatedRpmRepositoryMember(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FederatedRpmRepositoryMember. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FederatedRpmRepositoryMember.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FederatedRpmRepositoryMember.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class FederatedSbtRepositoryMember(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FederatedSbtRepositoryMember. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FederatedSbtRepositoryMember.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FederatedSbtRepositoryMember.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class FederatedSwiftRepositoryMember(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FederatedSwiftRepositoryMember. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FederatedSwiftRepositoryMember.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FederatedSwiftRepositoryMember.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class FederatedTerraformModuleRepositoryMember(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FederatedTerraformModuleRepositoryMember. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FederatedTerraformModuleRepositoryMember.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FederatedTerraformModuleRepositoryMember.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class FederatedTerraformProviderRepositoryMember(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FederatedTerraformProviderRepositoryMember. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FederatedTerraformProviderRepositoryMember.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FederatedTerraformProviderRepositoryMember.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class FederatedVagrantRepositoryMember(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FederatedVagrantRepositoryMember. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FederatedVagrantRepositoryMember.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FederatedVagrantRepositoryMember.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class LocalRepositoryMultiReplicationReplication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "checkBinaryExistenceInFilestore":
            suggest = "check_binary_existence_in_filestore"
        elif key == "disableProxy":
            suggest = "disable_proxy"
        elif key == "excludePathPrefixPattern":
            suggest = "exclude_path_prefix_pattern"
        elif key == "includePathPrefixPattern":
            suggest = "include_path_prefix_pattern"
        elif key == "replicationKey":
            suggest = "replication_key"
        elif key == "socketTimeoutMillis":
            suggest = "socket_timeout_millis"
        elif key == "syncDeletes":
            suggest = "sync_deletes"
        elif key == "syncProperties":
            suggest = "sync_properties"
        elif key == "syncStatistics":
            suggest = "sync_statistics"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LocalRepositoryMultiReplicationReplication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LocalRepositoryMultiReplicationReplication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LocalRepositoryMultiReplicationReplication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: _builtins.str,
                 username: _builtins.str,
                 check_binary_existence_in_filestore: Optional[_builtins.bool] = None,
                 disable_proxy: Optional[_builtins.bool] = None,
                 enabled: Optional[_builtins.bool] = None,
                 exclude_path_prefix_pattern: Optional[_builtins.str] = None,
                 include_path_prefix_pattern: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 proxy: Optional[_builtins.str] = None,
                 replication_key: Optional[_builtins.str] = None,
                 socket_timeout_millis: Optional[_builtins.int] = None,
                 sync_deletes: Optional[_builtins.bool] = None,
                 sync_properties: Optional[_builtins.bool] = None,
                 sync_statistics: Optional[_builtins.bool] = None):
        """
        :param _builtins.str url: The URL of the target local repository on a remote Artifactory server. Use the format `https://<artifactory_url>/artifactory/<repository_name>`.
        :param _builtins.str username: Username on the remote Artifactory instance.
        :param _builtins.bool check_binary_existence_in_filestore: Enabling the `check_binary_existence_in_filestore` flag requires an Enterprise Plus license. When true, enables distributed checksum storage. For more information, see [Optimizing Repository Replication with Checksum-Based Storage](https://www.jfrog.com/confluence/display/JFROG/Repository+Replication#RepositoryReplication-OptimizingRepositoryReplicationUsingStorageLevelSynchronizationOptions).
        :param _builtins.bool disable_proxy: When set to `true`, the `proxy` attribute will be ignored (from version 7.41.7). The default value is `false`.
        :param _builtins.bool enabled: When set, enables replication of this repository to the target specified in `url` attribute. Default value is `true`.
        :param _builtins.str exclude_path_prefix_pattern: List of artifact patterns to exclude when evaluating artifact requests, in the form of `x/y/**/z/*`. By default, no artifacts are excluded.
        :param _builtins.str include_path_prefix_pattern: List of artifact patterns to include when evaluating artifact requests in the form of `x/y/**/z/*`. When used, only artifacts matching one of the include patterns are served. By default, all artifacts are included `(**/*)`.
        :param _builtins.str password: Use either the HTTP authentication password or [identity token](https://www.jfrog.com/confluence/display/JFROG/User+Profile#UserProfile-IdentityTokenidentitytoken).
        :param _builtins.str proxy: Proxy key from Artifactory Proxies settings. The proxy configuration will be used when communicating with the remote instance.
        :param _builtins.str replication_key: Replication ID, the value is unknown until the resource is created. Can't be set or updated.
        :param _builtins.int socket_timeout_millis: The network timeout in milliseconds to use for remote operations. Default value is `15000`.
        :param _builtins.bool sync_deletes: When set, items that were deleted locally should also be deleted remotely (also applies to properties metadata). Note that enabling this option, will delete artifacts on the target that do not exist in the source repository. Default value is `false`.
        :param _builtins.bool sync_properties: When set, the task also synchronizes the properties of replicated artifacts. Default value is `true`.
        :param _builtins.bool sync_statistics: When set, the task also synchronizes artifact download statistics. Set to avoid inadvertent cleanup at the target instance when setting up replication for disaster recovery. Default value is `false`
        """
        pulumi.set(__self__, "url", url)
        pulumi.set(__self__, "username", username)
        if check_binary_existence_in_filestore is not None:
            pulumi.set(__self__, "check_binary_existence_in_filestore", check_binary_existence_in_filestore)
        if disable_proxy is not None:
            pulumi.set(__self__, "disable_proxy", disable_proxy)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if exclude_path_prefix_pattern is not None:
            pulumi.set(__self__, "exclude_path_prefix_pattern", exclude_path_prefix_pattern)
        if include_path_prefix_pattern is not None:
            pulumi.set(__self__, "include_path_prefix_pattern", include_path_prefix_pattern)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if replication_key is not None:
            pulumi.set(__self__, "replication_key", replication_key)
        if socket_timeout_millis is not None:
            pulumi.set(__self__, "socket_timeout_millis", socket_timeout_millis)
        if sync_deletes is not None:
            pulumi.set(__self__, "sync_deletes", sync_deletes)
        if sync_properties is not None:
            pulumi.set(__self__, "sync_properties", sync_properties)
        if sync_statistics is not None:
            pulumi.set(__self__, "sync_statistics", sync_statistics)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The URL of the target local repository on a remote Artifactory server. Use the format `https://<artifactory_url>/artifactory/<repository_name>`.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        Username on the remote Artifactory instance.
        """
        return pulumi.get(self, "username")

    @_builtins.property
    @pulumi.getter(name="checkBinaryExistenceInFilestore")
    def check_binary_existence_in_filestore(self) -> Optional[_builtins.bool]:
        """
        Enabling the `check_binary_existence_in_filestore` flag requires an Enterprise Plus license. When true, enables distributed checksum storage. For more information, see [Optimizing Repository Replication with Checksum-Based Storage](https://www.jfrog.com/confluence/display/JFROG/Repository+Replication#RepositoryReplication-OptimizingRepositoryReplicationUsingStorageLevelSynchronizationOptions).
        """
        return pulumi.get(self, "check_binary_existence_in_filestore")

    @_builtins.property
    @pulumi.getter(name="disableProxy")
    def disable_proxy(self) -> Optional[_builtins.bool]:
        """
        When set to `true`, the `proxy` attribute will be ignored (from version 7.41.7). The default value is `false`.
        """
        return pulumi.get(self, "disable_proxy")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        When set, enables replication of this repository to the target specified in `url` attribute. Default value is `true`.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="excludePathPrefixPattern")
    def exclude_path_prefix_pattern(self) -> Optional[_builtins.str]:
        """
        List of artifact patterns to exclude when evaluating artifact requests, in the form of `x/y/**/z/*`. By default, no artifacts are excluded.
        """
        return pulumi.get(self, "exclude_path_prefix_pattern")

    @_builtins.property
    @pulumi.getter(name="includePathPrefixPattern")
    def include_path_prefix_pattern(self) -> Optional[_builtins.str]:
        """
        List of artifact patterns to include when evaluating artifact requests in the form of `x/y/**/z/*`. When used, only artifacts matching one of the include patterns are served. By default, all artifacts are included `(**/*)`.
        """
        return pulumi.get(self, "include_path_prefix_pattern")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        Use either the HTTP authentication password or [identity token](https://www.jfrog.com/confluence/display/JFROG/User+Profile#UserProfile-IdentityTokenidentitytoken).
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def proxy(self) -> Optional[_builtins.str]:
        """
        Proxy key from Artifactory Proxies settings. The proxy configuration will be used when communicating with the remote instance.
        """
        return pulumi.get(self, "proxy")

    @_builtins.property
    @pulumi.getter(name="replicationKey")
    def replication_key(self) -> Optional[_builtins.str]:
        """
        Replication ID, the value is unknown until the resource is created. Can't be set or updated.
        """
        return pulumi.get(self, "replication_key")

    @_builtins.property
    @pulumi.getter(name="socketTimeoutMillis")
    def socket_timeout_millis(self) -> Optional[_builtins.int]:
        """
        The network timeout in milliseconds to use for remote operations. Default value is `15000`.
        """
        return pulumi.get(self, "socket_timeout_millis")

    @_builtins.property
    @pulumi.getter(name="syncDeletes")
    def sync_deletes(self) -> Optional[_builtins.bool]:
        """
        When set, items that were deleted locally should also be deleted remotely (also applies to properties metadata). Note that enabling this option, will delete artifacts on the target that do not exist in the source repository. Default value is `false`.
        """
        return pulumi.get(self, "sync_deletes")

    @_builtins.property
    @pulumi.getter(name="syncProperties")
    def sync_properties(self) -> Optional[_builtins.bool]:
        """
        When set, the task also synchronizes the properties of replicated artifacts. Default value is `true`.
        """
        return pulumi.get(self, "sync_properties")

    @_builtins.property
    @pulumi.getter(name="syncStatistics")
    def sync_statistics(self) -> Optional[_builtins.bool]:
        """
        When set, the task also synchronizes artifact download statistics. Set to avoid inadvertent cleanup at the target instance when setting up replication for disaster recovery. Default value is `false`
        """
        return pulumi.get(self, "sync_statistics")


@pulumi.output_type
class ManagedUserPasswordPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "specialChar":
            suggest = "special_char"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedUserPasswordPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedUserPasswordPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedUserPasswordPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 digit: Optional[_builtins.int] = None,
                 length: Optional[_builtins.int] = None,
                 lowercase: Optional[_builtins.int] = None,
                 special_char: Optional[_builtins.int] = None,
                 uppercase: Optional[_builtins.int] = None):
        """
        :param _builtins.int digit: Minimum number of digits that the password must contain
        :param _builtins.int length: Minimum length of the password
        :param _builtins.int lowercase: Minimum number of lowercase letters that the password must contain
        :param _builtins.int special_char: Minimum number of special char that the password must contain. Special chars list: `!"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~`
        :param _builtins.int uppercase: Minimum number of uppercase letters that the password must contain
        """
        if digit is not None:
            pulumi.set(__self__, "digit", digit)
        if length is not None:
            pulumi.set(__self__, "length", length)
        if lowercase is not None:
            pulumi.set(__self__, "lowercase", lowercase)
        if special_char is not None:
            pulumi.set(__self__, "special_char", special_char)
        if uppercase is not None:
            pulumi.set(__self__, "uppercase", uppercase)

    @_builtins.property
    @pulumi.getter
    def digit(self) -> Optional[_builtins.int]:
        """
        Minimum number of digits that the password must contain
        """
        return pulumi.get(self, "digit")

    @_builtins.property
    @pulumi.getter
    def length(self) -> Optional[_builtins.int]:
        """
        Minimum length of the password
        """
        return pulumi.get(self, "length")

    @_builtins.property
    @pulumi.getter
    def lowercase(self) -> Optional[_builtins.int]:
        """
        Minimum number of lowercase letters that the password must contain
        """
        return pulumi.get(self, "lowercase")

    @_builtins.property
    @pulumi.getter(name="specialChar")
    def special_char(self) -> Optional[_builtins.int]:
        """
        Minimum number of special char that the password must contain. Special chars list: `!"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~`
        """
        return pulumi.get(self, "special_char")

    @_builtins.property
    @pulumi.getter
    def uppercase(self) -> Optional[_builtins.int]:
        """
        Minimum number of uppercase letters that the password must contain
        """
        return pulumi.get(self, "uppercase")


@pulumi.output_type
class OauthSettingsOauthProvider(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiUrl":
            suggest = "api_url"
        elif key == "authUrl":
            suggest = "auth_url"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "tokenUrl":
            suggest = "token_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OauthSettingsOauthProvider. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OauthSettingsOauthProvider.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OauthSettingsOauthProvider.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_url: _builtins.str,
                 auth_url: _builtins.str,
                 client_id: _builtins.str,
                 client_secret: _builtins.str,
                 name: _builtins.str,
                 token_url: _builtins.str,
                 type: _builtins.str,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str api_url: OAuth user info endpoint for the IdP.
        :param _builtins.str auth_url: OAuth authorization endpoint for the IdP.
        :param _builtins.str client_id: OAuth client ID configured on the IdP.
        :param _builtins.str client_secret: OAuth client secret configured on the IdP.
        :param _builtins.str name: Name of the Artifactory OAuth provider.
        :param _builtins.str token_url: OAuth token endpoint for the IdP.
        :param _builtins.str type: Type of OAuth provider. (e.g., `github`, `google`, `cloudfoundry`, or `openId`)
        :param _builtins.bool enabled: Enable the Artifactory OAuth provider.  Default value is `true`.
        """
        pulumi.set(__self__, "api_url", api_url)
        pulumi.set(__self__, "auth_url", auth_url)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "token_url", token_url)
        pulumi.set(__self__, "type", type)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter(name="apiUrl")
    def api_url(self) -> _builtins.str:
        """
        OAuth user info endpoint for the IdP.
        """
        return pulumi.get(self, "api_url")

    @_builtins.property
    @pulumi.getter(name="authUrl")
    def auth_url(self) -> _builtins.str:
        """
        OAuth authorization endpoint for the IdP.
        """
        return pulumi.get(self, "auth_url")

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> _builtins.str:
        """
        OAuth client ID configured on the IdP.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> _builtins.str:
        """
        OAuth client secret configured on the IdP.
        """
        return pulumi.get(self, "client_secret")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the Artifactory OAuth provider.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="tokenUrl")
    def token_url(self) -> _builtins.str:
        """
        OAuth token endpoint for the IdP.
        """
        return pulumi.get(self, "token_url")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of OAuth provider. (e.g., `github`, `google`, `cloudfoundry`, or `openId`)
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enable the Artifactory OAuth provider.  Default value is `true`.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class PackageCleanupPolicySearchCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedPackages":
            suggest = "included_packages"
        elif key == "includedProjects":
            suggest = "included_projects"
        elif key == "packageTypes":
            suggest = "package_types"
        elif key == "createdBeforeInDays":
            suggest = "created_before_in_days"
        elif key == "createdBeforeInMonths":
            suggest = "created_before_in_months"
        elif key == "excludedPackages":
            suggest = "excluded_packages"
        elif key == "excludedProperties":
            suggest = "excluded_properties"
        elif key == "excludedRepos":
            suggest = "excluded_repos"
        elif key == "includeAllProjects":
            suggest = "include_all_projects"
        elif key == "includedProperties":
            suggest = "included_properties"
        elif key == "keepLastNVersions":
            suggest = "keep_last_n_versions"
        elif key == "lastDownloadedBeforeInDays":
            suggest = "last_downloaded_before_in_days"
        elif key == "lastDownloadedBeforeInMonths":
            suggest = "last_downloaded_before_in_months"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PackageCleanupPolicySearchCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PackageCleanupPolicySearchCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PackageCleanupPolicySearchCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 included_packages: Sequence[_builtins.str],
                 included_projects: Sequence[_builtins.str],
                 package_types: Sequence[_builtins.str],
                 repos: Sequence[_builtins.str],
                 created_before_in_days: Optional[_builtins.int] = None,
                 created_before_in_months: Optional[_builtins.int] = None,
                 excluded_packages: Optional[Sequence[_builtins.str]] = None,
                 excluded_properties: Optional[Mapping[str, Sequence[_builtins.str]]] = None,
                 excluded_repos: Optional[Sequence[_builtins.str]] = None,
                 include_all_projects: Optional[_builtins.bool] = None,
                 included_properties: Optional[Mapping[str, Sequence[_builtins.str]]] = None,
                 keep_last_n_versions: Optional[_builtins.int] = None,
                 last_downloaded_before_in_days: Optional[_builtins.int] = None,
                 last_downloaded_before_in_months: Optional[_builtins.int] = None):
        """
        :param Sequence[_builtins.str] included_packages: Specify a pattern for a package name or an explicit package name on which you want the cleanup policy to run. Only one pattern or explicit name can be entered. To include all packages, use `**`. Example: `included_packages = ["**"]`
        :param Sequence[_builtins.str] included_projects: Enter the project keys for the projects on which you want the policy to run. To include repositories that are not assigned to any project, enter the project key `default`. Can be empty when `include_all_projects` is set to `true`.
        :param Sequence[_builtins.str] repos: Specify one or more patterns for the repository name(s) on which you want the cleanup policy to run. You can also specify explicit repository names. Specifying at least one pattern or explicit name is mandatory. Only packages in repositories that match the pattern or explicit name will be deleted. For including all repos use `**`. Example: `repos = ["**"]`
        :param _builtins.int created_before_in_days: The cleanup policy will delete packages based on how long ago they were created. For example, if this parameter is 5 then packages created more than 5 days ago will be deleted as part of the policy.
               
               ~>JFrog recommends using the `created_before_in_days` condition to ensure that packages currently in use are not deleted.
        :param _builtins.int created_before_in_months: The cleanup policy will delete packages based on how long ago they were created. For example, if this parameter is 2 then packages created more than 2 months ago will be deleted as part of the policy.
               
               ~>JFrog recommends using the `created_before_in_months` condition to ensure that packages currently in use are not deleted.
        :param Sequence[_builtins.str] excluded_packages: Specify explicit package names that you want excluded from the policy. Only explicit names (and not patterns) are accepted.
        :param Mapping[str, Sequence[_builtins.str]] excluded_properties: A key-value pair applied to the lead artifact of a package. Packages with this property will be excluded from deletion.
        :param Sequence[_builtins.str] excluded_repos: Specify patterns for repository names or explicit repository names that you want excluded from the cleanup policy.
        :param _builtins.bool include_all_projects: Set this value to `true` if you want the policy to run on all Artifactory projects. The default value is `false`.
               
                ~>This parameter is relevant only on the global level, for Platform Admins.
        :param Mapping[str, Sequence[_builtins.str]] included_properties: A key-value pair applied to the lead artifact of a package. Packages with this property will be deleted.
        :param _builtins.int keep_last_n_versions: Set a value for the number of latest versions to keep. The cleanup policy will remove all versions prior to the number you select here. The latest version is always excluded.
               
               ~>Not all package types support this condition. For information on which package types support this condition, [learn more](https://jfrog.com/help/r/jfrog-platform-administration-documentation/retention-policies/package-types-coverage).
        :param _builtins.int last_downloaded_before_in_days: The cleanup policy will delete packages based on how long ago they were downloaded. For example, if this parameter is 5 then packages downloaded more than 5 days ago will be deleted as part of the policy.
               
               ~>JFrog recommends using the `last_downloaded_before_in_days` condition to ensure that packages currently in use are not deleted.
        :param _builtins.int last_downloaded_before_in_months: The cleanup policy will delete packages based on how long ago they were downloaded. For example, if this parameter is 5 then packages downloaded more than 5 months ago will be deleted as part of the policy.
               
               ~>JFrog recommends using the `last_downloaded_before_in_months` condition to ensure that packages currently in use are not deleted.
        """
        pulumi.set(__self__, "included_packages", included_packages)
        pulumi.set(__self__, "included_projects", included_projects)
        pulumi.set(__self__, "package_types", package_types)
        pulumi.set(__self__, "repos", repos)
        if created_before_in_days is not None:
            pulumi.set(__self__, "created_before_in_days", created_before_in_days)
        if created_before_in_months is not None:
            pulumi.set(__self__, "created_before_in_months", created_before_in_months)
        if excluded_packages is not None:
            pulumi.set(__self__, "excluded_packages", excluded_packages)
        if excluded_properties is not None:
            pulumi.set(__self__, "excluded_properties", excluded_properties)
        if excluded_repos is not None:
            pulumi.set(__self__, "excluded_repos", excluded_repos)
        if include_all_projects is not None:
            pulumi.set(__self__, "include_all_projects", include_all_projects)
        if included_properties is not None:
            pulumi.set(__self__, "included_properties", included_properties)
        if keep_last_n_versions is not None:
            pulumi.set(__self__, "keep_last_n_versions", keep_last_n_versions)
        if last_downloaded_before_in_days is not None:
            pulumi.set(__self__, "last_downloaded_before_in_days", last_downloaded_before_in_days)
        if last_downloaded_before_in_months is not None:
            pulumi.set(__self__, "last_downloaded_before_in_months", last_downloaded_before_in_months)

    @_builtins.property
    @pulumi.getter(name="includedPackages")
    def included_packages(self) -> Sequence[_builtins.str]:
        """
        Specify a pattern for a package name or an explicit package name on which you want the cleanup policy to run. Only one pattern or explicit name can be entered. To include all packages, use `**`. Example: `included_packages = ["**"]`
        """
        return pulumi.get(self, "included_packages")

    @_builtins.property
    @pulumi.getter(name="includedProjects")
    def included_projects(self) -> Sequence[_builtins.str]:
        """
        Enter the project keys for the projects on which you want the policy to run. To include repositories that are not assigned to any project, enter the project key `default`. Can be empty when `include_all_projects` is set to `true`.
        """
        return pulumi.get(self, "included_projects")

    @_builtins.property
    @pulumi.getter(name="packageTypes")
    def package_types(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "package_types")

    @_builtins.property
    @pulumi.getter
    def repos(self) -> Sequence[_builtins.str]:
        """
        Specify one or more patterns for the repository name(s) on which you want the cleanup policy to run. You can also specify explicit repository names. Specifying at least one pattern or explicit name is mandatory. Only packages in repositories that match the pattern or explicit name will be deleted. For including all repos use `**`. Example: `repos = ["**"]`
        """
        return pulumi.get(self, "repos")

    @_builtins.property
    @pulumi.getter(name="createdBeforeInDays")
    def created_before_in_days(self) -> Optional[_builtins.int]:
        """
        The cleanup policy will delete packages based on how long ago they were created. For example, if this parameter is 5 then packages created more than 5 days ago will be deleted as part of the policy.

        ~>JFrog recommends using the `created_before_in_days` condition to ensure that packages currently in use are not deleted.
        """
        return pulumi.get(self, "created_before_in_days")

    @_builtins.property
    @pulumi.getter(name="createdBeforeInMonths")
    @_utilities.deprecated("""Use `created_before_in_days` instead of `created_before_in_months`. Renamed to `created_before_in_days` starting in version 7.111.2.""")
    def created_before_in_months(self) -> Optional[_builtins.int]:
        """
        The cleanup policy will delete packages based on how long ago they were created. For example, if this parameter is 2 then packages created more than 2 months ago will be deleted as part of the policy.

        ~>JFrog recommends using the `created_before_in_months` condition to ensure that packages currently in use are not deleted.
        """
        return pulumi.get(self, "created_before_in_months")

    @_builtins.property
    @pulumi.getter(name="excludedPackages")
    def excluded_packages(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specify explicit package names that you want excluded from the policy. Only explicit names (and not patterns) are accepted.
        """
        return pulumi.get(self, "excluded_packages")

    @_builtins.property
    @pulumi.getter(name="excludedProperties")
    def excluded_properties(self) -> Optional[Mapping[str, Sequence[_builtins.str]]]:
        """
        A key-value pair applied to the lead artifact of a package. Packages with this property will be excluded from deletion.
        """
        return pulumi.get(self, "excluded_properties")

    @_builtins.property
    @pulumi.getter(name="excludedRepos")
    def excluded_repos(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specify patterns for repository names or explicit repository names that you want excluded from the cleanup policy.
        """
        return pulumi.get(self, "excluded_repos")

    @_builtins.property
    @pulumi.getter(name="includeAllProjects")
    def include_all_projects(self) -> Optional[_builtins.bool]:
        """
        Set this value to `true` if you want the policy to run on all Artifactory projects. The default value is `false`.

         ~>This parameter is relevant only on the global level, for Platform Admins.
        """
        return pulumi.get(self, "include_all_projects")

    @_builtins.property
    @pulumi.getter(name="includedProperties")
    def included_properties(self) -> Optional[Mapping[str, Sequence[_builtins.str]]]:
        """
        A key-value pair applied to the lead artifact of a package. Packages with this property will be deleted.
        """
        return pulumi.get(self, "included_properties")

    @_builtins.property
    @pulumi.getter(name="keepLastNVersions")
    def keep_last_n_versions(self) -> Optional[_builtins.int]:
        """
        Set a value for the number of latest versions to keep. The cleanup policy will remove all versions prior to the number you select here. The latest version is always excluded.

        ~>Not all package types support this condition. For information on which package types support this condition, [learn more](https://jfrog.com/help/r/jfrog-platform-administration-documentation/retention-policies/package-types-coverage).
        """
        return pulumi.get(self, "keep_last_n_versions")

    @_builtins.property
    @pulumi.getter(name="lastDownloadedBeforeInDays")
    def last_downloaded_before_in_days(self) -> Optional[_builtins.int]:
        """
        The cleanup policy will delete packages based on how long ago they were downloaded. For example, if this parameter is 5 then packages downloaded more than 5 days ago will be deleted as part of the policy.

        ~>JFrog recommends using the `last_downloaded_before_in_days` condition to ensure that packages currently in use are not deleted.
        """
        return pulumi.get(self, "last_downloaded_before_in_days")

    @_builtins.property
    @pulumi.getter(name="lastDownloadedBeforeInMonths")
    @_utilities.deprecated("""Use `last_downloaded_before_in_days` instead of `last_downloaded_before_in_months`. Renamed to `last_downloaded_before_in_days` starting in version 7.111.2.""")
    def last_downloaded_before_in_months(self) -> Optional[_builtins.int]:
        """
        The cleanup policy will delete packages based on how long ago they were downloaded. For example, if this parameter is 5 then packages downloaded more than 5 months ago will be deleted as part of the policy.

        ~>JFrog recommends using the `last_downloaded_before_in_months` condition to ensure that packages currently in use are not deleted.
        """
        return pulumi.get(self, "last_downloaded_before_in_months")


@pulumi.output_type
class PermissionTargetBuild(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludesPatterns":
            suggest = "excludes_patterns"
        elif key == "includesPatterns":
            suggest = "includes_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PermissionTargetBuild. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PermissionTargetBuild.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PermissionTargetBuild.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 repositories: Sequence[_builtins.str],
                 actions: Optional['outputs.PermissionTargetBuildActions'] = None,
                 excludes_patterns: Optional[Sequence[_builtins.str]] = None,
                 includes_patterns: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] repositories: This can only be 1 value: "artifactory-build-info", and currently, validation of sets/lists is not allowed. Artifactory will reject the request if you change this
        :param Sequence[_builtins.str] excludes_patterns: The default value will be [] if nothing is supplied
        :param Sequence[_builtins.str] includes_patterns: The default value will be [""] if nothing is supplied
        """
        pulumi.set(__self__, "repositories", repositories)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if excludes_patterns is not None:
            pulumi.set(__self__, "excludes_patterns", excludes_patterns)
        if includes_patterns is not None:
            pulumi.set(__self__, "includes_patterns", includes_patterns)

    @_builtins.property
    @pulumi.getter
    def repositories(self) -> Sequence[_builtins.str]:
        """
        This can only be 1 value: "artifactory-build-info", and currently, validation of sets/lists is not allowed. Artifactory will reject the request if you change this
        """
        return pulumi.get(self, "repositories")

    @_builtins.property
    @pulumi.getter
    def actions(self) -> Optional['outputs.PermissionTargetBuildActions']:
        return pulumi.get(self, "actions")

    @_builtins.property
    @pulumi.getter(name="excludesPatterns")
    def excludes_patterns(self) -> Optional[Sequence[_builtins.str]]:
        """
        The default value will be [] if nothing is supplied
        """
        return pulumi.get(self, "excludes_patterns")

    @_builtins.property
    @pulumi.getter(name="includesPatterns")
    def includes_patterns(self) -> Optional[Sequence[_builtins.str]]:
        """
        The default value will be [""] if nothing is supplied
        """
        return pulumi.get(self, "includes_patterns")


@pulumi.output_type
class PermissionTargetBuildActions(dict):
    def __init__(__self__, *,
                 groups: Optional[Sequence['outputs.PermissionTargetBuildActionsGroup']] = None,
                 users: Optional[Sequence['outputs.PermissionTargetBuildActionsUser']] = None):
        """
        :param Sequence['PermissionTargetBuildActionsGroupArgs'] groups: Groups this permission applies for.
        :param Sequence['PermissionTargetBuildActionsUserArgs'] users: Users this permission target applies for.
        """
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @_builtins.property
    @pulumi.getter
    def groups(self) -> Optional[Sequence['outputs.PermissionTargetBuildActionsGroup']]:
        """
        Groups this permission applies for.
        """
        return pulumi.get(self, "groups")

    @_builtins.property
    @pulumi.getter
    def users(self) -> Optional[Sequence['outputs.PermissionTargetBuildActionsUser']]:
        """
        Users this permission target applies for.
        """
        return pulumi.get(self, "users")


@pulumi.output_type
class PermissionTargetBuildActionsGroup(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 permissions: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Name of permission.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of permission.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def permissions(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "permissions")


@pulumi.output_type
class PermissionTargetBuildActionsUser(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 permissions: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Name of permission.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of permission.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def permissions(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "permissions")


@pulumi.output_type
class PermissionTargetReleaseBundle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludesPatterns":
            suggest = "excludes_patterns"
        elif key == "includesPatterns":
            suggest = "includes_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PermissionTargetReleaseBundle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PermissionTargetReleaseBundle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PermissionTargetReleaseBundle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 repositories: Sequence[_builtins.str],
                 actions: Optional['outputs.PermissionTargetReleaseBundleActions'] = None,
                 excludes_patterns: Optional[Sequence[_builtins.str]] = None,
                 includes_patterns: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] repositories: This can only be 1 value: "artifactory-build-info", and currently, validation of sets/lists is not allowed. Artifactory will reject the request if you change this
        :param Sequence[_builtins.str] excludes_patterns: The default value will be [] if nothing is supplied
        :param Sequence[_builtins.str] includes_patterns: The default value will be [""] if nothing is supplied
        """
        pulumi.set(__self__, "repositories", repositories)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if excludes_patterns is not None:
            pulumi.set(__self__, "excludes_patterns", excludes_patterns)
        if includes_patterns is not None:
            pulumi.set(__self__, "includes_patterns", includes_patterns)

    @_builtins.property
    @pulumi.getter
    def repositories(self) -> Sequence[_builtins.str]:
        """
        This can only be 1 value: "artifactory-build-info", and currently, validation of sets/lists is not allowed. Artifactory will reject the request if you change this
        """
        return pulumi.get(self, "repositories")

    @_builtins.property
    @pulumi.getter
    def actions(self) -> Optional['outputs.PermissionTargetReleaseBundleActions']:
        return pulumi.get(self, "actions")

    @_builtins.property
    @pulumi.getter(name="excludesPatterns")
    def excludes_patterns(self) -> Optional[Sequence[_builtins.str]]:
        """
        The default value will be [] if nothing is supplied
        """
        return pulumi.get(self, "excludes_patterns")

    @_builtins.property
    @pulumi.getter(name="includesPatterns")
    def includes_patterns(self) -> Optional[Sequence[_builtins.str]]:
        """
        The default value will be [""] if nothing is supplied
        """
        return pulumi.get(self, "includes_patterns")


@pulumi.output_type
class PermissionTargetReleaseBundleActions(dict):
    def __init__(__self__, *,
                 groups: Optional[Sequence['outputs.PermissionTargetReleaseBundleActionsGroup']] = None,
                 users: Optional[Sequence['outputs.PermissionTargetReleaseBundleActionsUser']] = None):
        """
        :param Sequence['PermissionTargetReleaseBundleActionsGroupArgs'] groups: Groups this permission applies for.
        :param Sequence['PermissionTargetReleaseBundleActionsUserArgs'] users: Users this permission target applies for.
        """
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @_builtins.property
    @pulumi.getter
    def groups(self) -> Optional[Sequence['outputs.PermissionTargetReleaseBundleActionsGroup']]:
        """
        Groups this permission applies for.
        """
        return pulumi.get(self, "groups")

    @_builtins.property
    @pulumi.getter
    def users(self) -> Optional[Sequence['outputs.PermissionTargetReleaseBundleActionsUser']]:
        """
        Users this permission target applies for.
        """
        return pulumi.get(self, "users")


@pulumi.output_type
class PermissionTargetReleaseBundleActionsGroup(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 permissions: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Name of permission.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of permission.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def permissions(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "permissions")


@pulumi.output_type
class PermissionTargetReleaseBundleActionsUser(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 permissions: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Name of permission.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of permission.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def permissions(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "permissions")


@pulumi.output_type
class PermissionTargetRepo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludesPatterns":
            suggest = "excludes_patterns"
        elif key == "includesPatterns":
            suggest = "includes_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PermissionTargetRepo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PermissionTargetRepo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PermissionTargetRepo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 repositories: Sequence[_builtins.str],
                 actions: Optional['outputs.PermissionTargetRepoActions'] = None,
                 excludes_patterns: Optional[Sequence[_builtins.str]] = None,
                 includes_patterns: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] repositories: List of repositories this permission target is applicable for. You can specify the name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        :param Sequence[_builtins.str] excludes_patterns: Pattern of artifacts to exclude.
        :param Sequence[_builtins.str] includes_patterns: Pattern of artifacts to include.
        """
        pulumi.set(__self__, "repositories", repositories)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if excludes_patterns is not None:
            pulumi.set(__self__, "excludes_patterns", excludes_patterns)
        if includes_patterns is not None:
            pulumi.set(__self__, "includes_patterns", includes_patterns)

    @_builtins.property
    @pulumi.getter
    def repositories(self) -> Sequence[_builtins.str]:
        """
        List of repositories this permission target is applicable for. You can specify the name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        """
        return pulumi.get(self, "repositories")

    @_builtins.property
    @pulumi.getter
    def actions(self) -> Optional['outputs.PermissionTargetRepoActions']:
        return pulumi.get(self, "actions")

    @_builtins.property
    @pulumi.getter(name="excludesPatterns")
    def excludes_patterns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Pattern of artifacts to exclude.
        """
        return pulumi.get(self, "excludes_patterns")

    @_builtins.property
    @pulumi.getter(name="includesPatterns")
    def includes_patterns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Pattern of artifacts to include.
        """
        return pulumi.get(self, "includes_patterns")


@pulumi.output_type
class PermissionTargetRepoActions(dict):
    def __init__(__self__, *,
                 groups: Optional[Sequence['outputs.PermissionTargetRepoActionsGroup']] = None,
                 users: Optional[Sequence['outputs.PermissionTargetRepoActionsUser']] = None):
        """
        :param Sequence['PermissionTargetRepoActionsGroupArgs'] groups: Groups this permission applies for.
        :param Sequence['PermissionTargetRepoActionsUserArgs'] users: Users this permission target applies for.
        """
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @_builtins.property
    @pulumi.getter
    def groups(self) -> Optional[Sequence['outputs.PermissionTargetRepoActionsGroup']]:
        """
        Groups this permission applies for.
        """
        return pulumi.get(self, "groups")

    @_builtins.property
    @pulumi.getter
    def users(self) -> Optional[Sequence['outputs.PermissionTargetRepoActionsUser']]:
        """
        Users this permission target applies for.
        """
        return pulumi.get(self, "users")


@pulumi.output_type
class PermissionTargetRepoActionsGroup(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 permissions: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Name of permission.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of permission.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def permissions(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "permissions")


@pulumi.output_type
class PermissionTargetRepoActionsUser(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 permissions: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Name of permission.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of permission.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def permissions(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "permissions")


@pulumi.output_type
class PropertySetProperty(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "closedPredefinedValues":
            suggest = "closed_predefined_values"
        elif key == "multipleChoice":
            suggest = "multiple_choice"
        elif key == "predefinedValues":
            suggest = "predefined_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PropertySetProperty. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PropertySetProperty.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PropertySetProperty.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 closed_predefined_values: Optional[_builtins.bool] = None,
                 multiple_choice: Optional[_builtins.bool] = None,
                 predefined_values: Optional[Sequence['outputs.PropertySetPropertyPredefinedValue']] = None):
        """
        :param _builtins.str name: The name pf the property.
        :param _builtins.bool closed_predefined_values: Disables `multiple_choice` if set to `false` at the same time with multiple_choice set to `true`. Default value is `false`
        :param _builtins.bool multiple_choice: Defines if user can select multiple values. `closed_predefined_values` should be set to `true`. Default value is `false`.
        :param Sequence['PropertySetPropertyPredefinedValueArgs'] predefined_values: Properties in the property set. Predefined values is mandatory when closed_predefined_values or multiple_choice is set to 'true'
        """
        pulumi.set(__self__, "name", name)
        if closed_predefined_values is not None:
            pulumi.set(__self__, "closed_predefined_values", closed_predefined_values)
        if multiple_choice is not None:
            pulumi.set(__self__, "multiple_choice", multiple_choice)
        if predefined_values is not None:
            pulumi.set(__self__, "predefined_values", predefined_values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name pf the property.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="closedPredefinedValues")
    def closed_predefined_values(self) -> Optional[_builtins.bool]:
        """
        Disables `multiple_choice` if set to `false` at the same time with multiple_choice set to `true`. Default value is `false`
        """
        return pulumi.get(self, "closed_predefined_values")

    @_builtins.property
    @pulumi.getter(name="multipleChoice")
    def multiple_choice(self) -> Optional[_builtins.bool]:
        """
        Defines if user can select multiple values. `closed_predefined_values` should be set to `true`. Default value is `false`.
        """
        return pulumi.get(self, "multiple_choice")

    @_builtins.property
    @pulumi.getter(name="predefinedValues")
    def predefined_values(self) -> Optional[Sequence['outputs.PropertySetPropertyPredefinedValue']]:
        """
        Properties in the property set. Predefined values is mandatory when closed_predefined_values or multiple_choice is set to 'true'
        """
        return pulumi.get(self, "predefined_values")


@pulumi.output_type
class PropertySetPropertyPredefinedValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultValue":
            suggest = "default_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PropertySetPropertyPredefinedValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PropertySetPropertyPredefinedValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PropertySetPropertyPredefinedValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_value: _builtins.bool,
                 name: _builtins.str):
        """
        :param _builtins.bool default_value: Whether the value is selected by default in the UI.
        :param _builtins.str name: Property set name.
        """
        pulumi.set(__self__, "default_value", default_value)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> _builtins.bool:
        """
        Whether the value is selected by default in the UI.
        """
        return pulumi.get(self, "default_value")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Property set name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class PushReplicationReplication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "checkBinaryExistenceInFilestore":
            suggest = "check_binary_existence_in_filestore"
        elif key == "pathPrefix":
            suggest = "path_prefix"
        elif key == "socketTimeoutMillis":
            suggest = "socket_timeout_millis"
        elif key == "syncDeletes":
            suggest = "sync_deletes"
        elif key == "syncProperties":
            suggest = "sync_properties"
        elif key == "syncStatistics":
            suggest = "sync_statistics"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PushReplicationReplication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PushReplicationReplication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PushReplicationReplication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 password: _builtins.str,
                 url: _builtins.str,
                 username: _builtins.str,
                 check_binary_existence_in_filestore: Optional[_builtins.bool] = None,
                 enabled: Optional[_builtins.bool] = None,
                 path_prefix: Optional[_builtins.str] = None,
                 proxy: Optional[_builtins.str] = None,
                 socket_timeout_millis: Optional[_builtins.int] = None,
                 sync_deletes: Optional[_builtins.bool] = None,
                 sync_properties: Optional[_builtins.bool] = None,
                 sync_statistics: Optional[_builtins.bool] = None):
        """
        :param _builtins.str password: Required for local repository, but not needed for remote repository.
        :param _builtins.str url: The URL of the target local repository on a remote Artifactory server. Required for local repository, but not needed for remote repository.
        :param _builtins.str username: Required for local repository, but not needed for remote repository.
        :param _builtins.bool check_binary_existence_in_filestore: When true, enables distributed checksum storage. For more information, see
               [Optimizing Repository Replication with Checksum-Based Storage](https://www.jfrog.com/confluence/display/JFROG/Repository+Replication#RepositoryReplication-OptimizingRepositoryReplicationUsingStorageLevelSynchronizationOptions).
        :param _builtins.bool enabled: When set, this replication will be enabled when saved.
        :param _builtins.str path_prefix: Only artifacts that located in path that matches the subpath within the remote repository will be replicated.
        :param _builtins.str proxy: Proxy key from Artifactory Proxies settings. The proxy configuration will be used when communicating with the remote instance.
        :param _builtins.int socket_timeout_millis: The network timeout in milliseconds to use for remote operations.
        :param _builtins.bool sync_deletes: When set, items that were deleted locally should also be deleted remotely (also applies to properties metadata).
               Note that enabling this option, will delete artifacts on the target that do not exist in the source repository.
        :param _builtins.bool sync_properties: When set, the task also synchronizes the properties of replicated artifacts.
        :param _builtins.bool sync_statistics: When set, artifact download statistics will also be replicated. Set to avoid inadvertent cleanup at the target instance when setting up replication for disaster recovery.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "url", url)
        pulumi.set(__self__, "username", username)
        if check_binary_existence_in_filestore is not None:
            pulumi.set(__self__, "check_binary_existence_in_filestore", check_binary_existence_in_filestore)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if path_prefix is not None:
            pulumi.set(__self__, "path_prefix", path_prefix)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if socket_timeout_millis is not None:
            pulumi.set(__self__, "socket_timeout_millis", socket_timeout_millis)
        if sync_deletes is not None:
            pulumi.set(__self__, "sync_deletes", sync_deletes)
        if sync_properties is not None:
            pulumi.set(__self__, "sync_properties", sync_properties)
        if sync_statistics is not None:
            pulumi.set(__self__, "sync_statistics", sync_statistics)

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        """
        Required for local repository, but not needed for remote repository.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The URL of the target local repository on a remote Artifactory server. Required for local repository, but not needed for remote repository.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        Required for local repository, but not needed for remote repository.
        """
        return pulumi.get(self, "username")

    @_builtins.property
    @pulumi.getter(name="checkBinaryExistenceInFilestore")
    def check_binary_existence_in_filestore(self) -> Optional[_builtins.bool]:
        """
        When true, enables distributed checksum storage. For more information, see
        [Optimizing Repository Replication with Checksum-Based Storage](https://www.jfrog.com/confluence/display/JFROG/Repository+Replication#RepositoryReplication-OptimizingRepositoryReplicationUsingStorageLevelSynchronizationOptions).
        """
        return pulumi.get(self, "check_binary_existence_in_filestore")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        When set, this replication will be enabled when saved.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="pathPrefix")
    def path_prefix(self) -> Optional[_builtins.str]:
        """
        Only artifacts that located in path that matches the subpath within the remote repository will be replicated.
        """
        return pulumi.get(self, "path_prefix")

    @_builtins.property
    @pulumi.getter
    def proxy(self) -> Optional[_builtins.str]:
        """
        Proxy key from Artifactory Proxies settings. The proxy configuration will be used when communicating with the remote instance.
        """
        return pulumi.get(self, "proxy")

    @_builtins.property
    @pulumi.getter(name="socketTimeoutMillis")
    def socket_timeout_millis(self) -> Optional[_builtins.int]:
        """
        The network timeout in milliseconds to use for remote operations.
        """
        return pulumi.get(self, "socket_timeout_millis")

    @_builtins.property
    @pulumi.getter(name="syncDeletes")
    def sync_deletes(self) -> Optional[_builtins.bool]:
        """
        When set, items that were deleted locally should also be deleted remotely (also applies to properties metadata).
        Note that enabling this option, will delete artifacts on the target that do not exist in the source repository.
        """
        return pulumi.get(self, "sync_deletes")

    @_builtins.property
    @pulumi.getter(name="syncProperties")
    def sync_properties(self) -> Optional[_builtins.bool]:
        """
        When set, the task also synchronizes the properties of replicated artifacts.
        """
        return pulumi.get(self, "sync_properties")

    @_builtins.property
    @pulumi.getter(name="syncStatistics")
    def sync_statistics(self) -> Optional[_builtins.bool]:
        """
        When set, artifact download statistics will also be replicated. Set to avoid inadvertent cleanup at the target instance when setting up replication for disaster recovery.
        """
        return pulumi.get(self, "sync_statistics")


@pulumi.output_type
class ReleaseBundleCustomWebhookCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyReleaseBundle":
            suggest = "any_release_bundle"
        elif key == "registeredReleaseBundleNames":
            suggest = "registered_release_bundle_names"
        elif key == "excludePatterns":
            suggest = "exclude_patterns"
        elif key == "includePatterns":
            suggest = "include_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReleaseBundleCustomWebhookCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReleaseBundleCustomWebhookCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReleaseBundleCustomWebhookCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_release_bundle: _builtins.bool,
                 registered_release_bundle_names: Sequence[_builtins.str],
                 exclude_patterns: Optional[Sequence[_builtins.str]] = None,
                 include_patterns: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.bool any_release_bundle: Trigger on any release bundle.
        :param Sequence[_builtins.str] registered_release_bundle_names: Trigger on this list of release bundle names.
        :param Sequence[_builtins.str] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: "org/apache/**".
        :param Sequence[_builtins.str] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: "org/apache/**".
        """
        pulumi.set(__self__, "any_release_bundle", any_release_bundle)
        pulumi.set(__self__, "registered_release_bundle_names", registered_release_bundle_names)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @_builtins.property
    @pulumi.getter(name="anyReleaseBundle")
    def any_release_bundle(self) -> _builtins.bool:
        """
        Trigger on any release bundle.
        """
        return pulumi.get(self, "any_release_bundle")

    @_builtins.property
    @pulumi.getter(name="registeredReleaseBundleNames")
    def registered_release_bundle_names(self) -> Sequence[_builtins.str]:
        """
        Trigger on this list of release bundle names.
        """
        return pulumi.get(self, "registered_release_bundle_names")

    @_builtins.property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: "org/apache/**".
        """
        return pulumi.get(self, "exclude_patterns")

    @_builtins.property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: "org/apache/**".
        """
        return pulumi.get(self, "include_patterns")


@pulumi.output_type
class ReleaseBundleCustomWebhookHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpHeaders":
            suggest = "http_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReleaseBundleCustomWebhookHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReleaseBundleCustomWebhookHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReleaseBundleCustomWebhookHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: _builtins.str,
                 http_headers: Optional[Mapping[str, _builtins.str]] = None,
                 method: Optional[_builtins.str] = None,
                 payload: Optional[_builtins.str] = None,
                 proxy: Optional[_builtins.str] = None,
                 secrets: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param Mapping[str, _builtins.str] http_headers: HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        :param _builtins.str method: Specifies the HTTP method for the URL that the Webhook invokes. Allowed values are: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`.
        :param _builtins.str payload: This attribute is used to build the request body. Used in custom webhooks
        :param _builtins.str proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param Mapping[str, _builtins.str] secrets: Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
        pulumi.set(__self__, "url", url)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        """
        return pulumi.get(self, "http_headers")

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[_builtins.str]:
        """
        Specifies the HTTP method for the URL that the Webhook invokes. Allowed values are: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`.
        """
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter
    def payload(self) -> Optional[_builtins.str]:
        """
        This attribute is used to build the request body. Used in custom webhooks
        """
        return pulumi.get(self, "payload")

    @_builtins.property
    @pulumi.getter
    def proxy(self) -> Optional[_builtins.str]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @_builtins.property
    @pulumi.getter
    def secrets(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
        return pulumi.get(self, "secrets")


@pulumi.output_type
class ReleaseBundleV2CleanupPolicySearchCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludePromotedEnvironments":
            suggest = "exclude_promoted_environments"
        elif key == "createdBeforeInMonths":
            suggest = "created_before_in_months"
        elif key == "includeAllProjects":
            suggest = "include_all_projects"
        elif key == "includedProjects":
            suggest = "included_projects"
        elif key == "releaseBundles":
            suggest = "release_bundles"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReleaseBundleV2CleanupPolicySearchCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReleaseBundleV2CleanupPolicySearchCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReleaseBundleV2CleanupPolicySearchCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exclude_promoted_environments: Sequence[_builtins.str],
                 created_before_in_months: Optional[_builtins.int] = None,
                 include_all_projects: Optional[_builtins.bool] = None,
                 included_projects: Optional[Sequence[_builtins.str]] = None,
                 release_bundles: Optional[Sequence['outputs.ReleaseBundleV2CleanupPolicySearchCriteriaReleaseBundle']] = None):
        """
        :param Sequence[_builtins.str] exclude_promoted_environments: A list of environments to exclude from the cleanup process. To exclude all, set to `**`. Example: `exclude_promoted_environments = ["**"]`
        :param _builtins.int created_before_in_months: The cleanup policy will cleanup release bundles based on how long ago they were created. For example, if this parameter is 2 then release bundles created more than 2 months ago will be cleaned up as part of the policy.
        :param _builtins.bool include_all_projects: Set this value to `true` if you want the policy to run on all Artifactory projects. The default value is `false`.
        :param Sequence[_builtins.str] included_projects: List of projects on which you want this policy to run. To include repositories that are not assigned to any project, enter the project key `default`.
               
               ~>This setting is relevant only on the global level, for Platform Admins.
        :param Sequence['ReleaseBundleV2CleanupPolicySearchCriteriaReleaseBundleArgs'] release_bundles: Specify the release bundles to include in the cleanup policy. The policy will only clean up the release bundles that match the specified criteria.
        """
        pulumi.set(__self__, "exclude_promoted_environments", exclude_promoted_environments)
        if created_before_in_months is not None:
            pulumi.set(__self__, "created_before_in_months", created_before_in_months)
        if include_all_projects is not None:
            pulumi.set(__self__, "include_all_projects", include_all_projects)
        if included_projects is not None:
            pulumi.set(__self__, "included_projects", included_projects)
        if release_bundles is not None:
            pulumi.set(__self__, "release_bundles", release_bundles)

    @_builtins.property
    @pulumi.getter(name="excludePromotedEnvironments")
    def exclude_promoted_environments(self) -> Sequence[_builtins.str]:
        """
        A list of environments to exclude from the cleanup process. To exclude all, set to `**`. Example: `exclude_promoted_environments = ["**"]`
        """
        return pulumi.get(self, "exclude_promoted_environments")

    @_builtins.property
    @pulumi.getter(name="createdBeforeInMonths")
    def created_before_in_months(self) -> Optional[_builtins.int]:
        """
        The cleanup policy will cleanup release bundles based on how long ago they were created. For example, if this parameter is 2 then release bundles created more than 2 months ago will be cleaned up as part of the policy.
        """
        return pulumi.get(self, "created_before_in_months")

    @_builtins.property
    @pulumi.getter(name="includeAllProjects")
    def include_all_projects(self) -> Optional[_builtins.bool]:
        """
        Set this value to `true` if you want the policy to run on all Artifactory projects. The default value is `false`.
        """
        return pulumi.get(self, "include_all_projects")

    @_builtins.property
    @pulumi.getter(name="includedProjects")
    def included_projects(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of projects on which you want this policy to run. To include repositories that are not assigned to any project, enter the project key `default`.

        ~>This setting is relevant only on the global level, for Platform Admins.
        """
        return pulumi.get(self, "included_projects")

    @_builtins.property
    @pulumi.getter(name="releaseBundles")
    def release_bundles(self) -> Optional[Sequence['outputs.ReleaseBundleV2CleanupPolicySearchCriteriaReleaseBundle']]:
        """
        Specify the release bundles to include in the cleanup policy. The policy will only clean up the release bundles that match the specified criteria.
        """
        return pulumi.get(self, "release_bundles")


@pulumi.output_type
class ReleaseBundleV2CleanupPolicySearchCriteriaReleaseBundle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "projectKey":
            suggest = "project_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReleaseBundleV2CleanupPolicySearchCriteriaReleaseBundle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReleaseBundleV2CleanupPolicySearchCriteriaReleaseBundle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReleaseBundleV2CleanupPolicySearchCriteriaReleaseBundle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 project_key: _builtins.str):
        """
        :param _builtins.str name: The name of the release bundle. Set `**` to include all bundles. Example: `name = "**"`
        :param _builtins.str project_key: The project identifier associated with the release bundle. This key is obtained from the Project Settings screen. Leave the field blank to apply at a global level.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project_key", project_key)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the release bundle. Set `**` to include all bundles. Example: `name = "**"`
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="projectKey")
    def project_key(self) -> _builtins.str:
        """
        The project identifier associated with the release bundle. This key is obtained from the Project Settings screen. Leave the field blank to apply at a global level.
        """
        return pulumi.get(self, "project_key")


@pulumi.output_type
class ReleaseBundleV2CustomWebhookCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyReleaseBundle":
            suggest = "any_release_bundle"
        elif key == "selectedReleaseBundles":
            suggest = "selected_release_bundles"
        elif key == "excludePatterns":
            suggest = "exclude_patterns"
        elif key == "includePatterns":
            suggest = "include_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReleaseBundleV2CustomWebhookCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReleaseBundleV2CustomWebhookCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReleaseBundleV2CustomWebhookCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_release_bundle: _builtins.bool,
                 selected_release_bundles: Sequence[_builtins.str],
                 exclude_patterns: Optional[Sequence[_builtins.str]] = None,
                 include_patterns: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.bool any_release_bundle: Trigger on any release bundle.
        :param Sequence[_builtins.str] selected_release_bundles: Trigger on this list of release bundle names.
        :param Sequence[_builtins.str] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: "org/apache/**".
        :param Sequence[_builtins.str] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: "org/apache/**".
        """
        pulumi.set(__self__, "any_release_bundle", any_release_bundle)
        pulumi.set(__self__, "selected_release_bundles", selected_release_bundles)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @_builtins.property
    @pulumi.getter(name="anyReleaseBundle")
    def any_release_bundle(self) -> _builtins.bool:
        """
        Trigger on any release bundle.
        """
        return pulumi.get(self, "any_release_bundle")

    @_builtins.property
    @pulumi.getter(name="selectedReleaseBundles")
    def selected_release_bundles(self) -> Sequence[_builtins.str]:
        """
        Trigger on this list of release bundle names.
        """
        return pulumi.get(self, "selected_release_bundles")

    @_builtins.property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: "org/apache/**".
        """
        return pulumi.get(self, "exclude_patterns")

    @_builtins.property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: "org/apache/**".
        """
        return pulumi.get(self, "include_patterns")


@pulumi.output_type
class ReleaseBundleV2CustomWebhookHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpHeaders":
            suggest = "http_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReleaseBundleV2CustomWebhookHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReleaseBundleV2CustomWebhookHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReleaseBundleV2CustomWebhookHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: _builtins.str,
                 http_headers: Optional[Mapping[str, _builtins.str]] = None,
                 method: Optional[_builtins.str] = None,
                 payload: Optional[_builtins.str] = None,
                 proxy: Optional[_builtins.str] = None,
                 secrets: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param Mapping[str, _builtins.str] http_headers: HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        :param _builtins.str method: Specifies the HTTP method for the URL that the Webhook invokes. Allowed values are: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`.
        :param _builtins.str payload: This attribute is used to build the request body. Used in custom webhooks
        :param _builtins.str proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param Mapping[str, _builtins.str] secrets: Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
        pulumi.set(__self__, "url", url)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        """
        return pulumi.get(self, "http_headers")

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[_builtins.str]:
        """
        Specifies the HTTP method for the URL that the Webhook invokes. Allowed values are: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`.
        """
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter
    def payload(self) -> Optional[_builtins.str]:
        """
        This attribute is used to build the request body. Used in custom webhooks
        """
        return pulumi.get(self, "payload")

    @_builtins.property
    @pulumi.getter
    def proxy(self) -> Optional[_builtins.str]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @_builtins.property
    @pulumi.getter
    def secrets(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
        return pulumi.get(self, "secrets")


@pulumi.output_type
class ReleaseBundleV2PromotionCustomWebhookCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "selectedEnvironments":
            suggest = "selected_environments"
        elif key == "excludePatterns":
            suggest = "exclude_patterns"
        elif key == "includePatterns":
            suggest = "include_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReleaseBundleV2PromotionCustomWebhookCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReleaseBundleV2PromotionCustomWebhookCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReleaseBundleV2PromotionCustomWebhookCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 selected_environments: Sequence[_builtins.str],
                 exclude_patterns: Optional[Sequence[_builtins.str]] = None,
                 include_patterns: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] selected_environments: Trigger on this list of environment names.
        """
        pulumi.set(__self__, "selected_environments", selected_environments)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @_builtins.property
    @pulumi.getter(name="selectedEnvironments")
    def selected_environments(self) -> Sequence[_builtins.str]:
        """
        Trigger on this list of environment names.
        """
        return pulumi.get(self, "selected_environments")

    @_builtins.property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "exclude_patterns")

    @_builtins.property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "include_patterns")


@pulumi.output_type
class ReleaseBundleV2PromotionCustomWebhookHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpHeaders":
            suggest = "http_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReleaseBundleV2PromotionCustomWebhookHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReleaseBundleV2PromotionCustomWebhookHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReleaseBundleV2PromotionCustomWebhookHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: _builtins.str,
                 http_headers: Optional[Mapping[str, _builtins.str]] = None,
                 method: Optional[_builtins.str] = None,
                 payload: Optional[_builtins.str] = None,
                 proxy: Optional[_builtins.str] = None,
                 secrets: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param Mapping[str, _builtins.str] http_headers: HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        :param _builtins.str method: Specifies the HTTP method for the URL that the Webhook invokes. Allowed values are: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`.
        :param _builtins.str payload: This attribute is used to build the request body. Used in custom webhooks
        :param _builtins.str proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param Mapping[str, _builtins.str] secrets: Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
        pulumi.set(__self__, "url", url)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        """
        return pulumi.get(self, "http_headers")

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[_builtins.str]:
        """
        Specifies the HTTP method for the URL that the Webhook invokes. Allowed values are: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`.
        """
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter
    def payload(self) -> Optional[_builtins.str]:
        """
        This attribute is used to build the request body. Used in custom webhooks
        """
        return pulumi.get(self, "payload")

    @_builtins.property
    @pulumi.getter
    def proxy(self) -> Optional[_builtins.str]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @_builtins.property
    @pulumi.getter
    def secrets(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
        return pulumi.get(self, "secrets")


@pulumi.output_type
class ReleaseBundleV2PromotionWebhookCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "selectedEnvironments":
            suggest = "selected_environments"
        elif key == "excludePatterns":
            suggest = "exclude_patterns"
        elif key == "includePatterns":
            suggest = "include_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReleaseBundleV2PromotionWebhookCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReleaseBundleV2PromotionWebhookCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReleaseBundleV2PromotionWebhookCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 selected_environments: Sequence[_builtins.str],
                 exclude_patterns: Optional[Sequence[_builtins.str]] = None,
                 include_patterns: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] selected_environments: Trigger on this list of environment names.
        """
        pulumi.set(__self__, "selected_environments", selected_environments)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @_builtins.property
    @pulumi.getter(name="selectedEnvironments")
    def selected_environments(self) -> Sequence[_builtins.str]:
        """
        Trigger on this list of environment names.
        """
        return pulumi.get(self, "selected_environments")

    @_builtins.property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "exclude_patterns")

    @_builtins.property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "include_patterns")


@pulumi.output_type
class ReleaseBundleV2PromotionWebhookHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customHttpHeaders":
            suggest = "custom_http_headers"
        elif key == "useSecretForSigning":
            suggest = "use_secret_for_signing"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReleaseBundleV2PromotionWebhookHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReleaseBundleV2PromotionWebhookHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReleaseBundleV2PromotionWebhookHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: _builtins.str,
                 custom_http_headers: Optional[Mapping[str, _builtins.str]] = None,
                 proxy: Optional[_builtins.str] = None,
                 secret: Optional[_builtins.str] = None,
                 use_secret_for_signing: Optional[_builtins.bool] = None):
        """
        :param _builtins.str url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param Mapping[str, _builtins.str] custom_http_headers: Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        :param _builtins.str proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param _builtins.str secret: Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        :param _builtins.bool use_secret_for_signing: When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        pulumi.set(__self__, "url", url)
        if custom_http_headers is not None:
            pulumi.set(__self__, "custom_http_headers", custom_http_headers)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if use_secret_for_signing is not None:
            pulumi.set(__self__, "use_secret_for_signing", use_secret_for_signing)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="customHttpHeaders")
    def custom_http_headers(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        return pulumi.get(self, "custom_http_headers")

    @_builtins.property
    @pulumi.getter
    def proxy(self) -> Optional[_builtins.str]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[_builtins.str]:
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter(name="useSecretForSigning")
    def use_secret_for_signing(self) -> Optional[_builtins.bool]:
        """
        When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        return pulumi.get(self, "use_secret_for_signing")


@pulumi.output_type
class ReleaseBundleV2Source(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "releaseBundles":
            suggest = "release_bundles"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReleaseBundleV2Source. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReleaseBundleV2Source.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReleaseBundleV2Source.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aql: Optional[_builtins.str] = None,
                 artifacts: Optional[Sequence['outputs.ReleaseBundleV2SourceArtifact']] = None,
                 builds: Optional[Sequence['outputs.ReleaseBundleV2SourceBuild']] = None,
                 release_bundles: Optional[Sequence['outputs.ReleaseBundleV2SourceReleaseBundle']] = None):
        """
        :param _builtins.str aql: The contents of the AQL query.
        :param Sequence['ReleaseBundleV2SourceArtifactArgs'] artifacts: Source type to create a Release Bundle v2 version by collecting source artifacts from a list of path/checksum pairs.
        :param Sequence['ReleaseBundleV2SourceBuildArgs'] builds: Source type to create a Release Bundle v2 version by collecting source artifacts from one or multiple builds (also known as build-info).
        :param Sequence['ReleaseBundleV2SourceReleaseBundleArgs'] release_bundles: Source type to create a Release Bundle v2 version by collecting source artifacts from existing Release Bundle versions. Must match `source_type` attribute value.
        """
        if aql is not None:
            pulumi.set(__self__, "aql", aql)
        if artifacts is not None:
            pulumi.set(__self__, "artifacts", artifacts)
        if builds is not None:
            pulumi.set(__self__, "builds", builds)
        if release_bundles is not None:
            pulumi.set(__self__, "release_bundles", release_bundles)

    @_builtins.property
    @pulumi.getter
    def aql(self) -> Optional[_builtins.str]:
        """
        The contents of the AQL query.
        """
        return pulumi.get(self, "aql")

    @_builtins.property
    @pulumi.getter
    def artifacts(self) -> Optional[Sequence['outputs.ReleaseBundleV2SourceArtifact']]:
        """
        Source type to create a Release Bundle v2 version by collecting source artifacts from a list of path/checksum pairs.
        """
        return pulumi.get(self, "artifacts")

    @_builtins.property
    @pulumi.getter
    def builds(self) -> Optional[Sequence['outputs.ReleaseBundleV2SourceBuild']]:
        """
        Source type to create a Release Bundle v2 version by collecting source artifacts from one or multiple builds (also known as build-info).
        """
        return pulumi.get(self, "builds")

    @_builtins.property
    @pulumi.getter(name="releaseBundles")
    def release_bundles(self) -> Optional[Sequence['outputs.ReleaseBundleV2SourceReleaseBundle']]:
        """
        Source type to create a Release Bundle v2 version by collecting source artifacts from existing Release Bundle versions. Must match `source_type` attribute value.
        """
        return pulumi.get(self, "release_bundles")


@pulumi.output_type
class ReleaseBundleV2SourceArtifact(dict):
    def __init__(__self__, *,
                 path: _builtins.str,
                 sha256: Optional[_builtins.str] = None):
        """
        :param _builtins.str path: The path for the artifact
        :param _builtins.str sha256: The SHA256 for the artifact
        """
        pulumi.set(__self__, "path", path)
        if sha256 is not None:
            pulumi.set(__self__, "sha256", sha256)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        The path for the artifact
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def sha256(self) -> Optional[_builtins.str]:
        """
        The SHA256 for the artifact
        """
        return pulumi.get(self, "sha256")


@pulumi.output_type
class ReleaseBundleV2SourceBuild(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeDependencies":
            suggest = "include_dependencies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReleaseBundleV2SourceBuild. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReleaseBundleV2SourceBuild.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReleaseBundleV2SourceBuild.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 number: _builtins.str,
                 include_dependencies: Optional[_builtins.bool] = None,
                 repository: Optional[_builtins.str] = None,
                 started: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of the build.
        :param _builtins.str number: Number (run) of the build.
        :param _builtins.bool include_dependencies: Determines whether to include build dependencies in the Release Bundle. The default value is `false`.
        :param _builtins.str repository: The repository key of the build. If omitted, the system uses the default built-in repository, `artifactory-build-info`.
        :param _builtins.str started: Timestamp when the build was created. If omitted, the system uses the latest build run, as identified by the `name` and `number` combination. The timestamp is provided according to the ISO 8601 standard.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "number", number)
        if include_dependencies is not None:
            pulumi.set(__self__, "include_dependencies", include_dependencies)
        if repository is not None:
            pulumi.set(__self__, "repository", repository)
        if started is not None:
            pulumi.set(__self__, "started", started)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the build.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def number(self) -> _builtins.str:
        """
        Number (run) of the build.
        """
        return pulumi.get(self, "number")

    @_builtins.property
    @pulumi.getter(name="includeDependencies")
    def include_dependencies(self) -> Optional[_builtins.bool]:
        """
        Determines whether to include build dependencies in the Release Bundle. The default value is `false`.
        """
        return pulumi.get(self, "include_dependencies")

    @_builtins.property
    @pulumi.getter
    def repository(self) -> Optional[_builtins.str]:
        """
        The repository key of the build. If omitted, the system uses the default built-in repository, `artifactory-build-info`.
        """
        return pulumi.get(self, "repository")

    @_builtins.property
    @pulumi.getter
    def started(self) -> Optional[_builtins.str]:
        """
        Timestamp when the build was created. If omitted, the system uses the latest build run, as identified by the `name` and `number` combination. The timestamp is provided according to the ISO 8601 standard.
        """
        return pulumi.get(self, "started")


@pulumi.output_type
class ReleaseBundleV2SourceReleaseBundle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "projectKey":
            suggest = "project_key"
        elif key == "repositoryKey":
            suggest = "repository_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReleaseBundleV2SourceReleaseBundle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReleaseBundleV2SourceReleaseBundle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReleaseBundleV2SourceReleaseBundle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 version: _builtins.str,
                 project_key: Optional[_builtins.str] = None,
                 repository_key: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The name of the release bundle.
        :param _builtins.str version: The version of the release bundle.
        :param _builtins.str project_key: Project key of the release bundle.
        :param _builtins.str repository_key: The key of the release bundle repository.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "version", version)
        if project_key is not None:
            pulumi.set(__self__, "project_key", project_key)
        if repository_key is not None:
            pulumi.set(__self__, "repository_key", repository_key)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the release bundle.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        The version of the release bundle.
        """
        return pulumi.get(self, "version")

    @_builtins.property
    @pulumi.getter(name="projectKey")
    def project_key(self) -> Optional[_builtins.str]:
        """
        Project key of the release bundle.
        """
        return pulumi.get(self, "project_key")

    @_builtins.property
    @pulumi.getter(name="repositoryKey")
    def repository_key(self) -> Optional[_builtins.str]:
        """
        The key of the release bundle repository.
        """
        return pulumi.get(self, "repository_key")


@pulumi.output_type
class ReleaseBundleV2WebhookCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyReleaseBundle":
            suggest = "any_release_bundle"
        elif key == "selectedReleaseBundles":
            suggest = "selected_release_bundles"
        elif key == "excludePatterns":
            suggest = "exclude_patterns"
        elif key == "includePatterns":
            suggest = "include_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReleaseBundleV2WebhookCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReleaseBundleV2WebhookCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReleaseBundleV2WebhookCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_release_bundle: _builtins.bool,
                 selected_release_bundles: Sequence[_builtins.str],
                 exclude_patterns: Optional[Sequence[_builtins.str]] = None,
                 include_patterns: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.bool any_release_bundle: Trigger on any release bundle.
        :param Sequence[_builtins.str] selected_release_bundles: Trigger on this list of release bundle names.
        :param Sequence[_builtins.str] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: "org/apache/**".
        :param Sequence[_builtins.str] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: "org/apache/**".
        """
        pulumi.set(__self__, "any_release_bundle", any_release_bundle)
        pulumi.set(__self__, "selected_release_bundles", selected_release_bundles)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @_builtins.property
    @pulumi.getter(name="anyReleaseBundle")
    def any_release_bundle(self) -> _builtins.bool:
        """
        Trigger on any release bundle.
        """
        return pulumi.get(self, "any_release_bundle")

    @_builtins.property
    @pulumi.getter(name="selectedReleaseBundles")
    def selected_release_bundles(self) -> Sequence[_builtins.str]:
        """
        Trigger on this list of release bundle names.
        """
        return pulumi.get(self, "selected_release_bundles")

    @_builtins.property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: "org/apache/**".
        """
        return pulumi.get(self, "exclude_patterns")

    @_builtins.property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: "org/apache/**".
        """
        return pulumi.get(self, "include_patterns")


@pulumi.output_type
class ReleaseBundleV2WebhookHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customHttpHeaders":
            suggest = "custom_http_headers"
        elif key == "useSecretForSigning":
            suggest = "use_secret_for_signing"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReleaseBundleV2WebhookHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReleaseBundleV2WebhookHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReleaseBundleV2WebhookHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: _builtins.str,
                 custom_http_headers: Optional[Mapping[str, _builtins.str]] = None,
                 proxy: Optional[_builtins.str] = None,
                 secret: Optional[_builtins.str] = None,
                 use_secret_for_signing: Optional[_builtins.bool] = None):
        """
        :param _builtins.str url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param Mapping[str, _builtins.str] custom_http_headers: Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        :param _builtins.str proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param _builtins.str secret: Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        :param _builtins.bool use_secret_for_signing: When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        pulumi.set(__self__, "url", url)
        if custom_http_headers is not None:
            pulumi.set(__self__, "custom_http_headers", custom_http_headers)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if use_secret_for_signing is not None:
            pulumi.set(__self__, "use_secret_for_signing", use_secret_for_signing)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="customHttpHeaders")
    def custom_http_headers(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        return pulumi.get(self, "custom_http_headers")

    @_builtins.property
    @pulumi.getter
    def proxy(self) -> Optional[_builtins.str]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[_builtins.str]:
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter(name="useSecretForSigning")
    def use_secret_for_signing(self) -> Optional[_builtins.bool]:
        """
        When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        return pulumi.get(self, "use_secret_for_signing")


@pulumi.output_type
class ReleaseBundleWebhookCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyReleaseBundle":
            suggest = "any_release_bundle"
        elif key == "registeredReleaseBundleNames":
            suggest = "registered_release_bundle_names"
        elif key == "excludePatterns":
            suggest = "exclude_patterns"
        elif key == "includePatterns":
            suggest = "include_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReleaseBundleWebhookCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReleaseBundleWebhookCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReleaseBundleWebhookCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_release_bundle: _builtins.bool,
                 registered_release_bundle_names: Sequence[_builtins.str],
                 exclude_patterns: Optional[Sequence[_builtins.str]] = None,
                 include_patterns: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.bool any_release_bundle: Trigger on any release bundle.
        :param Sequence[_builtins.str] registered_release_bundle_names: Trigger on this list of release bundle names.
        :param Sequence[_builtins.str] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: "org/apache/**".
        :param Sequence[_builtins.str] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: "org/apache/**".
        """
        pulumi.set(__self__, "any_release_bundle", any_release_bundle)
        pulumi.set(__self__, "registered_release_bundle_names", registered_release_bundle_names)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @_builtins.property
    @pulumi.getter(name="anyReleaseBundle")
    def any_release_bundle(self) -> _builtins.bool:
        """
        Trigger on any release bundle.
        """
        return pulumi.get(self, "any_release_bundle")

    @_builtins.property
    @pulumi.getter(name="registeredReleaseBundleNames")
    def registered_release_bundle_names(self) -> Sequence[_builtins.str]:
        """
        Trigger on this list of release bundle names.
        """
        return pulumi.get(self, "registered_release_bundle_names")

    @_builtins.property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: "org/apache/**".
        """
        return pulumi.get(self, "exclude_patterns")

    @_builtins.property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: "org/apache/**".
        """
        return pulumi.get(self, "include_patterns")


@pulumi.output_type
class ReleaseBundleWebhookHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customHttpHeaders":
            suggest = "custom_http_headers"
        elif key == "useSecretForSigning":
            suggest = "use_secret_for_signing"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReleaseBundleWebhookHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReleaseBundleWebhookHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReleaseBundleWebhookHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: _builtins.str,
                 custom_http_headers: Optional[Mapping[str, _builtins.str]] = None,
                 proxy: Optional[_builtins.str] = None,
                 secret: Optional[_builtins.str] = None,
                 use_secret_for_signing: Optional[_builtins.bool] = None):
        """
        :param _builtins.str url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param Mapping[str, _builtins.str] custom_http_headers: Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        :param _builtins.str proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param _builtins.str secret: Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        :param _builtins.bool use_secret_for_signing: When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        pulumi.set(__self__, "url", url)
        if custom_http_headers is not None:
            pulumi.set(__self__, "custom_http_headers", custom_http_headers)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if use_secret_for_signing is not None:
            pulumi.set(__self__, "use_secret_for_signing", use_secret_for_signing)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="customHttpHeaders")
    def custom_http_headers(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        return pulumi.get(self, "custom_http_headers")

    @_builtins.property
    @pulumi.getter
    def proxy(self) -> Optional[_builtins.str]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[_builtins.str]:
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter(name="useSecretForSigning")
    def use_secret_for_signing(self) -> Optional[_builtins.bool]:
        """
        When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        return pulumi.get(self, "use_secret_for_signing")


@pulumi.output_type
class RemoteAlpineRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteAlpineRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteAlpineRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteAlpineRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteAnsibleRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteAnsibleRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteAnsibleRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteAnsibleRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteBowerRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteBowerRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteBowerRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteBowerRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteCargoRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteCargoRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteCargoRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteCargoRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteChefRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteChefRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteChefRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteChefRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteCocoapodsRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteCocoapodsRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteCocoapodsRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteCocoapodsRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteComposerRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteComposerRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteComposerRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteComposerRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteConanRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteConanRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteConanRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteConanRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteCondaRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteCondaRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteCondaRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteCondaRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteCranRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteCranRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteCranRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteCranRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteDebianRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteDebianRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteDebianRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteDebianRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteDockerRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteDockerRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteDockerRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteDockerRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteGemsRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteGemsRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteGemsRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteGemsRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteGenericRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteGenericRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteGenericRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteGenericRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteGitlfsRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteGitlfsRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteGitlfsRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteGitlfsRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteGoRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteGoRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteGoRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteGoRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteGradleRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteGradleRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteGradleRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteGradleRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteHelmRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteHelmRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteHelmRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteHelmRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteHelmociRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteHelmociRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteHelmociRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteHelmociRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteHuggingfacemlRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteHuggingfacemlRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteHuggingfacemlRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteHuggingfacemlRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteIvyRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteIvyRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteIvyRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteIvyRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteMavenRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteMavenRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteMavenRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteMavenRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteNpmRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteNpmRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteNpmRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteNpmRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteNugetRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteNugetRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteNugetRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteNugetRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteOciRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteOciRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteOciRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteOciRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteOpkgRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteOpkgRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteOpkgRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteOpkgRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteP2RepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteP2RepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteP2RepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteP2RepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemotePubRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemotePubRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemotePubRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemotePubRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemotePuppetRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemotePuppetRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemotePuppetRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemotePuppetRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemotePypiRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemotePypiRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemotePypiRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemotePypiRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteRpmRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteRpmRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteRpmRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteRpmRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteSbtRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteSbtRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteSbtRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteSbtRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteSwiftRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteSwiftRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteSwiftRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteSwiftRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteTerraformRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteTerraformRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteTerraformRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteTerraformRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteVcsRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteVcsRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteVcsRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteVcsRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class UnmanagedUserPasswordPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "specialChar":
            suggest = "special_char"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UnmanagedUserPasswordPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UnmanagedUserPasswordPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UnmanagedUserPasswordPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 digit: Optional[_builtins.int] = None,
                 length: Optional[_builtins.int] = None,
                 lowercase: Optional[_builtins.int] = None,
                 special_char: Optional[_builtins.int] = None,
                 uppercase: Optional[_builtins.int] = None):
        """
        :param _builtins.int digit: Minimum number of digits that the password must contain
        :param _builtins.int length: Minimum length of the password
        :param _builtins.int lowercase: Minimum number of lowercase letters that the password must contain
        :param _builtins.int special_char: Minimum number of special char that the password must contain. Special chars list: ``!"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~``
        :param _builtins.int uppercase: Minimum number of uppercase letters that the password must contain
        """
        if digit is not None:
            pulumi.set(__self__, "digit", digit)
        if length is not None:
            pulumi.set(__self__, "length", length)
        if lowercase is not None:
            pulumi.set(__self__, "lowercase", lowercase)
        if special_char is not None:
            pulumi.set(__self__, "special_char", special_char)
        if uppercase is not None:
            pulumi.set(__self__, "uppercase", uppercase)

    @_builtins.property
    @pulumi.getter
    def digit(self) -> Optional[_builtins.int]:
        """
        Minimum number of digits that the password must contain
        """
        return pulumi.get(self, "digit")

    @_builtins.property
    @pulumi.getter
    def length(self) -> Optional[_builtins.int]:
        """
        Minimum length of the password
        """
        return pulumi.get(self, "length")

    @_builtins.property
    @pulumi.getter
    def lowercase(self) -> Optional[_builtins.int]:
        """
        Minimum number of lowercase letters that the password must contain
        """
        return pulumi.get(self, "lowercase")

    @_builtins.property
    @pulumi.getter(name="specialChar")
    def special_char(self) -> Optional[_builtins.int]:
        """
        Minimum number of special char that the password must contain. Special chars list: ``!"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~``
        """
        return pulumi.get(self, "special_char")

    @_builtins.property
    @pulumi.getter
    def uppercase(self) -> Optional[_builtins.int]:
        """
        Minimum number of uppercase letters that the password must contain
        """
        return pulumi.get(self, "uppercase")


@pulumi.output_type
class UserCustomWebhookHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpHeaders":
            suggest = "http_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserCustomWebhookHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserCustomWebhookHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserCustomWebhookHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: _builtins.str,
                 http_headers: Optional[Mapping[str, _builtins.str]] = None,
                 method: Optional[_builtins.str] = None,
                 payload: Optional[_builtins.str] = None,
                 proxy: Optional[_builtins.str] = None,
                 secrets: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send a request to.
        :param Mapping[str, _builtins.str] http_headers: HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        :param _builtins.str method: Specifies the HTTP method for the URL that the Webhook invokes. Allowed values are: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`.
        :param _builtins.str payload: This attribute is used to build the request body. Used in custom webhooks
        :param _builtins.str proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param Mapping[str, _builtins.str] secrets: Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
        pulumi.set(__self__, "url", url)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send a request to.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        """
        return pulumi.get(self, "http_headers")

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[_builtins.str]:
        """
        Specifies the HTTP method for the URL that the Webhook invokes. Allowed values are: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`.
        """
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter
    def payload(self) -> Optional[_builtins.str]:
        """
        This attribute is used to build the request body. Used in custom webhooks
        """
        return pulumi.get(self, "payload")

    @_builtins.property
    @pulumi.getter
    def proxy(self) -> Optional[_builtins.str]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @_builtins.property
    @pulumi.getter
    def secrets(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
        return pulumi.get(self, "secrets")


@pulumi.output_type
class UserPasswordPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "specialChar":
            suggest = "special_char"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserPasswordPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserPasswordPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserPasswordPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 digit: Optional[_builtins.int] = None,
                 length: Optional[_builtins.int] = None,
                 lowercase: Optional[_builtins.int] = None,
                 special_char: Optional[_builtins.int] = None,
                 uppercase: Optional[_builtins.int] = None):
        """
        :param _builtins.int digit: Minimum number of digits that the password must contain
        :param _builtins.int length: Minimum length of the password
        :param _builtins.int lowercase: Minimum number of lowercase letters that the password must contain
        :param _builtins.int special_char: Minimum number of special char that the password must contain. Special chars list: `!"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~`
        :param _builtins.int uppercase: Minimum number of uppercase letters that the password must contain
        """
        if digit is not None:
            pulumi.set(__self__, "digit", digit)
        if length is not None:
            pulumi.set(__self__, "length", length)
        if lowercase is not None:
            pulumi.set(__self__, "lowercase", lowercase)
        if special_char is not None:
            pulumi.set(__self__, "special_char", special_char)
        if uppercase is not None:
            pulumi.set(__self__, "uppercase", uppercase)

    @_builtins.property
    @pulumi.getter
    def digit(self) -> Optional[_builtins.int]:
        """
        Minimum number of digits that the password must contain
        """
        return pulumi.get(self, "digit")

    @_builtins.property
    @pulumi.getter
    def length(self) -> Optional[_builtins.int]:
        """
        Minimum length of the password
        """
        return pulumi.get(self, "length")

    @_builtins.property
    @pulumi.getter
    def lowercase(self) -> Optional[_builtins.int]:
        """
        Minimum number of lowercase letters that the password must contain
        """
        return pulumi.get(self, "lowercase")

    @_builtins.property
    @pulumi.getter(name="specialChar")
    def special_char(self) -> Optional[_builtins.int]:
        """
        Minimum number of special char that the password must contain. Special chars list: `!"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~`
        """
        return pulumi.get(self, "special_char")

    @_builtins.property
    @pulumi.getter
    def uppercase(self) -> Optional[_builtins.int]:
        """
        Minimum number of uppercase letters that the password must contain
        """
        return pulumi.get(self, "uppercase")


@pulumi.output_type
class UserWebhookHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customHttpHeaders":
            suggest = "custom_http_headers"
        elif key == "useSecretForSigning":
            suggest = "use_secret_for_signing"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserWebhookHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserWebhookHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserWebhookHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: _builtins.str,
                 custom_http_headers: Optional[Mapping[str, _builtins.str]] = None,
                 proxy: Optional[_builtins.str] = None,
                 secret: Optional[_builtins.str] = None,
                 use_secret_for_signing: Optional[_builtins.bool] = None):
        """
        :param _builtins.str url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param Mapping[str, _builtins.str] custom_http_headers: Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        :param _builtins.str proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param _builtins.str secret: Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        :param _builtins.bool use_secret_for_signing: When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        pulumi.set(__self__, "url", url)
        if custom_http_headers is not None:
            pulumi.set(__self__, "custom_http_headers", custom_http_headers)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if use_secret_for_signing is not None:
            pulumi.set(__self__, "use_secret_for_signing", use_secret_for_signing)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="customHttpHeaders")
    def custom_http_headers(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        return pulumi.get(self, "custom_http_headers")

    @_builtins.property
    @pulumi.getter
    def proxy(self) -> Optional[_builtins.str]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[_builtins.str]:
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter(name="useSecretForSigning")
    def use_secret_for_signing(self) -> Optional[_builtins.bool]:
        """
        When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        return pulumi.get(self, "use_secret_for_signing")


@pulumi.output_type
class VaultConfigurationConfig(dict):
    def __init__(__self__, *,
                 auth: 'outputs.VaultConfigurationConfigAuth',
                 mounts: Sequence['outputs.VaultConfigurationConfigMount'],
                 url: _builtins.str):
        """
        :param _builtins.str url: The base URL of the Vault server.
        """
        pulumi.set(__self__, "auth", auth)
        pulumi.set(__self__, "mounts", mounts)
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def auth(self) -> 'outputs.VaultConfigurationConfigAuth':
        return pulumi.get(self, "auth")

    @_builtins.property
    @pulumi.getter
    def mounts(self) -> Sequence['outputs.VaultConfigurationConfigMount']:
        return pulumi.get(self, "mounts")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The base URL of the Vault server.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class VaultConfigurationConfigAuth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateKey":
            suggest = "certificate_key"
        elif key == "roleId":
            suggest = "role_id"
        elif key == "secretId":
            suggest = "secret_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VaultConfigurationConfigAuth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VaultConfigurationConfigAuth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VaultConfigurationConfigAuth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 certificate: Optional[_builtins.str] = None,
                 certificate_key: Optional[_builtins.str] = None,
                 role_id: Optional[_builtins.str] = None,
                 secret_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str certificate: Client certificate (in PEM format) for `Certificate` type.
        :param _builtins.str certificate_key: Private key (in PEM format) for `Certificate` type.
        :param _builtins.str role_id: Role ID for `AppRole` type
        :param _builtins.str secret_id: Secret ID for `AppRole` type
        """
        pulumi.set(__self__, "type", type)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if certificate_key is not None:
            pulumi.set(__self__, "certificate_key", certificate_key)
        if role_id is not None:
            pulumi.set(__self__, "role_id", role_id)
        if secret_id is not None:
            pulumi.set(__self__, "secret_id", secret_id)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def certificate(self) -> Optional[_builtins.str]:
        """
        Client certificate (in PEM format) for `Certificate` type.
        """
        return pulumi.get(self, "certificate")

    @_builtins.property
    @pulumi.getter(name="certificateKey")
    def certificate_key(self) -> Optional[_builtins.str]:
        """
        Private key (in PEM format) for `Certificate` type.
        """
        return pulumi.get(self, "certificate_key")

    @_builtins.property
    @pulumi.getter(name="roleId")
    def role_id(self) -> Optional[_builtins.str]:
        """
        Role ID for `AppRole` type
        """
        return pulumi.get(self, "role_id")

    @_builtins.property
    @pulumi.getter(name="secretId")
    def secret_id(self) -> Optional[_builtins.str]:
        """
        Secret ID for `AppRole` type
        """
        return pulumi.get(self, "secret_id")


@pulumi.output_type
class VaultConfigurationConfigMount(dict):
    def __init__(__self__, *,
                 path: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str path: Vault secret engine path
        :param _builtins.str type: Vault supports several secret engines, each one has different capabilities. The supported secret engine types are: `KV1` and `KV2`.
        """
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Vault secret engine path
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Vault supports several secret engines, each one has different capabilities. The supported secret engine types are: `KV1` and `KV2`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetFederatedAlpineRepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class GetFederatedAnsibleRepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class GetFederatedBowerRepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class GetFederatedCargoRepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class GetFederatedChefRepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class GetFederatedCocoapodsRepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class GetFederatedComposerRepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class GetFederatedConanRepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class GetFederatedCondaRepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class GetFederatedCranRepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class GetFederatedDebianRepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class GetFederatedDockerRepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repositoryName
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repositoryName
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class GetFederatedDockerV1RepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class GetFederatedDockerV2RepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class GetFederatedGemsRepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class GetFederatedGenericRepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class GetFederatedGitlfsRepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class GetFederatedGoRepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class GetFederatedGradleRepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class GetFederatedHelmRepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class GetFederatedHelmociRepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class GetFederatedHuggingfacemlRepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repositoryName
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repositoryName
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class GetFederatedIvyRepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class GetFederatedMavenRepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class GetFederatedNpmRepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class GetFederatedNugetRepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class GetFederatedOciRepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class GetFederatedOpkgRepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class GetFederatedPuppetRepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class GetFederatedPypiRepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class GetFederatedRpmRepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class GetFederatedSbtRepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class GetFederatedSwiftRepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class GetFederatedTerraformModuleRepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class GetFederatedTerraformProviderRepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class GetFederatedVagrantRepositoryMemberResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class GetFileListFileResult(dict):
    def __init__(__self__, *,
                 folder: _builtins.bool,
                 last_modified: _builtins.str,
                 metadata_timestamps: 'outputs.GetFileListFileMetadataTimestampsResult',
                 sha1: _builtins.str,
                 sha2: _builtins.str,
                 size: _builtins.int,
                 uri: _builtins.str):
        """
        :param _builtins.bool folder: Is this a folder
        :param _builtins.str last_modified: Last modified time
        :param 'GetFileListFileMetadataTimestampsArgs' metadata_timestamps: File metadata
        :param _builtins.str sha1: SHA-1 checksum
        :param _builtins.str sha2: SHA-256 checksum
        :param _builtins.int size: File size in bytes
        :param _builtins.str uri: URL to file
        """
        pulumi.set(__self__, "folder", folder)
        pulumi.set(__self__, "last_modified", last_modified)
        pulumi.set(__self__, "metadata_timestamps", metadata_timestamps)
        pulumi.set(__self__, "sha1", sha1)
        pulumi.set(__self__, "sha2", sha2)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter
    def folder(self) -> _builtins.bool:
        """
        Is this a folder
        """
        return pulumi.get(self, "folder")

    @_builtins.property
    @pulumi.getter(name="lastModified")
    def last_modified(self) -> _builtins.str:
        """
        Last modified time
        """
        return pulumi.get(self, "last_modified")

    @_builtins.property
    @pulumi.getter(name="metadataTimestamps")
    def metadata_timestamps(self) -> 'outputs.GetFileListFileMetadataTimestampsResult':
        """
        File metadata
        """
        return pulumi.get(self, "metadata_timestamps")

    @_builtins.property
    @pulumi.getter
    def sha1(self) -> _builtins.str:
        """
        SHA-1 checksum
        """
        return pulumi.get(self, "sha1")

    @_builtins.property
    @pulumi.getter
    def sha2(self) -> _builtins.str:
        """
        SHA-256 checksum
        """
        return pulumi.get(self, "sha2")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.int:
        """
        File size in bytes
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter
    def uri(self) -> _builtins.str:
        """
        URL to file
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class GetFileListFileMetadataTimestampsResult(dict):
    def __init__(__self__, *,
                 properties: _builtins.str):
        """
        :param _builtins.str properties: Properties timestamp
        """
        pulumi.set(__self__, "properties", properties)

    @_builtins.property
    @pulumi.getter
    def properties(self) -> _builtins.str:
        """
        Properties timestamp
        """
        return pulumi.get(self, "properties")


@pulumi.output_type
class GetPermissionTargetBuildResult(dict):
    def __init__(__self__, *,
                 repositories: Sequence[_builtins.str],
                 actions: Optional['outputs.GetPermissionTargetBuildActionsResult'] = None,
                 excludes_patterns: Optional[Sequence[_builtins.str]] = None,
                 includes_patterns: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] repositories: List of repositories this permission target is applicable for. You can specify the
               name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote
               repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        :param Sequence[_builtins.str] excludes_patterns: Pattern of artifacts to exclude.
        :param Sequence[_builtins.str] includes_patterns: Pattern of artifacts to include.
        """
        pulumi.set(__self__, "repositories", repositories)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if excludes_patterns is not None:
            pulumi.set(__self__, "excludes_patterns", excludes_patterns)
        if includes_patterns is not None:
            pulumi.set(__self__, "includes_patterns", includes_patterns)

    @_builtins.property
    @pulumi.getter
    def repositories(self) -> Sequence[_builtins.str]:
        """
        List of repositories this permission target is applicable for. You can specify the
        name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote
        repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        """
        return pulumi.get(self, "repositories")

    @_builtins.property
    @pulumi.getter
    def actions(self) -> Optional['outputs.GetPermissionTargetBuildActionsResult']:
        return pulumi.get(self, "actions")

    @_builtins.property
    @pulumi.getter(name="excludesPatterns")
    def excludes_patterns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Pattern of artifacts to exclude.
        """
        return pulumi.get(self, "excludes_patterns")

    @_builtins.property
    @pulumi.getter(name="includesPatterns")
    def includes_patterns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Pattern of artifacts to include.
        """
        return pulumi.get(self, "includes_patterns")


@pulumi.output_type
class GetPermissionTargetBuildActionsResult(dict):
    def __init__(__self__, *,
                 groups: Optional[Sequence['outputs.GetPermissionTargetBuildActionsGroupResult']] = None,
                 users: Optional[Sequence['outputs.GetPermissionTargetBuildActionsUserResult']] = None):
        """
        :param Sequence['GetPermissionTargetBuildActionsGroupArgs'] groups: Groups this permission applies for.
        :param Sequence['GetPermissionTargetBuildActionsUserArgs'] users: Users this permission target applies for.
        """
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @_builtins.property
    @pulumi.getter
    def groups(self) -> Optional[Sequence['outputs.GetPermissionTargetBuildActionsGroupResult']]:
        """
        Groups this permission applies for.
        """
        return pulumi.get(self, "groups")

    @_builtins.property
    @pulumi.getter
    def users(self) -> Optional[Sequence['outputs.GetPermissionTargetBuildActionsUserResult']]:
        """
        Users this permission target applies for.
        """
        return pulumi.get(self, "users")


@pulumi.output_type
class GetPermissionTargetBuildActionsGroupResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 permissions: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Name of the permission target.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the permission target.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def permissions(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "permissions")


@pulumi.output_type
class GetPermissionTargetBuildActionsUserResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 permissions: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Name of the permission target.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the permission target.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def permissions(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "permissions")


@pulumi.output_type
class GetPermissionTargetReleaseBundleResult(dict):
    def __init__(__self__, *,
                 repositories: Sequence[_builtins.str],
                 actions: Optional['outputs.GetPermissionTargetReleaseBundleActionsResult'] = None,
                 excludes_patterns: Optional[Sequence[_builtins.str]] = None,
                 includes_patterns: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] repositories: List of repositories this permission target is applicable for. You can specify the
               name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote
               repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        :param Sequence[_builtins.str] excludes_patterns: Pattern of artifacts to exclude.
        :param Sequence[_builtins.str] includes_patterns: Pattern of artifacts to include.
        """
        pulumi.set(__self__, "repositories", repositories)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if excludes_patterns is not None:
            pulumi.set(__self__, "excludes_patterns", excludes_patterns)
        if includes_patterns is not None:
            pulumi.set(__self__, "includes_patterns", includes_patterns)

    @_builtins.property
    @pulumi.getter
    def repositories(self) -> Sequence[_builtins.str]:
        """
        List of repositories this permission target is applicable for. You can specify the
        name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote
        repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        """
        return pulumi.get(self, "repositories")

    @_builtins.property
    @pulumi.getter
    def actions(self) -> Optional['outputs.GetPermissionTargetReleaseBundleActionsResult']:
        return pulumi.get(self, "actions")

    @_builtins.property
    @pulumi.getter(name="excludesPatterns")
    def excludes_patterns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Pattern of artifacts to exclude.
        """
        return pulumi.get(self, "excludes_patterns")

    @_builtins.property
    @pulumi.getter(name="includesPatterns")
    def includes_patterns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Pattern of artifacts to include.
        """
        return pulumi.get(self, "includes_patterns")


@pulumi.output_type
class GetPermissionTargetReleaseBundleActionsResult(dict):
    def __init__(__self__, *,
                 groups: Optional[Sequence['outputs.GetPermissionTargetReleaseBundleActionsGroupResult']] = None,
                 users: Optional[Sequence['outputs.GetPermissionTargetReleaseBundleActionsUserResult']] = None):
        """
        :param Sequence['GetPermissionTargetReleaseBundleActionsGroupArgs'] groups: Groups this permission applies for.
        :param Sequence['GetPermissionTargetReleaseBundleActionsUserArgs'] users: Users this permission target applies for.
        """
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @_builtins.property
    @pulumi.getter
    def groups(self) -> Optional[Sequence['outputs.GetPermissionTargetReleaseBundleActionsGroupResult']]:
        """
        Groups this permission applies for.
        """
        return pulumi.get(self, "groups")

    @_builtins.property
    @pulumi.getter
    def users(self) -> Optional[Sequence['outputs.GetPermissionTargetReleaseBundleActionsUserResult']]:
        """
        Users this permission target applies for.
        """
        return pulumi.get(self, "users")


@pulumi.output_type
class GetPermissionTargetReleaseBundleActionsGroupResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 permissions: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Name of the permission target.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the permission target.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def permissions(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "permissions")


@pulumi.output_type
class GetPermissionTargetReleaseBundleActionsUserResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 permissions: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Name of the permission target.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the permission target.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def permissions(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "permissions")


@pulumi.output_type
class GetPermissionTargetRepoResult(dict):
    def __init__(__self__, *,
                 repositories: Sequence[_builtins.str],
                 actions: Optional['outputs.GetPermissionTargetRepoActionsResult'] = None,
                 excludes_patterns: Optional[Sequence[_builtins.str]] = None,
                 includes_patterns: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] repositories: List of repositories this permission target is applicable for. You can specify the
               name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote
               repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        :param Sequence[_builtins.str] excludes_patterns: Pattern of artifacts to exclude.
        :param Sequence[_builtins.str] includes_patterns: Pattern of artifacts to include.
        """
        pulumi.set(__self__, "repositories", repositories)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if excludes_patterns is not None:
            pulumi.set(__self__, "excludes_patterns", excludes_patterns)
        if includes_patterns is not None:
            pulumi.set(__self__, "includes_patterns", includes_patterns)

    @_builtins.property
    @pulumi.getter
    def repositories(self) -> Sequence[_builtins.str]:
        """
        List of repositories this permission target is applicable for. You can specify the
        name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote
        repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        """
        return pulumi.get(self, "repositories")

    @_builtins.property
    @pulumi.getter
    def actions(self) -> Optional['outputs.GetPermissionTargetRepoActionsResult']:
        return pulumi.get(self, "actions")

    @_builtins.property
    @pulumi.getter(name="excludesPatterns")
    def excludes_patterns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Pattern of artifacts to exclude.
        """
        return pulumi.get(self, "excludes_patterns")

    @_builtins.property
    @pulumi.getter(name="includesPatterns")
    def includes_patterns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Pattern of artifacts to include.
        """
        return pulumi.get(self, "includes_patterns")


@pulumi.output_type
class GetPermissionTargetRepoActionsResult(dict):
    def __init__(__self__, *,
                 groups: Optional[Sequence['outputs.GetPermissionTargetRepoActionsGroupResult']] = None,
                 users: Optional[Sequence['outputs.GetPermissionTargetRepoActionsUserResult']] = None):
        """
        :param Sequence['GetPermissionTargetRepoActionsGroupArgs'] groups: Groups this permission applies for.
        :param Sequence['GetPermissionTargetRepoActionsUserArgs'] users: Users this permission target applies for.
        """
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @_builtins.property
    @pulumi.getter
    def groups(self) -> Optional[Sequence['outputs.GetPermissionTargetRepoActionsGroupResult']]:
        """
        Groups this permission applies for.
        """
        return pulumi.get(self, "groups")

    @_builtins.property
    @pulumi.getter
    def users(self) -> Optional[Sequence['outputs.GetPermissionTargetRepoActionsUserResult']]:
        """
        Users this permission target applies for.
        """
        return pulumi.get(self, "users")


@pulumi.output_type
class GetPermissionTargetRepoActionsGroupResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 permissions: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Name of the permission target.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the permission target.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def permissions(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "permissions")


@pulumi.output_type
class GetPermissionTargetRepoActionsUserResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 permissions: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Name of the permission target.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the permission target.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def permissions(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "permissions")


@pulumi.output_type
class GetRemoteAlpineRepositoryContentSynchronisationResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class GetRemoteAnsibleRepositoryContentSynchronisationResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class GetRemoteBowerRepositoryContentSynchronisationResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class GetRemoteCargoRepositoryContentSynchronisationResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class GetRemoteChefRepositoryContentSynchronisationResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class GetRemoteCocoapodsRepositoryContentSynchronisationResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class GetRemoteComposerRepositoryContentSynchronisationResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class GetRemoteConanRepositoryContentSynchronisationResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class GetRemoteCondaRepositoryContentSynchronisationResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class GetRemoteCranRepositoryContentSynchronisationResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class GetRemoteDebianRepositoryContentSynchronisationResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class GetRemoteDockerRepositoryContentSynchronisationResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class GetRemoteGenericRepositoryContentSynchronisationResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class GetRemoteGitlfsRepositoryContentSynchronisationResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class GetRemoteGoRepositoryContentSynchronisationResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class GetRemoteGradleRepositoryContentSynchronisationResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class GetRemoteHelmRepositoryContentSynchronisationResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class GetRemoteHelmociRepositoryContentSynchronisationResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class GetRemoteIvyRepositoryContentSynchronisationResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class GetRemoteMavenRepositoryContentSynchronisationResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class GetRemoteNpmRepositoryContentSynchronisationResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class GetRemoteNugetRepositoryContentSynchronisationResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class GetRemoteOciRepositoryContentSynchronisationResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class GetRemoteOpkgRepositoryContentSynchronisationResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class GetRemoteP2RepositoryContentSynchronisationResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class GetRemotePubRepositoryContentSynchronisationResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class GetRemotePuppetRepositoryContentSynchronisationResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class GetRemotePypiRepositoryContentSynchronisationResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class GetRemoteRpmRepositoryContentSynchronisationResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class GetRemoteSbtRepositoryContentSynchronisationResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class GetRemoteSwiftRepositoryContentSynchronisationResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class GetRemoteTerraformRepositoryContentSynchronisationResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class GetRemoteVcsRepositoryContentSynchronisationResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class GetRepositoriesRepoResult(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 key: _builtins.str,
                 package_type: _builtins.str,
                 type: _builtins.str,
                 url: _builtins.str):
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "package_type", package_type)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter(name="packageType")
    def package_type(self) -> _builtins.str:
        return pulumi.get(self, "package_type")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        return pulumi.get(self, "url")


