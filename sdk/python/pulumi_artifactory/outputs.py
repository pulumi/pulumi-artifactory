# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'AccessTokenAdminToken',
    'ArtifactPropertyWebhookCriteria',
    'ArtifactPropertyWebhookHandler',
    'ArtifactWebhookCriteria',
    'ArtifactWebhookHandler',
    'ArtifactoryReleaseBundleWebhookCriteria',
    'ArtifactoryReleaseBundleWebhookHandler',
    'BuildWebhookCriteria',
    'BuildWebhookHandler',
    'DistributionWebhookCriteria',
    'DistributionWebhookHandler',
    'DockerWebhookCriteria',
    'DockerWebhookHandler',
    'FederatedAlpineRepositoryMember',
    'FederatedBowerRepositoryMember',
    'FederatedCargoRepositoryMember',
    'FederatedChefRepositoryMember',
    'FederatedCocoapodsRepositoryMember',
    'FederatedComposerRepositoryMember',
    'FederatedConanRepositoryMember',
    'FederatedCondaRepositoryMember',
    'FederatedCranRepositoryMember',
    'FederatedDebianRepositoryMember',
    'FederatedDockerRepositoryMember',
    'FederatedDockerV1RepositoryMember',
    'FederatedDockerV2RepositoryMember',
    'FederatedGemsRepositoryMember',
    'FederatedGenericRepositoryMember',
    'FederatedGitltfsRepositoryMember',
    'FederatedGoRepositoryMember',
    'FederatedGradleRepositoryMember',
    'FederatedHelmRepositoryMember',
    'FederatedIvyRepositoryMember',
    'FederatedMavenRepositoryMember',
    'FederatedNpmRepositoryMember',
    'FederatedNugetRepositoryMember',
    'FederatedOpkgRepositoryMember',
    'FederatedPuppetRepositoryMember',
    'FederatedPypiRepositoryMember',
    'FederatedRpmRepositoryMember',
    'FederatedSbtRepositoryMember',
    'FederatedSwiftRepositoryMember',
    'FederatedTerraformModuleRepositoryMember',
    'FederatedTerraformProviderRepositoryMember',
    'FederatedVagrantRepositoryMember',
    'OauthSettingsOauthProvider',
    'PermissionTargetBuild',
    'PermissionTargetBuildActions',
    'PermissionTargetBuildActionsGroup',
    'PermissionTargetBuildActionsUser',
    'PermissionTargetReleaseBundle',
    'PermissionTargetReleaseBundleActions',
    'PermissionTargetReleaseBundleActionsGroup',
    'PermissionTargetReleaseBundleActionsUser',
    'PermissionTargetRepo',
    'PermissionTargetRepoActions',
    'PermissionTargetRepoActionsGroup',
    'PermissionTargetRepoActionsUser',
    'PermissionTargetsBuild',
    'PermissionTargetsBuildActions',
    'PermissionTargetsBuildActionsGroup',
    'PermissionTargetsBuildActionsUser',
    'PermissionTargetsReleaseBundle',
    'PermissionTargetsReleaseBundleActions',
    'PermissionTargetsReleaseBundleActionsGroup',
    'PermissionTargetsReleaseBundleActionsUser',
    'PermissionTargetsRepo',
    'PermissionTargetsRepoActions',
    'PermissionTargetsRepoActionsGroup',
    'PermissionTargetsRepoActionsUser',
    'PropertySetProperty',
    'PropertySetPropertyPredefinedValue',
    'PushReplicationReplication',
    'ReleaseBundleWebhookCriteria',
    'ReleaseBundleWebhookHandler',
    'RemoteAlpineRepositoryContentSynchronisation',
    'RemoteBowerRepositoryContentSynchronisation',
    'RemoteCargoRepositoryContentSynchronisation',
    'RemoteChefRepositoryContentSynchronisation',
    'RemoteCocoapodsRepositoryContentSynchronisation',
    'RemoteComposerRepositoryContentSynchronisation',
    'RemoteConanRepositoryContentSynchronisation',
    'RemoteCondaRepositoryContentSynchronisation',
    'RemoteCranRepositoryContentSynchronisation',
    'RemoteDebianRepositoryContentSynchronisation',
    'RemoteDockerRepositoryContentSynchronisation',
    'RemoteGemsRepositoryContentSynchronisation',
    'RemoteGenericRepositoryContentSynchronisation',
    'RemoteGitlfsRepositoryContentSynchronisation',
    'RemoteGoRepositoryContentSynchronisation',
    'RemoteGradleRepositoryContentSynchronisation',
    'RemoteHelmRepositoryContentSynchronisation',
    'RemoteIvyRepositoryContentSynchronisation',
    'RemoteMavenRepositoryContentSynchronisation',
    'RemoteNpmRepositoryContentSynchronisation',
    'RemoteNugetRepositoryContentSynchronisation',
    'RemoteOpkgRepositoryContentSynchronisation',
    'RemoteP2RepositoryContentSynchronisation',
    'RemotePubRepositoryContentSynchronisation',
    'RemotePuppetRepositoryContentSynchronisation',
    'RemotePypiRepositoryContentSynchronisation',
    'RemoteRpmRepositoryContentSynchronisation',
    'RemoteSbtRepositoryContentSynchronisation',
    'RemoteSwiftRepositoryContentSynchronisation',
    'RemoteTerraformRepositoryContentSynchronisation',
    'RemoteVcsRepositoryContentSynchronisation',
    'ReplicationConfigReplication',
    'GetPermissionTargetBuildResult',
    'GetPermissionTargetBuildActionsResult',
    'GetPermissionTargetBuildActionsGroupResult',
    'GetPermissionTargetBuildActionsUserResult',
    'GetPermissionTargetReleaseBundleResult',
    'GetPermissionTargetReleaseBundleActionsResult',
    'GetPermissionTargetReleaseBundleActionsGroupResult',
    'GetPermissionTargetReleaseBundleActionsUserResult',
    'GetPermissionTargetRepoResult',
    'GetPermissionTargetRepoActionsResult',
    'GetPermissionTargetRepoActionsGroupResult',
    'GetPermissionTargetRepoActionsUserResult',
]

@pulumi.output_type
class AccessTokenAdminToken(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceId":
            suggest = "instance_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessTokenAdminToken. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessTokenAdminToken.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessTokenAdminToken.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_id: str):
        pulumi.set(__self__, "instance_id", instance_id)

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> str:
        return pulumi.get(self, "instance_id")


@pulumi.output_type
class ArtifactPropertyWebhookCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyLocal":
            suggest = "any_local"
        elif key == "anyRemote":
            suggest = "any_remote"
        elif key == "repoKeys":
            suggest = "repo_keys"
        elif key == "excludePatterns":
            suggest = "exclude_patterns"
        elif key == "includePatterns":
            suggest = "include_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ArtifactPropertyWebhookCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ArtifactPropertyWebhookCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ArtifactPropertyWebhookCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_local: bool,
                 any_remote: bool,
                 repo_keys: Sequence[str],
                 exclude_patterns: Optional[Sequence[str]] = None,
                 include_patterns: Optional[Sequence[str]] = None):
        """
        :param bool any_local: Trigger on any local repo.
        :param bool any_remote: Trigger on any remote repo.
        :param Sequence[str] repo_keys: Trigger on this list of repo keys.
        :param Sequence[str] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash).\\n Ant-style path expressions are supported (*, *\\*, ?).\\nFor example: "org/apache/**".
        :param Sequence[str] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash).\\n Ant-style path expressions are supported (*, *\\*, ?).\\nFor example: "org/apache/**".
        """
        pulumi.set(__self__, "any_local", any_local)
        pulumi.set(__self__, "any_remote", any_remote)
        pulumi.set(__self__, "repo_keys", repo_keys)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @property
    @pulumi.getter(name="anyLocal")
    def any_local(self) -> bool:
        """
        Trigger on any local repo.
        """
        return pulumi.get(self, "any_local")

    @property
    @pulumi.getter(name="anyRemote")
    def any_remote(self) -> bool:
        """
        Trigger on any remote repo.
        """
        return pulumi.get(self, "any_remote")

    @property
    @pulumi.getter(name="repoKeys")
    def repo_keys(self) -> Sequence[str]:
        """
        Trigger on this list of repo keys.
        """
        return pulumi.get(self, "repo_keys")

    @property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[Sequence[str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash).\\n Ant-style path expressions are supported (*, *\\*, ?).\\nFor example: "org/apache/**".
        """
        return pulumi.get(self, "exclude_patterns")

    @property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[Sequence[str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash).\\n Ant-style path expressions are supported (*, *\\*, ?).\\nFor example: "org/apache/**".
        """
        return pulumi.get(self, "include_patterns")


@pulumi.output_type
class ArtifactPropertyWebhookHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customHttpHeaders":
            suggest = "custom_http_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ArtifactPropertyWebhookHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ArtifactPropertyWebhookHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ArtifactPropertyWebhookHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: str,
                 custom_http_headers: Optional[Mapping[str, str]] = None,
                 proxy: Optional[str] = None,
                 secret: Optional[str] = None):
        """
        :param str url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param Mapping[str, str] custom_http_headers: Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        :param str proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param str secret: Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        pulumi.set(__self__, "url", url)
        if custom_http_headers is not None:
            pulumi.set(__self__, "custom_http_headers", custom_http_headers)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="customHttpHeaders")
    def custom_http_headers(self) -> Optional[Mapping[str, str]]:
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        return pulumi.get(self, "custom_http_headers")

    @property
    @pulumi.getter
    def proxy(self) -> Optional[str]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @property
    @pulumi.getter
    def secret(self) -> Optional[str]:
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class ArtifactWebhookCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyLocal":
            suggest = "any_local"
        elif key == "anyRemote":
            suggest = "any_remote"
        elif key == "repoKeys":
            suggest = "repo_keys"
        elif key == "excludePatterns":
            suggest = "exclude_patterns"
        elif key == "includePatterns":
            suggest = "include_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ArtifactWebhookCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ArtifactWebhookCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ArtifactWebhookCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_local: bool,
                 any_remote: bool,
                 repo_keys: Sequence[str],
                 exclude_patterns: Optional[Sequence[str]] = None,
                 include_patterns: Optional[Sequence[str]] = None):
        """
        :param bool any_local: Trigger on any local repo.
        :param bool any_remote: Trigger on any remote repo.
        :param Sequence[str] repo_keys: Trigger on this list of repo keys.
        :param Sequence[str] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash).\\n Ant-style path expressions are supported (*, *\\*, ?).\\nFor example: "org/apache/**".
        :param Sequence[str] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash).\\n Ant-style path expressions are supported (*, *\\*, ?).\\nFor example: "org/apache/**".
        """
        pulumi.set(__self__, "any_local", any_local)
        pulumi.set(__self__, "any_remote", any_remote)
        pulumi.set(__self__, "repo_keys", repo_keys)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @property
    @pulumi.getter(name="anyLocal")
    def any_local(self) -> bool:
        """
        Trigger on any local repo.
        """
        return pulumi.get(self, "any_local")

    @property
    @pulumi.getter(name="anyRemote")
    def any_remote(self) -> bool:
        """
        Trigger on any remote repo.
        """
        return pulumi.get(self, "any_remote")

    @property
    @pulumi.getter(name="repoKeys")
    def repo_keys(self) -> Sequence[str]:
        """
        Trigger on this list of repo keys.
        """
        return pulumi.get(self, "repo_keys")

    @property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[Sequence[str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash).\\n Ant-style path expressions are supported (*, *\\*, ?).\\nFor example: "org/apache/**".
        """
        return pulumi.get(self, "exclude_patterns")

    @property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[Sequence[str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash).\\n Ant-style path expressions are supported (*, *\\*, ?).\\nFor example: "org/apache/**".
        """
        return pulumi.get(self, "include_patterns")


@pulumi.output_type
class ArtifactWebhookHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customHttpHeaders":
            suggest = "custom_http_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ArtifactWebhookHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ArtifactWebhookHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ArtifactWebhookHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: str,
                 custom_http_headers: Optional[Mapping[str, str]] = None,
                 proxy: Optional[str] = None,
                 secret: Optional[str] = None):
        """
        :param str url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param Mapping[str, str] custom_http_headers: Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        :param str proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param str secret: Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        pulumi.set(__self__, "url", url)
        if custom_http_headers is not None:
            pulumi.set(__self__, "custom_http_headers", custom_http_headers)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="customHttpHeaders")
    def custom_http_headers(self) -> Optional[Mapping[str, str]]:
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        return pulumi.get(self, "custom_http_headers")

    @property
    @pulumi.getter
    def proxy(self) -> Optional[str]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @property
    @pulumi.getter
    def secret(self) -> Optional[str]:
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class ArtifactoryReleaseBundleWebhookCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyReleaseBundle":
            suggest = "any_release_bundle"
        elif key == "registeredReleaseBundleNames":
            suggest = "registered_release_bundle_names"
        elif key == "excludePatterns":
            suggest = "exclude_patterns"
        elif key == "includePatterns":
            suggest = "include_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ArtifactoryReleaseBundleWebhookCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ArtifactoryReleaseBundleWebhookCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ArtifactoryReleaseBundleWebhookCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_release_bundle: bool,
                 registered_release_bundle_names: Sequence[str],
                 exclude_patterns: Optional[Sequence[str]] = None,
                 include_patterns: Optional[Sequence[str]] = None):
        """
        :param bool any_release_bundle: Trigger on any release bundle
        :param Sequence[str] registered_release_bundle_names: Trigger on this list of release bundle names
        :param Sequence[str] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash).\\n Ant-style path expressions are supported (*, *\\*, ?).\\nFor example: "org/apache/**"
        :param Sequence[str] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash).\\n Ant-style path expressions are supported (*, *\\*, ?).\\nFor example: "org/apache/**"
        """
        pulumi.set(__self__, "any_release_bundle", any_release_bundle)
        pulumi.set(__self__, "registered_release_bundle_names", registered_release_bundle_names)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @property
    @pulumi.getter(name="anyReleaseBundle")
    def any_release_bundle(self) -> bool:
        """
        Trigger on any release bundle
        """
        return pulumi.get(self, "any_release_bundle")

    @property
    @pulumi.getter(name="registeredReleaseBundleNames")
    def registered_release_bundle_names(self) -> Sequence[str]:
        """
        Trigger on this list of release bundle names
        """
        return pulumi.get(self, "registered_release_bundle_names")

    @property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[Sequence[str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash).\\n Ant-style path expressions are supported (*, *\\*, ?).\\nFor example: "org/apache/**"
        """
        return pulumi.get(self, "exclude_patterns")

    @property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[Sequence[str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash).\\n Ant-style path expressions are supported (*, *\\*, ?).\\nFor example: "org/apache/**"
        """
        return pulumi.get(self, "include_patterns")


@pulumi.output_type
class ArtifactoryReleaseBundleWebhookHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customHttpHeaders":
            suggest = "custom_http_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ArtifactoryReleaseBundleWebhookHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ArtifactoryReleaseBundleWebhookHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ArtifactoryReleaseBundleWebhookHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: str,
                 custom_http_headers: Optional[Mapping[str, str]] = None,
                 proxy: Optional[str] = None,
                 secret: Optional[str] = None):
        """
        :param str url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param Mapping[str, str] custom_http_headers: Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        :param str proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param str secret: Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        pulumi.set(__self__, "url", url)
        if custom_http_headers is not None:
            pulumi.set(__self__, "custom_http_headers", custom_http_headers)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="customHttpHeaders")
    def custom_http_headers(self) -> Optional[Mapping[str, str]]:
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        return pulumi.get(self, "custom_http_headers")

    @property
    @pulumi.getter
    def proxy(self) -> Optional[str]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @property
    @pulumi.getter
    def secret(self) -> Optional[str]:
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class BuildWebhookCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyBuild":
            suggest = "any_build"
        elif key == "selectedBuilds":
            suggest = "selected_builds"
        elif key == "excludePatterns":
            suggest = "exclude_patterns"
        elif key == "includePatterns":
            suggest = "include_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BuildWebhookCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BuildWebhookCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BuildWebhookCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_build: bool,
                 selected_builds: Sequence[str],
                 exclude_patterns: Optional[Sequence[str]] = None,
                 include_patterns: Optional[Sequence[str]] = None):
        """
        :param bool any_build: Trigger on any build.
        :param Sequence[str] selected_builds: Trigger on this list of build names.
        :param Sequence[str] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash).\\n Ant-style path expressions are supported (*, *\\*, ?).\\nFor example: "org/apache/**".
        :param Sequence[str] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash).\\n Ant-style path expressions are supported (*, *\\*, ?).\\nFor example: "org/apache/**".
        """
        pulumi.set(__self__, "any_build", any_build)
        pulumi.set(__self__, "selected_builds", selected_builds)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @property
    @pulumi.getter(name="anyBuild")
    def any_build(self) -> bool:
        """
        Trigger on any build.
        """
        return pulumi.get(self, "any_build")

    @property
    @pulumi.getter(name="selectedBuilds")
    def selected_builds(self) -> Sequence[str]:
        """
        Trigger on this list of build names.
        """
        return pulumi.get(self, "selected_builds")

    @property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[Sequence[str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash).\\n Ant-style path expressions are supported (*, *\\*, ?).\\nFor example: "org/apache/**".
        """
        return pulumi.get(self, "exclude_patterns")

    @property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[Sequence[str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash).\\n Ant-style path expressions are supported (*, *\\*, ?).\\nFor example: "org/apache/**".
        """
        return pulumi.get(self, "include_patterns")


@pulumi.output_type
class BuildWebhookHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customHttpHeaders":
            suggest = "custom_http_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BuildWebhookHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BuildWebhookHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BuildWebhookHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: str,
                 custom_http_headers: Optional[Mapping[str, str]] = None,
                 proxy: Optional[str] = None,
                 secret: Optional[str] = None):
        """
        :param str url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param Mapping[str, str] custom_http_headers: Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        :param str proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param str secret: Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        pulumi.set(__self__, "url", url)
        if custom_http_headers is not None:
            pulumi.set(__self__, "custom_http_headers", custom_http_headers)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="customHttpHeaders")
    def custom_http_headers(self) -> Optional[Mapping[str, str]]:
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        return pulumi.get(self, "custom_http_headers")

    @property
    @pulumi.getter
    def proxy(self) -> Optional[str]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @property
    @pulumi.getter
    def secret(self) -> Optional[str]:
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class DistributionWebhookCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyReleaseBundle":
            suggest = "any_release_bundle"
        elif key == "registeredReleaseBundleNames":
            suggest = "registered_release_bundle_names"
        elif key == "excludePatterns":
            suggest = "exclude_patterns"
        elif key == "includePatterns":
            suggest = "include_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DistributionWebhookCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DistributionWebhookCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DistributionWebhookCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_release_bundle: bool,
                 registered_release_bundle_names: Sequence[str],
                 exclude_patterns: Optional[Sequence[str]] = None,
                 include_patterns: Optional[Sequence[str]] = None):
        """
        :param bool any_release_bundle: Trigger on any release bundle.
        :param Sequence[str] registered_release_bundle_names: Trigger on this list of release bundle names.
        :param Sequence[str] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash).\\n Ant-style path expressions are supported (*, *\\*, ?).\\nFor example: "org/apache/**".
        :param Sequence[str] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash).\\n Ant-style path expressions are supported (*, *\\*, ?).\\nFor example: "org/apache/**".
        """
        pulumi.set(__self__, "any_release_bundle", any_release_bundle)
        pulumi.set(__self__, "registered_release_bundle_names", registered_release_bundle_names)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @property
    @pulumi.getter(name="anyReleaseBundle")
    def any_release_bundle(self) -> bool:
        """
        Trigger on any release bundle.
        """
        return pulumi.get(self, "any_release_bundle")

    @property
    @pulumi.getter(name="registeredReleaseBundleNames")
    def registered_release_bundle_names(self) -> Sequence[str]:
        """
        Trigger on this list of release bundle names.
        """
        return pulumi.get(self, "registered_release_bundle_names")

    @property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[Sequence[str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash).\\n Ant-style path expressions are supported (*, *\\*, ?).\\nFor example: "org/apache/**".
        """
        return pulumi.get(self, "exclude_patterns")

    @property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[Sequence[str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash).\\n Ant-style path expressions are supported (*, *\\*, ?).\\nFor example: "org/apache/**".
        """
        return pulumi.get(self, "include_patterns")


@pulumi.output_type
class DistributionWebhookHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customHttpHeaders":
            suggest = "custom_http_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DistributionWebhookHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DistributionWebhookHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DistributionWebhookHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: str,
                 custom_http_headers: Optional[Mapping[str, str]] = None,
                 proxy: Optional[str] = None,
                 secret: Optional[str] = None):
        """
        :param str url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param Mapping[str, str] custom_http_headers: Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        :param str proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param str secret: Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        pulumi.set(__self__, "url", url)
        if custom_http_headers is not None:
            pulumi.set(__self__, "custom_http_headers", custom_http_headers)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="customHttpHeaders")
    def custom_http_headers(self) -> Optional[Mapping[str, str]]:
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        return pulumi.get(self, "custom_http_headers")

    @property
    @pulumi.getter
    def proxy(self) -> Optional[str]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @property
    @pulumi.getter
    def secret(self) -> Optional[str]:
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class DockerWebhookCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyLocal":
            suggest = "any_local"
        elif key == "anyRemote":
            suggest = "any_remote"
        elif key == "repoKeys":
            suggest = "repo_keys"
        elif key == "excludePatterns":
            suggest = "exclude_patterns"
        elif key == "includePatterns":
            suggest = "include_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DockerWebhookCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DockerWebhookCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DockerWebhookCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_local: bool,
                 any_remote: bool,
                 repo_keys: Sequence[str],
                 exclude_patterns: Optional[Sequence[str]] = None,
                 include_patterns: Optional[Sequence[str]] = None):
        """
        :param bool any_local: Trigger on any local repo.
        :param bool any_remote: Trigger on any remote repo.
        :param Sequence[str] repo_keys: Trigger on this list of repo keys.
        :param Sequence[str] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash).\\n Ant-style path expressions are supported (*, *\\*, ?).\\nFor example: "org/apache/**".
        :param Sequence[str] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash).\\n Ant-style path expressions are supported (*, *\\*, ?).\\nFor example: "org/apache/**".
        """
        pulumi.set(__self__, "any_local", any_local)
        pulumi.set(__self__, "any_remote", any_remote)
        pulumi.set(__self__, "repo_keys", repo_keys)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @property
    @pulumi.getter(name="anyLocal")
    def any_local(self) -> bool:
        """
        Trigger on any local repo.
        """
        return pulumi.get(self, "any_local")

    @property
    @pulumi.getter(name="anyRemote")
    def any_remote(self) -> bool:
        """
        Trigger on any remote repo.
        """
        return pulumi.get(self, "any_remote")

    @property
    @pulumi.getter(name="repoKeys")
    def repo_keys(self) -> Sequence[str]:
        """
        Trigger on this list of repo keys.
        """
        return pulumi.get(self, "repo_keys")

    @property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[Sequence[str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash).\\n Ant-style path expressions are supported (*, *\\*, ?).\\nFor example: "org/apache/**".
        """
        return pulumi.get(self, "exclude_patterns")

    @property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[Sequence[str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash).\\n Ant-style path expressions are supported (*, *\\*, ?).\\nFor example: "org/apache/**".
        """
        return pulumi.get(self, "include_patterns")


@pulumi.output_type
class DockerWebhookHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customHttpHeaders":
            suggest = "custom_http_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DockerWebhookHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DockerWebhookHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DockerWebhookHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: str,
                 custom_http_headers: Optional[Mapping[str, str]] = None,
                 proxy: Optional[str] = None,
                 secret: Optional[str] = None):
        """
        :param str url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param Mapping[str, str] custom_http_headers: Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        :param str proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param str secret: Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        pulumi.set(__self__, "url", url)
        if custom_http_headers is not None:
            pulumi.set(__self__, "custom_http_headers", custom_http_headers)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="customHttpHeaders")
    def custom_http_headers(self) -> Optional[Mapping[str, str]]:
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        return pulumi.get(self, "custom_http_headers")

    @property
    @pulumi.getter
    def proxy(self) -> Optional[str]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @property
    @pulumi.getter
    def secret(self) -> Optional[str]:
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class FederatedAlpineRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedBowerRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedCargoRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedChefRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedCocoapodsRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedComposerRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedConanRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedCondaRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedCranRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedDebianRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedDockerRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedDockerV1RepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedDockerV2RepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedGemsRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedGenericRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedGitltfsRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedGoRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedGradleRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedHelmRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedIvyRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedMavenRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedNpmRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedNugetRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedOpkgRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedPuppetRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedPypiRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedRpmRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedSbtRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedSwiftRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedTerraformModuleRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedTerraformProviderRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class FederatedVagrantRepositoryMember(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class OauthSettingsOauthProvider(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiUrl":
            suggest = "api_url"
        elif key == "authUrl":
            suggest = "auth_url"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "tokenUrl":
            suggest = "token_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OauthSettingsOauthProvider. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OauthSettingsOauthProvider.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OauthSettingsOauthProvider.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_url: str,
                 auth_url: str,
                 client_id: str,
                 client_secret: str,
                 name: str,
                 token_url: str,
                 type: str,
                 enabled: Optional[bool] = None):
        """
        :param str api_url: OAuth user info endpoint for the IdP.
        :param str auth_url: OAuth authorization endpoint for the IdP.
        :param str client_id: OAuth client ID configured on the IdP.
        :param str client_secret: OAuth client secret configured on the IdP.
        :param str name: Name of the Artifactory OAuth provider.
        :param str token_url: OAuth token endpoint for the IdP.
        :param str type: Type of OAuth provider. (e.g., `github`, `google`, `cloudfoundry`, or `openId`)
        :param bool enabled: Enable the Artifactory OAuth provider.  Default value is `true`.
        """
        pulumi.set(__self__, "api_url", api_url)
        pulumi.set(__self__, "auth_url", auth_url)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "token_url", token_url)
        pulumi.set(__self__, "type", type)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="apiUrl")
    def api_url(self) -> str:
        """
        OAuth user info endpoint for the IdP.
        """
        return pulumi.get(self, "api_url")

    @property
    @pulumi.getter(name="authUrl")
    def auth_url(self) -> str:
        """
        OAuth authorization endpoint for the IdP.
        """
        return pulumi.get(self, "auth_url")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        OAuth client ID configured on the IdP.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        OAuth client secret configured on the IdP.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the Artifactory OAuth provider.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="tokenUrl")
    def token_url(self) -> str:
        """
        OAuth token endpoint for the IdP.
        """
        return pulumi.get(self, "token_url")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of OAuth provider. (e.g., `github`, `google`, `cloudfoundry`, or `openId`)
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Enable the Artifactory OAuth provider.  Default value is `true`.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class PermissionTargetBuild(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludesPatterns":
            suggest = "excludes_patterns"
        elif key == "includesPatterns":
            suggest = "includes_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PermissionTargetBuild. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PermissionTargetBuild.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PermissionTargetBuild.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 repositories: Sequence[str],
                 actions: Optional['outputs.PermissionTargetBuildActions'] = None,
                 excludes_patterns: Optional[Sequence[str]] = None,
                 includes_patterns: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] repositories: List of repositories this permission target is applicable for. You can specify the name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        :param Sequence[str] excludes_patterns: Pattern of artifacts to exclude.
        :param Sequence[str] includes_patterns: Pattern of artifacts to include.
        """
        pulumi.set(__self__, "repositories", repositories)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if excludes_patterns is not None:
            pulumi.set(__self__, "excludes_patterns", excludes_patterns)
        if includes_patterns is not None:
            pulumi.set(__self__, "includes_patterns", includes_patterns)

    @property
    @pulumi.getter
    def repositories(self) -> Sequence[str]:
        """
        List of repositories this permission target is applicable for. You can specify the name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        """
        return pulumi.get(self, "repositories")

    @property
    @pulumi.getter
    def actions(self) -> Optional['outputs.PermissionTargetBuildActions']:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="excludesPatterns")
    def excludes_patterns(self) -> Optional[Sequence[str]]:
        """
        Pattern of artifacts to exclude.
        """
        return pulumi.get(self, "excludes_patterns")

    @property
    @pulumi.getter(name="includesPatterns")
    def includes_patterns(self) -> Optional[Sequence[str]]:
        """
        Pattern of artifacts to include.
        """
        return pulumi.get(self, "includes_patterns")


@pulumi.output_type
class PermissionTargetBuildActions(dict):
    def __init__(__self__, *,
                 groups: Optional[Sequence['outputs.PermissionTargetBuildActionsGroup']] = None,
                 users: Optional[Sequence['outputs.PermissionTargetBuildActionsUser']] = None):
        """
        :param Sequence['PermissionTargetBuildActionsGroupArgs'] groups: Groups this permission applies for.
        :param Sequence['PermissionTargetBuildActionsUserArgs'] users: Users this permission target applies for.
        """
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence['outputs.PermissionTargetBuildActionsGroup']]:
        """
        Groups this permission applies for.
        """
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def users(self) -> Optional[Sequence['outputs.PermissionTargetBuildActionsUser']]:
        """
        Users this permission target applies for.
        """
        return pulumi.get(self, "users")


@pulumi.output_type
class PermissionTargetBuildActionsGroup(dict):
    def __init__(__self__, *,
                 name: str,
                 permissions: Sequence[str]):
        """
        :param str name: Name of permission.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of permission.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def permissions(self) -> Sequence[str]:
        return pulumi.get(self, "permissions")


@pulumi.output_type
class PermissionTargetBuildActionsUser(dict):
    def __init__(__self__, *,
                 name: str,
                 permissions: Sequence[str]):
        """
        :param str name: Name of permission.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of permission.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def permissions(self) -> Sequence[str]:
        return pulumi.get(self, "permissions")


@pulumi.output_type
class PermissionTargetReleaseBundle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludesPatterns":
            suggest = "excludes_patterns"
        elif key == "includesPatterns":
            suggest = "includes_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PermissionTargetReleaseBundle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PermissionTargetReleaseBundle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PermissionTargetReleaseBundle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 repositories: Sequence[str],
                 actions: Optional['outputs.PermissionTargetReleaseBundleActions'] = None,
                 excludes_patterns: Optional[Sequence[str]] = None,
                 includes_patterns: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] repositories: List of repositories this permission target is applicable for. You can specify the name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        :param Sequence[str] excludes_patterns: Pattern of artifacts to exclude.
        :param Sequence[str] includes_patterns: Pattern of artifacts to include.
        """
        pulumi.set(__self__, "repositories", repositories)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if excludes_patterns is not None:
            pulumi.set(__self__, "excludes_patterns", excludes_patterns)
        if includes_patterns is not None:
            pulumi.set(__self__, "includes_patterns", includes_patterns)

    @property
    @pulumi.getter
    def repositories(self) -> Sequence[str]:
        """
        List of repositories this permission target is applicable for. You can specify the name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        """
        return pulumi.get(self, "repositories")

    @property
    @pulumi.getter
    def actions(self) -> Optional['outputs.PermissionTargetReleaseBundleActions']:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="excludesPatterns")
    def excludes_patterns(self) -> Optional[Sequence[str]]:
        """
        Pattern of artifacts to exclude.
        """
        return pulumi.get(self, "excludes_patterns")

    @property
    @pulumi.getter(name="includesPatterns")
    def includes_patterns(self) -> Optional[Sequence[str]]:
        """
        Pattern of artifacts to include.
        """
        return pulumi.get(self, "includes_patterns")


@pulumi.output_type
class PermissionTargetReleaseBundleActions(dict):
    def __init__(__self__, *,
                 groups: Optional[Sequence['outputs.PermissionTargetReleaseBundleActionsGroup']] = None,
                 users: Optional[Sequence['outputs.PermissionTargetReleaseBundleActionsUser']] = None):
        """
        :param Sequence['PermissionTargetReleaseBundleActionsGroupArgs'] groups: Groups this permission applies for.
        :param Sequence['PermissionTargetReleaseBundleActionsUserArgs'] users: Users this permission target applies for.
        """
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence['outputs.PermissionTargetReleaseBundleActionsGroup']]:
        """
        Groups this permission applies for.
        """
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def users(self) -> Optional[Sequence['outputs.PermissionTargetReleaseBundleActionsUser']]:
        """
        Users this permission target applies for.
        """
        return pulumi.get(self, "users")


@pulumi.output_type
class PermissionTargetReleaseBundleActionsGroup(dict):
    def __init__(__self__, *,
                 name: str,
                 permissions: Sequence[str]):
        """
        :param str name: Name of permission.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of permission.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def permissions(self) -> Sequence[str]:
        return pulumi.get(self, "permissions")


@pulumi.output_type
class PermissionTargetReleaseBundleActionsUser(dict):
    def __init__(__self__, *,
                 name: str,
                 permissions: Sequence[str]):
        """
        :param str name: Name of permission.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of permission.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def permissions(self) -> Sequence[str]:
        return pulumi.get(self, "permissions")


@pulumi.output_type
class PermissionTargetRepo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludesPatterns":
            suggest = "excludes_patterns"
        elif key == "includesPatterns":
            suggest = "includes_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PermissionTargetRepo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PermissionTargetRepo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PermissionTargetRepo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 repositories: Sequence[str],
                 actions: Optional['outputs.PermissionTargetRepoActions'] = None,
                 excludes_patterns: Optional[Sequence[str]] = None,
                 includes_patterns: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] repositories: List of repositories this permission target is applicable for. You can specify the name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        :param Sequence[str] excludes_patterns: Pattern of artifacts to exclude.
        :param Sequence[str] includes_patterns: Pattern of artifacts to include.
        """
        pulumi.set(__self__, "repositories", repositories)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if excludes_patterns is not None:
            pulumi.set(__self__, "excludes_patterns", excludes_patterns)
        if includes_patterns is not None:
            pulumi.set(__self__, "includes_patterns", includes_patterns)

    @property
    @pulumi.getter
    def repositories(self) -> Sequence[str]:
        """
        List of repositories this permission target is applicable for. You can specify the name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        """
        return pulumi.get(self, "repositories")

    @property
    @pulumi.getter
    def actions(self) -> Optional['outputs.PermissionTargetRepoActions']:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="excludesPatterns")
    def excludes_patterns(self) -> Optional[Sequence[str]]:
        """
        Pattern of artifacts to exclude.
        """
        return pulumi.get(self, "excludes_patterns")

    @property
    @pulumi.getter(name="includesPatterns")
    def includes_patterns(self) -> Optional[Sequence[str]]:
        """
        Pattern of artifacts to include.
        """
        return pulumi.get(self, "includes_patterns")


@pulumi.output_type
class PermissionTargetRepoActions(dict):
    def __init__(__self__, *,
                 groups: Optional[Sequence['outputs.PermissionTargetRepoActionsGroup']] = None,
                 users: Optional[Sequence['outputs.PermissionTargetRepoActionsUser']] = None):
        """
        :param Sequence['PermissionTargetRepoActionsGroupArgs'] groups: Groups this permission applies for.
        :param Sequence['PermissionTargetRepoActionsUserArgs'] users: Users this permission target applies for.
        """
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence['outputs.PermissionTargetRepoActionsGroup']]:
        """
        Groups this permission applies for.
        """
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def users(self) -> Optional[Sequence['outputs.PermissionTargetRepoActionsUser']]:
        """
        Users this permission target applies for.
        """
        return pulumi.get(self, "users")


@pulumi.output_type
class PermissionTargetRepoActionsGroup(dict):
    def __init__(__self__, *,
                 name: str,
                 permissions: Sequence[str]):
        """
        :param str name: Name of permission.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of permission.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def permissions(self) -> Sequence[str]:
        return pulumi.get(self, "permissions")


@pulumi.output_type
class PermissionTargetRepoActionsUser(dict):
    def __init__(__self__, *,
                 name: str,
                 permissions: Sequence[str]):
        """
        :param str name: Name of permission.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of permission.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def permissions(self) -> Sequence[str]:
        return pulumi.get(self, "permissions")


@pulumi.output_type
class PermissionTargetsBuild(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludesPatterns":
            suggest = "excludes_patterns"
        elif key == "includesPatterns":
            suggest = "includes_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PermissionTargetsBuild. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PermissionTargetsBuild.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PermissionTargetsBuild.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 repositories: Sequence[str],
                 actions: Optional['outputs.PermissionTargetsBuildActions'] = None,
                 excludes_patterns: Optional[Sequence[str]] = None,
                 includes_patterns: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] repositories: List of repositories this permission target is applicable for. You can specify the name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        :param Sequence[str] excludes_patterns: Pattern of artifacts to exclude.
        :param Sequence[str] includes_patterns: Pattern of artifacts to include.
        """
        pulumi.set(__self__, "repositories", repositories)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if excludes_patterns is not None:
            pulumi.set(__self__, "excludes_patterns", excludes_patterns)
        if includes_patterns is not None:
            pulumi.set(__self__, "includes_patterns", includes_patterns)

    @property
    @pulumi.getter
    def repositories(self) -> Sequence[str]:
        """
        List of repositories this permission target is applicable for. You can specify the name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        """
        return pulumi.get(self, "repositories")

    @property
    @pulumi.getter
    def actions(self) -> Optional['outputs.PermissionTargetsBuildActions']:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="excludesPatterns")
    def excludes_patterns(self) -> Optional[Sequence[str]]:
        """
        Pattern of artifacts to exclude.
        """
        return pulumi.get(self, "excludes_patterns")

    @property
    @pulumi.getter(name="includesPatterns")
    def includes_patterns(self) -> Optional[Sequence[str]]:
        """
        Pattern of artifacts to include.
        """
        return pulumi.get(self, "includes_patterns")


@pulumi.output_type
class PermissionTargetsBuildActions(dict):
    def __init__(__self__, *,
                 groups: Optional[Sequence['outputs.PermissionTargetsBuildActionsGroup']] = None,
                 users: Optional[Sequence['outputs.PermissionTargetsBuildActionsUser']] = None):
        """
        :param Sequence['PermissionTargetsBuildActionsGroupArgs'] groups: Groups this permission applies for.
        :param Sequence['PermissionTargetsBuildActionsUserArgs'] users: Users this permission target applies for.
        """
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence['outputs.PermissionTargetsBuildActionsGroup']]:
        """
        Groups this permission applies for.
        """
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def users(self) -> Optional[Sequence['outputs.PermissionTargetsBuildActionsUser']]:
        """
        Users this permission target applies for.
        """
        return pulumi.get(self, "users")


@pulumi.output_type
class PermissionTargetsBuildActionsGroup(dict):
    def __init__(__self__, *,
                 name: str,
                 permissions: Sequence[str]):
        """
        :param str name: Name of permission.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of permission.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def permissions(self) -> Sequence[str]:
        return pulumi.get(self, "permissions")


@pulumi.output_type
class PermissionTargetsBuildActionsUser(dict):
    def __init__(__self__, *,
                 name: str,
                 permissions: Sequence[str]):
        """
        :param str name: Name of permission.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of permission.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def permissions(self) -> Sequence[str]:
        return pulumi.get(self, "permissions")


@pulumi.output_type
class PermissionTargetsReleaseBundle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludesPatterns":
            suggest = "excludes_patterns"
        elif key == "includesPatterns":
            suggest = "includes_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PermissionTargetsReleaseBundle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PermissionTargetsReleaseBundle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PermissionTargetsReleaseBundle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 repositories: Sequence[str],
                 actions: Optional['outputs.PermissionTargetsReleaseBundleActions'] = None,
                 excludes_patterns: Optional[Sequence[str]] = None,
                 includes_patterns: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] repositories: List of repositories this permission target is applicable for. You can specify the name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        :param Sequence[str] excludes_patterns: Pattern of artifacts to exclude.
        :param Sequence[str] includes_patterns: Pattern of artifacts to include.
        """
        pulumi.set(__self__, "repositories", repositories)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if excludes_patterns is not None:
            pulumi.set(__self__, "excludes_patterns", excludes_patterns)
        if includes_patterns is not None:
            pulumi.set(__self__, "includes_patterns", includes_patterns)

    @property
    @pulumi.getter
    def repositories(self) -> Sequence[str]:
        """
        List of repositories this permission target is applicable for. You can specify the name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        """
        return pulumi.get(self, "repositories")

    @property
    @pulumi.getter
    def actions(self) -> Optional['outputs.PermissionTargetsReleaseBundleActions']:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="excludesPatterns")
    def excludes_patterns(self) -> Optional[Sequence[str]]:
        """
        Pattern of artifacts to exclude.
        """
        return pulumi.get(self, "excludes_patterns")

    @property
    @pulumi.getter(name="includesPatterns")
    def includes_patterns(self) -> Optional[Sequence[str]]:
        """
        Pattern of artifacts to include.
        """
        return pulumi.get(self, "includes_patterns")


@pulumi.output_type
class PermissionTargetsReleaseBundleActions(dict):
    def __init__(__self__, *,
                 groups: Optional[Sequence['outputs.PermissionTargetsReleaseBundleActionsGroup']] = None,
                 users: Optional[Sequence['outputs.PermissionTargetsReleaseBundleActionsUser']] = None):
        """
        :param Sequence['PermissionTargetsReleaseBundleActionsGroupArgs'] groups: Groups this permission applies for.
        :param Sequence['PermissionTargetsReleaseBundleActionsUserArgs'] users: Users this permission target applies for.
        """
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence['outputs.PermissionTargetsReleaseBundleActionsGroup']]:
        """
        Groups this permission applies for.
        """
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def users(self) -> Optional[Sequence['outputs.PermissionTargetsReleaseBundleActionsUser']]:
        """
        Users this permission target applies for.
        """
        return pulumi.get(self, "users")


@pulumi.output_type
class PermissionTargetsReleaseBundleActionsGroup(dict):
    def __init__(__self__, *,
                 name: str,
                 permissions: Sequence[str]):
        """
        :param str name: Name of permission.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of permission.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def permissions(self) -> Sequence[str]:
        return pulumi.get(self, "permissions")


@pulumi.output_type
class PermissionTargetsReleaseBundleActionsUser(dict):
    def __init__(__self__, *,
                 name: str,
                 permissions: Sequence[str]):
        """
        :param str name: Name of permission.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of permission.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def permissions(self) -> Sequence[str]:
        return pulumi.get(self, "permissions")


@pulumi.output_type
class PermissionTargetsRepo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludesPatterns":
            suggest = "excludes_patterns"
        elif key == "includesPatterns":
            suggest = "includes_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PermissionTargetsRepo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PermissionTargetsRepo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PermissionTargetsRepo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 repositories: Sequence[str],
                 actions: Optional['outputs.PermissionTargetsRepoActions'] = None,
                 excludes_patterns: Optional[Sequence[str]] = None,
                 includes_patterns: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] repositories: List of repositories this permission target is applicable for. You can specify the name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        :param Sequence[str] excludes_patterns: Pattern of artifacts to exclude.
        :param Sequence[str] includes_patterns: Pattern of artifacts to include.
        """
        pulumi.set(__self__, "repositories", repositories)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if excludes_patterns is not None:
            pulumi.set(__self__, "excludes_patterns", excludes_patterns)
        if includes_patterns is not None:
            pulumi.set(__self__, "includes_patterns", includes_patterns)

    @property
    @pulumi.getter
    def repositories(self) -> Sequence[str]:
        """
        List of repositories this permission target is applicable for. You can specify the name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        """
        return pulumi.get(self, "repositories")

    @property
    @pulumi.getter
    def actions(self) -> Optional['outputs.PermissionTargetsRepoActions']:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="excludesPatterns")
    def excludes_patterns(self) -> Optional[Sequence[str]]:
        """
        Pattern of artifacts to exclude.
        """
        return pulumi.get(self, "excludes_patterns")

    @property
    @pulumi.getter(name="includesPatterns")
    def includes_patterns(self) -> Optional[Sequence[str]]:
        """
        Pattern of artifacts to include.
        """
        return pulumi.get(self, "includes_patterns")


@pulumi.output_type
class PermissionTargetsRepoActions(dict):
    def __init__(__self__, *,
                 groups: Optional[Sequence['outputs.PermissionTargetsRepoActionsGroup']] = None,
                 users: Optional[Sequence['outputs.PermissionTargetsRepoActionsUser']] = None):
        """
        :param Sequence['PermissionTargetsRepoActionsGroupArgs'] groups: Groups this permission applies for.
        :param Sequence['PermissionTargetsRepoActionsUserArgs'] users: Users this permission target applies for.
        """
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence['outputs.PermissionTargetsRepoActionsGroup']]:
        """
        Groups this permission applies for.
        """
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def users(self) -> Optional[Sequence['outputs.PermissionTargetsRepoActionsUser']]:
        """
        Users this permission target applies for.
        """
        return pulumi.get(self, "users")


@pulumi.output_type
class PermissionTargetsRepoActionsGroup(dict):
    def __init__(__self__, *,
                 name: str,
                 permissions: Sequence[str]):
        """
        :param str name: Name of permission.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of permission.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def permissions(self) -> Sequence[str]:
        return pulumi.get(self, "permissions")


@pulumi.output_type
class PermissionTargetsRepoActionsUser(dict):
    def __init__(__self__, *,
                 name: str,
                 permissions: Sequence[str]):
        """
        :param str name: Name of permission.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of permission.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def permissions(self) -> Sequence[str]:
        return pulumi.get(self, "permissions")


@pulumi.output_type
class PropertySetProperty(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "predefinedValues":
            suggest = "predefined_values"
        elif key == "closedPredefinedValues":
            suggest = "closed_predefined_values"
        elif key == "multipleChoice":
            suggest = "multiple_choice"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PropertySetProperty. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PropertySetProperty.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PropertySetProperty.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 predefined_values: Sequence['outputs.PropertySetPropertyPredefinedValue'],
                 closed_predefined_values: Optional[bool] = None,
                 multiple_choice: Optional[bool] = None):
        """
        :param str name: Predefined property name.
        :param Sequence['PropertySetPropertyPredefinedValueArgs'] predefined_values: Properties in the property set.
        :param bool closed_predefined_values: Disables "multiple_choice" if set to "false" at the same time with multiple_choice set to "true". Default value is `false`
        :param bool multiple_choice: Defines if user can select multiple values. "closed_predefined_values" should be set to `true`. Default value is `false`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "predefined_values", predefined_values)
        if closed_predefined_values is not None:
            pulumi.set(__self__, "closed_predefined_values", closed_predefined_values)
        if multiple_choice is not None:
            pulumi.set(__self__, "multiple_choice", multiple_choice)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Predefined property name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="predefinedValues")
    def predefined_values(self) -> Sequence['outputs.PropertySetPropertyPredefinedValue']:
        """
        Properties in the property set.
        """
        return pulumi.get(self, "predefined_values")

    @property
    @pulumi.getter(name="closedPredefinedValues")
    def closed_predefined_values(self) -> Optional[bool]:
        """
        Disables "multiple_choice" if set to "false" at the same time with multiple_choice set to "true". Default value is `false`
        """
        return pulumi.get(self, "closed_predefined_values")

    @property
    @pulumi.getter(name="multipleChoice")
    def multiple_choice(self) -> Optional[bool]:
        """
        Defines if user can select multiple values. "closed_predefined_values" should be set to `true`. Default value is `false`.
        """
        return pulumi.get(self, "multiple_choice")


@pulumi.output_type
class PropertySetPropertyPredefinedValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultValue":
            suggest = "default_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PropertySetPropertyPredefinedValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PropertySetPropertyPredefinedValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PropertySetPropertyPredefinedValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_value: bool,
                 name: str):
        """
        :param bool default_value: Whether the value is selected by default in the UI.
        :param str name: Predefined property name.
        """
        pulumi.set(__self__, "default_value", default_value)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> bool:
        """
        Whether the value is selected by default in the UI.
        """
        return pulumi.get(self, "default_value")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Predefined property name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class PushReplicationReplication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "checkBinaryExistenceInFilestore":
            suggest = "check_binary_existence_in_filestore"
        elif key == "pathPrefix":
            suggest = "path_prefix"
        elif key == "socketTimeoutMillis":
            suggest = "socket_timeout_millis"
        elif key == "syncDeletes":
            suggest = "sync_deletes"
        elif key == "syncProperties":
            suggest = "sync_properties"
        elif key == "syncStatistics":
            suggest = "sync_statistics"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PushReplicationReplication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PushReplicationReplication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PushReplicationReplication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 password: str,
                 url: str,
                 username: str,
                 check_binary_existence_in_filestore: Optional[bool] = None,
                 enabled: Optional[bool] = None,
                 path_prefix: Optional[str] = None,
                 proxy: Optional[str] = None,
                 socket_timeout_millis: Optional[int] = None,
                 sync_deletes: Optional[bool] = None,
                 sync_properties: Optional[bool] = None,
                 sync_statistics: Optional[bool] = None):
        """
        :param str password: Required for local repository, but not needed for remote repository.
        :param str url: The URL of the target local repository on a remote Artifactory server. Required for local repository, but not needed for remote repository.
        :param str username: Required for local repository, but not needed for remote repository.
        :param bool check_binary_existence_in_filestore: When true, enables distributed checksum storage. For more information, see
               [Optimizing Repository Replication with Checksum-Based Storage](https://www.jfrog.com/confluence/display/JFROG/Repository+Replication#RepositoryReplication-OptimizingRepositoryReplicationUsingStorageLevelSynchronizationOptions).
        :param bool enabled: When set, this replication will be enabled when saved.
        :param str path_prefix: Only artifacts that located in path that matches the subpath within the remote repository will be replicated.
        :param str proxy: Proxy key from Artifactory Proxies settings. The proxy configuration will be used when communicating with the remote instance.
        :param int socket_timeout_millis: The network timeout in milliseconds to use for remote operations.
        :param bool sync_deletes: When set, items that were deleted locally should also be deleted remotely (also applies to properties metadata).
               Note that enabling this option, will delete artifacts on the target that do not exist in the source repository.
        :param bool sync_properties: When set, the task also synchronizes the properties of replicated artifacts.
        :param bool sync_statistics: When set, artifact download statistics will also be replicated. Set to avoid inadvertent cleanup at the target instance when setting up replication for disaster recovery.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "url", url)
        pulumi.set(__self__, "username", username)
        if check_binary_existence_in_filestore is not None:
            pulumi.set(__self__, "check_binary_existence_in_filestore", check_binary_existence_in_filestore)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if path_prefix is not None:
            pulumi.set(__self__, "path_prefix", path_prefix)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if socket_timeout_millis is not None:
            pulumi.set(__self__, "socket_timeout_millis", socket_timeout_millis)
        if sync_deletes is not None:
            pulumi.set(__self__, "sync_deletes", sync_deletes)
        if sync_properties is not None:
            pulumi.set(__self__, "sync_properties", sync_properties)
        if sync_statistics is not None:
            pulumi.set(__self__, "sync_statistics", sync_statistics)

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        Required for local repository, but not needed for remote repository.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The URL of the target local repository on a remote Artifactory server. Required for local repository, but not needed for remote repository.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Required for local repository, but not needed for remote repository.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="checkBinaryExistenceInFilestore")
    def check_binary_existence_in_filestore(self) -> Optional[bool]:
        """
        When true, enables distributed checksum storage. For more information, see
        [Optimizing Repository Replication with Checksum-Based Storage](https://www.jfrog.com/confluence/display/JFROG/Repository+Replication#RepositoryReplication-OptimizingRepositoryReplicationUsingStorageLevelSynchronizationOptions).
        """
        return pulumi.get(self, "check_binary_existence_in_filestore")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        When set, this replication will be enabled when saved.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="pathPrefix")
    def path_prefix(self) -> Optional[str]:
        """
        Only artifacts that located in path that matches the subpath within the remote repository will be replicated.
        """
        return pulumi.get(self, "path_prefix")

    @property
    @pulumi.getter
    def proxy(self) -> Optional[str]:
        """
        Proxy key from Artifactory Proxies settings. The proxy configuration will be used when communicating with the remote instance.
        """
        return pulumi.get(self, "proxy")

    @property
    @pulumi.getter(name="socketTimeoutMillis")
    def socket_timeout_millis(self) -> Optional[int]:
        """
        The network timeout in milliseconds to use for remote operations.
        """
        return pulumi.get(self, "socket_timeout_millis")

    @property
    @pulumi.getter(name="syncDeletes")
    def sync_deletes(self) -> Optional[bool]:
        """
        When set, items that were deleted locally should also be deleted remotely (also applies to properties metadata).
        Note that enabling this option, will delete artifacts on the target that do not exist in the source repository.
        """
        return pulumi.get(self, "sync_deletes")

    @property
    @pulumi.getter(name="syncProperties")
    def sync_properties(self) -> Optional[bool]:
        """
        When set, the task also synchronizes the properties of replicated artifacts.
        """
        return pulumi.get(self, "sync_properties")

    @property
    @pulumi.getter(name="syncStatistics")
    def sync_statistics(self) -> Optional[bool]:
        """
        When set, artifact download statistics will also be replicated. Set to avoid inadvertent cleanup at the target instance when setting up replication for disaster recovery.
        """
        return pulumi.get(self, "sync_statistics")


@pulumi.output_type
class ReleaseBundleWebhookCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anyReleaseBundle":
            suggest = "any_release_bundle"
        elif key == "registeredReleaseBundleNames":
            suggest = "registered_release_bundle_names"
        elif key == "excludePatterns":
            suggest = "exclude_patterns"
        elif key == "includePatterns":
            suggest = "include_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReleaseBundleWebhookCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReleaseBundleWebhookCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReleaseBundleWebhookCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 any_release_bundle: bool,
                 registered_release_bundle_names: Sequence[str],
                 exclude_patterns: Optional[Sequence[str]] = None,
                 include_patterns: Optional[Sequence[str]] = None):
        """
        :param bool any_release_bundle: Trigger on any release bundle.
        :param Sequence[str] registered_release_bundle_names: Trigger on this list of release bundle names.
        :param Sequence[str] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash).\\n Ant-style path expressions are supported (*, *\\*, ?).\\nFor example: "org/apache/**".
        :param Sequence[str] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash).\\n Ant-style path expressions are supported (*, *\\*, ?).\\nFor example: "org/apache/**".
        """
        pulumi.set(__self__, "any_release_bundle", any_release_bundle)
        pulumi.set(__self__, "registered_release_bundle_names", registered_release_bundle_names)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @property
    @pulumi.getter(name="anyReleaseBundle")
    def any_release_bundle(self) -> bool:
        """
        Trigger on any release bundle.
        """
        return pulumi.get(self, "any_release_bundle")

    @property
    @pulumi.getter(name="registeredReleaseBundleNames")
    def registered_release_bundle_names(self) -> Sequence[str]:
        """
        Trigger on this list of release bundle names.
        """
        return pulumi.get(self, "registered_release_bundle_names")

    @property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[Sequence[str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash).\\n Ant-style path expressions are supported (*, *\\*, ?).\\nFor example: "org/apache/**".
        """
        return pulumi.get(self, "exclude_patterns")

    @property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[Sequence[str]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash).\\n Ant-style path expressions are supported (*, *\\*, ?).\\nFor example: "org/apache/**".
        """
        return pulumi.get(self, "include_patterns")


@pulumi.output_type
class ReleaseBundleWebhookHandler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customHttpHeaders":
            suggest = "custom_http_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReleaseBundleWebhookHandler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReleaseBundleWebhookHandler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReleaseBundleWebhookHandler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: str,
                 custom_http_headers: Optional[Mapping[str, str]] = None,
                 proxy: Optional[str] = None,
                 secret: Optional[str] = None):
        """
        :param str url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param Mapping[str, str] custom_http_headers: Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        :param str proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param str secret: Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        pulumi.set(__self__, "url", url)
        if custom_http_headers is not None:
            pulumi.set(__self__, "custom_http_headers", custom_http_headers)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="customHttpHeaders")
    def custom_http_headers(self) -> Optional[Mapping[str, str]]:
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        return pulumi.get(self, "custom_http_headers")

    @property
    @pulumi.getter
    def proxy(self) -> Optional[str]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @property
    @pulumi.getter
    def secret(self) -> Optional[str]:
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class RemoteAlpineRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteAlpineRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteAlpineRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteAlpineRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteBowerRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteBowerRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteBowerRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteBowerRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteCargoRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteCargoRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteCargoRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteCargoRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteChefRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteChefRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteChefRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteChefRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteCocoapodsRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteCocoapodsRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteCocoapodsRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteCocoapodsRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteComposerRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteComposerRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteComposerRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteComposerRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteConanRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteConanRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteConanRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteConanRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteCondaRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteCondaRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteCondaRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteCondaRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteCranRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteCranRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteCranRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteCranRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteDebianRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteDebianRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteDebianRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteDebianRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteDockerRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteDockerRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteDockerRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteDockerRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteGemsRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteGemsRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteGemsRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteGemsRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteGenericRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteGenericRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteGenericRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteGenericRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteGitlfsRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteGitlfsRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteGitlfsRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteGitlfsRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteGoRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteGoRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteGoRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteGoRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteGradleRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteGradleRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteGradleRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteGradleRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteHelmRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteHelmRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteHelmRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteHelmRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteIvyRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteIvyRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteIvyRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteIvyRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteMavenRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteMavenRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteMavenRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteMavenRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteNpmRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteNpmRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteNpmRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteNpmRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteNugetRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteNugetRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteNugetRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteNugetRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteOpkgRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteOpkgRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteOpkgRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteOpkgRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteP2RepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteP2RepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteP2RepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteP2RepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemotePubRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemotePubRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemotePubRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemotePubRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemotePuppetRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemotePuppetRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemotePuppetRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemotePuppetRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemotePypiRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemotePypiRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemotePypiRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemotePypiRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteRpmRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteRpmRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteRpmRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteRpmRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteSbtRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteSbtRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteSbtRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteSbtRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteSwiftRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteSwiftRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteSwiftRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteSwiftRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteTerraformRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteTerraformRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteTerraformRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteTerraformRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class RemoteVcsRepositoryContentSynchronisation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertiesEnabled":
            suggest = "properties_enabled"
        elif key == "sourceOriginAbsenceDetection":
            suggest = "source_origin_absence_detection"
        elif key == "statisticsEnabled":
            suggest = "statistics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteVcsRepositoryContentSynchronisation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteVcsRepositoryContentSynchronisation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteVcsRepositoryContentSynchronisation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "properties_enabled")

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        return pulumi.get(self, "source_origin_absence_detection")

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "statistics_enabled")


@pulumi.output_type
class ReplicationConfigReplication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pathPrefix":
            suggest = "path_prefix"
        elif key == "socketTimeoutMillis":
            suggest = "socket_timeout_millis"
        elif key == "syncDeletes":
            suggest = "sync_deletes"
        elif key == "syncProperties":
            suggest = "sync_properties"
        elif key == "syncStatistics":
            suggest = "sync_statistics"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReplicationConfigReplication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReplicationConfigReplication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReplicationConfigReplication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 password: Optional[str] = None,
                 path_prefix: Optional[str] = None,
                 proxy: Optional[str] = None,
                 socket_timeout_millis: Optional[int] = None,
                 sync_deletes: Optional[bool] = None,
                 sync_properties: Optional[bool] = None,
                 sync_statistics: Optional[bool] = None,
                 url: Optional[str] = None,
                 username: Optional[str] = None):
        """
        :param str password: Requires password encryption to be turned off `POST /api/system/decrypt`.
        :param str proxy: Proxy key from Artifactory Proxies setting
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if path_prefix is not None:
            pulumi.set(__self__, "path_prefix", path_prefix)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if socket_timeout_millis is not None:
            pulumi.set(__self__, "socket_timeout_millis", socket_timeout_millis)
        if sync_deletes is not None:
            pulumi.set(__self__, "sync_deletes", sync_deletes)
        if sync_properties is not None:
            pulumi.set(__self__, "sync_properties", sync_properties)
        if sync_statistics is not None:
            pulumi.set(__self__, "sync_statistics", sync_statistics)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        Requires password encryption to be turned off `POST /api/system/decrypt`.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="pathPrefix")
    def path_prefix(self) -> Optional[str]:
        return pulumi.get(self, "path_prefix")

    @property
    @pulumi.getter
    def proxy(self) -> Optional[str]:
        """
        Proxy key from Artifactory Proxies setting
        """
        return pulumi.get(self, "proxy")

    @property
    @pulumi.getter(name="socketTimeoutMillis")
    def socket_timeout_millis(self) -> Optional[int]:
        return pulumi.get(self, "socket_timeout_millis")

    @property
    @pulumi.getter(name="syncDeletes")
    def sync_deletes(self) -> Optional[bool]:
        return pulumi.get(self, "sync_deletes")

    @property
    @pulumi.getter(name="syncProperties")
    def sync_properties(self) -> Optional[bool]:
        return pulumi.get(self, "sync_properties")

    @property
    @pulumi.getter(name="syncStatistics")
    def sync_statistics(self) -> Optional[bool]:
        return pulumi.get(self, "sync_statistics")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        return pulumi.get(self, "username")


@pulumi.output_type
class GetPermissionTargetBuildResult(dict):
    def __init__(__self__, *,
                 repositories: Sequence[str],
                 actions: Optional['outputs.GetPermissionTargetBuildActionsResult'] = None,
                 excludes_patterns: Optional[Sequence[str]] = None,
                 includes_patterns: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] repositories: List of repositories this permission target is applicable for. You can specify the
               name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote
               repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        :param Sequence[str] excludes_patterns: Pattern of artifacts to exclude.
        :param Sequence[str] includes_patterns: Pattern of artifacts to include.
        """
        pulumi.set(__self__, "repositories", repositories)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if excludes_patterns is not None:
            pulumi.set(__self__, "excludes_patterns", excludes_patterns)
        if includes_patterns is not None:
            pulumi.set(__self__, "includes_patterns", includes_patterns)

    @property
    @pulumi.getter
    def repositories(self) -> Sequence[str]:
        """
        List of repositories this permission target is applicable for. You can specify the
        name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote
        repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        """
        return pulumi.get(self, "repositories")

    @property
    @pulumi.getter
    def actions(self) -> Optional['outputs.GetPermissionTargetBuildActionsResult']:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="excludesPatterns")
    def excludes_patterns(self) -> Optional[Sequence[str]]:
        """
        Pattern of artifacts to exclude.
        """
        return pulumi.get(self, "excludes_patterns")

    @property
    @pulumi.getter(name="includesPatterns")
    def includes_patterns(self) -> Optional[Sequence[str]]:
        """
        Pattern of artifacts to include.
        """
        return pulumi.get(self, "includes_patterns")


@pulumi.output_type
class GetPermissionTargetBuildActionsResult(dict):
    def __init__(__self__, *,
                 groups: Optional[Sequence['outputs.GetPermissionTargetBuildActionsGroupResult']] = None,
                 users: Optional[Sequence['outputs.GetPermissionTargetBuildActionsUserResult']] = None):
        """
        :param Sequence['GetPermissionTargetBuildActionsGroupArgs'] groups: Groups this permission applies for.
        :param Sequence['GetPermissionTargetBuildActionsUserArgs'] users: Users this permission target applies for.
        """
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence['outputs.GetPermissionTargetBuildActionsGroupResult']]:
        """
        Groups this permission applies for.
        """
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def users(self) -> Optional[Sequence['outputs.GetPermissionTargetBuildActionsUserResult']]:
        """
        Users this permission target applies for.
        """
        return pulumi.get(self, "users")


@pulumi.output_type
class GetPermissionTargetBuildActionsGroupResult(dict):
    def __init__(__self__, *,
                 name: str,
                 permissions: Sequence[str]):
        """
        :param str name: Name of the permission target.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the permission target.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def permissions(self) -> Sequence[str]:
        return pulumi.get(self, "permissions")


@pulumi.output_type
class GetPermissionTargetBuildActionsUserResult(dict):
    def __init__(__self__, *,
                 name: str,
                 permissions: Sequence[str]):
        """
        :param str name: Name of the permission target.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the permission target.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def permissions(self) -> Sequence[str]:
        return pulumi.get(self, "permissions")


@pulumi.output_type
class GetPermissionTargetReleaseBundleResult(dict):
    def __init__(__self__, *,
                 repositories: Sequence[str],
                 actions: Optional['outputs.GetPermissionTargetReleaseBundleActionsResult'] = None,
                 excludes_patterns: Optional[Sequence[str]] = None,
                 includes_patterns: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] repositories: List of repositories this permission target is applicable for. You can specify the
               name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote
               repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        :param Sequence[str] excludes_patterns: Pattern of artifacts to exclude.
        :param Sequence[str] includes_patterns: Pattern of artifacts to include.
        """
        pulumi.set(__self__, "repositories", repositories)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if excludes_patterns is not None:
            pulumi.set(__self__, "excludes_patterns", excludes_patterns)
        if includes_patterns is not None:
            pulumi.set(__self__, "includes_patterns", includes_patterns)

    @property
    @pulumi.getter
    def repositories(self) -> Sequence[str]:
        """
        List of repositories this permission target is applicable for. You can specify the
        name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote
        repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        """
        return pulumi.get(self, "repositories")

    @property
    @pulumi.getter
    def actions(self) -> Optional['outputs.GetPermissionTargetReleaseBundleActionsResult']:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="excludesPatterns")
    def excludes_patterns(self) -> Optional[Sequence[str]]:
        """
        Pattern of artifacts to exclude.
        """
        return pulumi.get(self, "excludes_patterns")

    @property
    @pulumi.getter(name="includesPatterns")
    def includes_patterns(self) -> Optional[Sequence[str]]:
        """
        Pattern of artifacts to include.
        """
        return pulumi.get(self, "includes_patterns")


@pulumi.output_type
class GetPermissionTargetReleaseBundleActionsResult(dict):
    def __init__(__self__, *,
                 groups: Optional[Sequence['outputs.GetPermissionTargetReleaseBundleActionsGroupResult']] = None,
                 users: Optional[Sequence['outputs.GetPermissionTargetReleaseBundleActionsUserResult']] = None):
        """
        :param Sequence['GetPermissionTargetReleaseBundleActionsGroupArgs'] groups: Groups this permission applies for.
        :param Sequence['GetPermissionTargetReleaseBundleActionsUserArgs'] users: Users this permission target applies for.
        """
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence['outputs.GetPermissionTargetReleaseBundleActionsGroupResult']]:
        """
        Groups this permission applies for.
        """
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def users(self) -> Optional[Sequence['outputs.GetPermissionTargetReleaseBundleActionsUserResult']]:
        """
        Users this permission target applies for.
        """
        return pulumi.get(self, "users")


@pulumi.output_type
class GetPermissionTargetReleaseBundleActionsGroupResult(dict):
    def __init__(__self__, *,
                 name: str,
                 permissions: Sequence[str]):
        """
        :param str name: Name of the permission target.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the permission target.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def permissions(self) -> Sequence[str]:
        return pulumi.get(self, "permissions")


@pulumi.output_type
class GetPermissionTargetReleaseBundleActionsUserResult(dict):
    def __init__(__self__, *,
                 name: str,
                 permissions: Sequence[str]):
        """
        :param str name: Name of the permission target.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the permission target.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def permissions(self) -> Sequence[str]:
        return pulumi.get(self, "permissions")


@pulumi.output_type
class GetPermissionTargetRepoResult(dict):
    def __init__(__self__, *,
                 repositories: Sequence[str],
                 actions: Optional['outputs.GetPermissionTargetRepoActionsResult'] = None,
                 excludes_patterns: Optional[Sequence[str]] = None,
                 includes_patterns: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] repositories: List of repositories this permission target is applicable for. You can specify the
               name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote
               repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        :param Sequence[str] excludes_patterns: Pattern of artifacts to exclude.
        :param Sequence[str] includes_patterns: Pattern of artifacts to include.
        """
        pulumi.set(__self__, "repositories", repositories)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if excludes_patterns is not None:
            pulumi.set(__self__, "excludes_patterns", excludes_patterns)
        if includes_patterns is not None:
            pulumi.set(__self__, "includes_patterns", includes_patterns)

    @property
    @pulumi.getter
    def repositories(self) -> Sequence[str]:
        """
        List of repositories this permission target is applicable for. You can specify the
        name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote
        repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        """
        return pulumi.get(self, "repositories")

    @property
    @pulumi.getter
    def actions(self) -> Optional['outputs.GetPermissionTargetRepoActionsResult']:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="excludesPatterns")
    def excludes_patterns(self) -> Optional[Sequence[str]]:
        """
        Pattern of artifacts to exclude.
        """
        return pulumi.get(self, "excludes_patterns")

    @property
    @pulumi.getter(name="includesPatterns")
    def includes_patterns(self) -> Optional[Sequence[str]]:
        """
        Pattern of artifacts to include.
        """
        return pulumi.get(self, "includes_patterns")


@pulumi.output_type
class GetPermissionTargetRepoActionsResult(dict):
    def __init__(__self__, *,
                 groups: Optional[Sequence['outputs.GetPermissionTargetRepoActionsGroupResult']] = None,
                 users: Optional[Sequence['outputs.GetPermissionTargetRepoActionsUserResult']] = None):
        """
        :param Sequence['GetPermissionTargetRepoActionsGroupArgs'] groups: Groups this permission applies for.
        :param Sequence['GetPermissionTargetRepoActionsUserArgs'] users: Users this permission target applies for.
        """
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence['outputs.GetPermissionTargetRepoActionsGroupResult']]:
        """
        Groups this permission applies for.
        """
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def users(self) -> Optional[Sequence['outputs.GetPermissionTargetRepoActionsUserResult']]:
        """
        Users this permission target applies for.
        """
        return pulumi.get(self, "users")


@pulumi.output_type
class GetPermissionTargetRepoActionsGroupResult(dict):
    def __init__(__self__, *,
                 name: str,
                 permissions: Sequence[str]):
        """
        :param str name: Name of the permission target.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the permission target.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def permissions(self) -> Sequence[str]:
        return pulumi.get(self, "permissions")


@pulumi.output_type
class GetPermissionTargetRepoActionsUserResult(dict):
    def __init__(__self__, *,
                 name: str,
                 permissions: Sequence[str]):
        """
        :param str name: Name of the permission target.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the permission target.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def permissions(self) -> Sequence[str]:
        return pulumi.get(self, "permissions")


