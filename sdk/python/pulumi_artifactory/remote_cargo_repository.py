# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs
from ._inputs import *

__all__ = ['RemoteCargoRepositoryArgs', 'RemoteCargoRepository']

@pulumi.input_type
class RemoteCargoRepositoryArgs:
    def __init__(__self__, *,
                 git_registry_url: pulumi.Input[str],
                 key: pulumi.Input[str],
                 url: pulumi.Input[str],
                 allow_any_host_auth: Optional[pulumi.Input[bool]] = None,
                 anonymous_access: Optional[pulumi.Input[bool]] = None,
                 assumed_offline_period_secs: Optional[pulumi.Input[int]] = None,
                 blacked_out: Optional[pulumi.Input[bool]] = None,
                 block_mismatching_mime_types: Optional[pulumi.Input[bool]] = None,
                 bypass_head_requests: Optional[pulumi.Input[bool]] = None,
                 client_tls_certificate: Optional[pulumi.Input[str]] = None,
                 content_synchronisation: Optional[pulumi.Input['RemoteCargoRepositoryContentSynchronisationArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 enable_cookie_management: Optional[pulumi.Input[bool]] = None,
                 excludes_pattern: Optional[pulumi.Input[str]] = None,
                 hard_fail: Optional[pulumi.Input[bool]] = None,
                 includes_pattern: Optional[pulumi.Input[str]] = None,
                 local_address: Optional[pulumi.Input[str]] = None,
                 missed_cache_period_seconds: Optional[pulumi.Input[int]] = None,
                 notes: Optional[pulumi.Input[str]] = None,
                 offline: Optional[pulumi.Input[bool]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 priority_resolution: Optional[pulumi.Input[bool]] = None,
                 propagate_query_params: Optional[pulumi.Input[bool]] = None,
                 property_sets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 proxy: Optional[pulumi.Input[str]] = None,
                 remote_repo_layout_ref: Optional[pulumi.Input[str]] = None,
                 repo_layout_ref: Optional[pulumi.Input[str]] = None,
                 retrieval_cache_period_seconds: Optional[pulumi.Input[int]] = None,
                 share_configuration: Optional[pulumi.Input[bool]] = None,
                 socket_timeout_millis: Optional[pulumi.Input[int]] = None,
                 store_artifacts_locally: Optional[pulumi.Input[bool]] = None,
                 synchronize_properties: Optional[pulumi.Input[bool]] = None,
                 unused_artifacts_cleanup_period_enabled: Optional[pulumi.Input[bool]] = None,
                 unused_artifacts_cleanup_period_hours: Optional[pulumi.Input[int]] = None,
                 username: Optional[pulumi.Input[str]] = None,
                 xray_index: Optional[pulumi.Input[bool]] = None):
        """
        The set of arguments for constructing a RemoteCargoRepository resource.
        :param pulumi.Input[str] git_registry_url: - This is the index url, expected to be a git repository. for remote artifactory use "arturl/git/repokey.git"
        :param pulumi.Input[str] key: The repository identifier. Must be unique system-wide
        :param pulumi.Input[bool] allow_any_host_auth: Also known as 'Lenient Host Authentication', Allow credentials of this repository to be used on requests redirected to
               any other host.
        :param pulumi.Input[bool] anonymous_access: - Cargo client does not send credentials when performing download and search for crates. Enable this to allow anonymous access to these resources (only), note that this will override the security anonymous access option.
        :param pulumi.Input[int] assumed_offline_period_secs: The number of seconds the repository stays in assumed offline state after a connection error. At the end of this time,
               an online check is attempted in order to reset the offline status. A value of 0 means the repository is never assumed
               offline. Default to 300.
        :param pulumi.Input[bool] blacked_out: (A.K.A 'Ignore Repository' on the UI) When set, the repository or its local cache do not participate in artifact
               resolution.
        :param pulumi.Input[bool] block_mismatching_mime_types: Before caching an artifact, Artifactory first sends a HEAD request to the remote resource. In some remote resources,
               HEAD requests are disallowed and therefore rejected, even though downloading the artifact is allowed. When checked,
               Artifactory will bypass the HEAD request and cache the artifact directly using a GET request.
        :param pulumi.Input[bool] bypass_head_requests: Before caching an artifact, Artifactory first sends a HEAD request to the remote resource. In some remote resources,
               HEAD requests are disallowed and therefore rejected, even though downloading the artifact is allowed. When checked,
               Artifactory will bypass the HEAD request and cache the artifact directly using a GET request.
        :param pulumi.Input['RemoteCargoRepositoryContentSynchronisationArgs'] content_synchronisation: Reference [JFROG Smart Remote Repositories](https://www.jfrog.com/confluence/display/JFROG/Smart+Remote+Repositories)
        :param pulumi.Input[bool] enable_cookie_management: Enables cookie management if the remote repository uses cookies to manage client state.
        :param pulumi.Input[int] missed_cache_period_seconds: This is actually the missedRetrievalCachePeriodSecs in the API
        :param pulumi.Input[bool] offline: If set, Artifactory does not try to fetch remote artifacts. Only locally-cached artifacts are retrieved.
        :param pulumi.Input[bool] priority_resolution: Setting repositories with priority will cause metadata to be merged only from repositories set with this field
        :param pulumi.Input[int] retrieval_cache_period_seconds: The metadataRetrievalTimeoutSecs field not allowed to be bigger then retrievalCachePeriodSecs field.
        :param pulumi.Input[bool] store_artifacts_locally: When set, the repository should store cached artifacts locally. When not set, artifacts are not stored locally, and
               direct repository-to-client streaming is used. This can be useful for multi-server setups over a high-speed LAN, with
               one Artifactory caching certain data on central storage, and streaming it directly to satellite pass-though Artifactory
               servers.
        :param pulumi.Input[bool] synchronize_properties: When set, remote artifacts are fetched along with their properties.
        """
        pulumi.set(__self__, "git_registry_url", git_registry_url)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "url", url)
        if allow_any_host_auth is not None:
            pulumi.set(__self__, "allow_any_host_auth", allow_any_host_auth)
        if anonymous_access is not None:
            pulumi.set(__self__, "anonymous_access", anonymous_access)
        if assumed_offline_period_secs is not None:
            pulumi.set(__self__, "assumed_offline_period_secs", assumed_offline_period_secs)
        if blacked_out is not None:
            pulumi.set(__self__, "blacked_out", blacked_out)
        if block_mismatching_mime_types is not None:
            pulumi.set(__self__, "block_mismatching_mime_types", block_mismatching_mime_types)
        if bypass_head_requests is not None:
            pulumi.set(__self__, "bypass_head_requests", bypass_head_requests)
        if client_tls_certificate is not None:
            pulumi.set(__self__, "client_tls_certificate", client_tls_certificate)
        if content_synchronisation is not None:
            pulumi.set(__self__, "content_synchronisation", content_synchronisation)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enable_cookie_management is not None:
            pulumi.set(__self__, "enable_cookie_management", enable_cookie_management)
        if excludes_pattern is not None:
            pulumi.set(__self__, "excludes_pattern", excludes_pattern)
        if hard_fail is not None:
            pulumi.set(__self__, "hard_fail", hard_fail)
        if includes_pattern is not None:
            pulumi.set(__self__, "includes_pattern", includes_pattern)
        if local_address is not None:
            pulumi.set(__self__, "local_address", local_address)
        if missed_cache_period_seconds is not None:
            pulumi.set(__self__, "missed_cache_period_seconds", missed_cache_period_seconds)
        if notes is not None:
            pulumi.set(__self__, "notes", notes)
        if offline is not None:
            pulumi.set(__self__, "offline", offline)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if priority_resolution is not None:
            pulumi.set(__self__, "priority_resolution", priority_resolution)
        if propagate_query_params is not None:
            pulumi.set(__self__, "propagate_query_params", propagate_query_params)
        if property_sets is not None:
            pulumi.set(__self__, "property_sets", property_sets)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if remote_repo_layout_ref is not None:
            pulumi.set(__self__, "remote_repo_layout_ref", remote_repo_layout_ref)
        if repo_layout_ref is not None:
            pulumi.set(__self__, "repo_layout_ref", repo_layout_ref)
        if retrieval_cache_period_seconds is not None:
            pulumi.set(__self__, "retrieval_cache_period_seconds", retrieval_cache_period_seconds)
        if share_configuration is not None:
            pulumi.set(__self__, "share_configuration", share_configuration)
        if socket_timeout_millis is not None:
            pulumi.set(__self__, "socket_timeout_millis", socket_timeout_millis)
        if store_artifacts_locally is not None:
            pulumi.set(__self__, "store_artifacts_locally", store_artifacts_locally)
        if synchronize_properties is not None:
            pulumi.set(__self__, "synchronize_properties", synchronize_properties)
        if unused_artifacts_cleanup_period_enabled is not None:
            pulumi.set(__self__, "unused_artifacts_cleanup_period_enabled", unused_artifacts_cleanup_period_enabled)
        if unused_artifacts_cleanup_period_hours is not None:
            pulumi.set(__self__, "unused_artifacts_cleanup_period_hours", unused_artifacts_cleanup_period_hours)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if xray_index is not None:
            pulumi.set(__self__, "xray_index", xray_index)

    @property
    @pulumi.getter(name="gitRegistryUrl")
    def git_registry_url(self) -> pulumi.Input[str]:
        """
        - This is the index url, expected to be a git repository. for remote artifactory use "arturl/git/repokey.git"
        """
        return pulumi.get(self, "git_registry_url")

    @git_registry_url.setter
    def git_registry_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "git_registry_url", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The repository identifier. Must be unique system-wide
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="allowAnyHostAuth")
    def allow_any_host_auth(self) -> Optional[pulumi.Input[bool]]:
        """
        Also known as 'Lenient Host Authentication', Allow credentials of this repository to be used on requests redirected to
        any other host.
        """
        return pulumi.get(self, "allow_any_host_auth")

    @allow_any_host_auth.setter
    def allow_any_host_auth(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_any_host_auth", value)

    @property
    @pulumi.getter(name="anonymousAccess")
    def anonymous_access(self) -> Optional[pulumi.Input[bool]]:
        """
        - Cargo client does not send credentials when performing download and search for crates. Enable this to allow anonymous access to these resources (only), note that this will override the security anonymous access option.
        """
        return pulumi.get(self, "anonymous_access")

    @anonymous_access.setter
    def anonymous_access(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "anonymous_access", value)

    @property
    @pulumi.getter(name="assumedOfflinePeriodSecs")
    def assumed_offline_period_secs(self) -> Optional[pulumi.Input[int]]:
        """
        The number of seconds the repository stays in assumed offline state after a connection error. At the end of this time,
        an online check is attempted in order to reset the offline status. A value of 0 means the repository is never assumed
        offline. Default to 300.
        """
        return pulumi.get(self, "assumed_offline_period_secs")

    @assumed_offline_period_secs.setter
    def assumed_offline_period_secs(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "assumed_offline_period_secs", value)

    @property
    @pulumi.getter(name="blackedOut")
    def blacked_out(self) -> Optional[pulumi.Input[bool]]:
        """
        (A.K.A 'Ignore Repository' on the UI) When set, the repository or its local cache do not participate in artifact
        resolution.
        """
        return pulumi.get(self, "blacked_out")

    @blacked_out.setter
    def blacked_out(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "blacked_out", value)

    @property
    @pulumi.getter(name="blockMismatchingMimeTypes")
    def block_mismatching_mime_types(self) -> Optional[pulumi.Input[bool]]:
        """
        Before caching an artifact, Artifactory first sends a HEAD request to the remote resource. In some remote resources,
        HEAD requests are disallowed and therefore rejected, even though downloading the artifact is allowed. When checked,
        Artifactory will bypass the HEAD request and cache the artifact directly using a GET request.
        """
        return pulumi.get(self, "block_mismatching_mime_types")

    @block_mismatching_mime_types.setter
    def block_mismatching_mime_types(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "block_mismatching_mime_types", value)

    @property
    @pulumi.getter(name="bypassHeadRequests")
    def bypass_head_requests(self) -> Optional[pulumi.Input[bool]]:
        """
        Before caching an artifact, Artifactory first sends a HEAD request to the remote resource. In some remote resources,
        HEAD requests are disallowed and therefore rejected, even though downloading the artifact is allowed. When checked,
        Artifactory will bypass the HEAD request and cache the artifact directly using a GET request.
        """
        return pulumi.get(self, "bypass_head_requests")

    @bypass_head_requests.setter
    def bypass_head_requests(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "bypass_head_requests", value)

    @property
    @pulumi.getter(name="clientTlsCertificate")
    def client_tls_certificate(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "client_tls_certificate")

    @client_tls_certificate.setter
    def client_tls_certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_tls_certificate", value)

    @property
    @pulumi.getter(name="contentSynchronisation")
    def content_synchronisation(self) -> Optional[pulumi.Input['RemoteCargoRepositoryContentSynchronisationArgs']]:
        """
        Reference [JFROG Smart Remote Repositories](https://www.jfrog.com/confluence/display/JFROG/Smart+Remote+Repositories)
        """
        return pulumi.get(self, "content_synchronisation")

    @content_synchronisation.setter
    def content_synchronisation(self, value: Optional[pulumi.Input['RemoteCargoRepositoryContentSynchronisationArgs']]):
        pulumi.set(self, "content_synchronisation", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="enableCookieManagement")
    def enable_cookie_management(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables cookie management if the remote repository uses cookies to manage client state.
        """
        return pulumi.get(self, "enable_cookie_management")

    @enable_cookie_management.setter
    def enable_cookie_management(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_cookie_management", value)

    @property
    @pulumi.getter(name="excludesPattern")
    def excludes_pattern(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "excludes_pattern")

    @excludes_pattern.setter
    def excludes_pattern(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "excludes_pattern", value)

    @property
    @pulumi.getter(name="hardFail")
    def hard_fail(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "hard_fail")

    @hard_fail.setter
    def hard_fail(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "hard_fail", value)

    @property
    @pulumi.getter(name="includesPattern")
    def includes_pattern(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "includes_pattern")

    @includes_pattern.setter
    def includes_pattern(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "includes_pattern", value)

    @property
    @pulumi.getter(name="localAddress")
    def local_address(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "local_address")

    @local_address.setter
    def local_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "local_address", value)

    @property
    @pulumi.getter(name="missedCachePeriodSeconds")
    def missed_cache_period_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        This is actually the missedRetrievalCachePeriodSecs in the API
        """
        return pulumi.get(self, "missed_cache_period_seconds")

    @missed_cache_period_seconds.setter
    def missed_cache_period_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "missed_cache_period_seconds", value)

    @property
    @pulumi.getter
    def notes(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "notes")

    @notes.setter
    def notes(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "notes", value)

    @property
    @pulumi.getter
    def offline(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory does not try to fetch remote artifacts. Only locally-cached artifacts are retrieved.
        """
        return pulumi.get(self, "offline")

    @offline.setter
    def offline(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "offline", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="priorityResolution")
    def priority_resolution(self) -> Optional[pulumi.Input[bool]]:
        """
        Setting repositories with priority will cause metadata to be merged only from repositories set with this field
        """
        return pulumi.get(self, "priority_resolution")

    @priority_resolution.setter
    def priority_resolution(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "priority_resolution", value)

    @property
    @pulumi.getter(name="propagateQueryParams")
    def propagate_query_params(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "propagate_query_params")

    @propagate_query_params.setter
    def propagate_query_params(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "propagate_query_params", value)

    @property
    @pulumi.getter(name="propertySets")
    def property_sets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "property_sets")

    @property_sets.setter
    def property_sets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "property_sets", value)

    @property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy", value)

    @property
    @pulumi.getter(name="remoteRepoLayoutRef")
    def remote_repo_layout_ref(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "remote_repo_layout_ref")

    @remote_repo_layout_ref.setter
    def remote_repo_layout_ref(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "remote_repo_layout_ref", value)

    @property
    @pulumi.getter(name="repoLayoutRef")
    def repo_layout_ref(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "repo_layout_ref")

    @repo_layout_ref.setter
    def repo_layout_ref(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo_layout_ref", value)

    @property
    @pulumi.getter(name="retrievalCachePeriodSeconds")
    def retrieval_cache_period_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The metadataRetrievalTimeoutSecs field not allowed to be bigger then retrievalCachePeriodSecs field.
        """
        return pulumi.get(self, "retrieval_cache_period_seconds")

    @retrieval_cache_period_seconds.setter
    def retrieval_cache_period_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retrieval_cache_period_seconds", value)

    @property
    @pulumi.getter(name="shareConfiguration")
    def share_configuration(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "share_configuration")

    @share_configuration.setter
    def share_configuration(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "share_configuration", value)

    @property
    @pulumi.getter(name="socketTimeoutMillis")
    def socket_timeout_millis(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "socket_timeout_millis")

    @socket_timeout_millis.setter
    def socket_timeout_millis(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "socket_timeout_millis", value)

    @property
    @pulumi.getter(name="storeArtifactsLocally")
    def store_artifacts_locally(self) -> Optional[pulumi.Input[bool]]:
        """
        When set, the repository should store cached artifacts locally. When not set, artifacts are not stored locally, and
        direct repository-to-client streaming is used. This can be useful for multi-server setups over a high-speed LAN, with
        one Artifactory caching certain data on central storage, and streaming it directly to satellite pass-though Artifactory
        servers.
        """
        return pulumi.get(self, "store_artifacts_locally")

    @store_artifacts_locally.setter
    def store_artifacts_locally(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "store_artifacts_locally", value)

    @property
    @pulumi.getter(name="synchronizeProperties")
    def synchronize_properties(self) -> Optional[pulumi.Input[bool]]:
        """
        When set, remote artifacts are fetched along with their properties.
        """
        return pulumi.get(self, "synchronize_properties")

    @synchronize_properties.setter
    def synchronize_properties(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "synchronize_properties", value)

    @property
    @pulumi.getter(name="unusedArtifactsCleanupPeriodEnabled")
    def unused_artifacts_cleanup_period_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "unused_artifacts_cleanup_period_enabled")

    @unused_artifacts_cleanup_period_enabled.setter
    def unused_artifacts_cleanup_period_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "unused_artifacts_cleanup_period_enabled", value)

    @property
    @pulumi.getter(name="unusedArtifactsCleanupPeriodHours")
    def unused_artifacts_cleanup_period_hours(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "unused_artifacts_cleanup_period_hours")

    @unused_artifacts_cleanup_period_hours.setter
    def unused_artifacts_cleanup_period_hours(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "unused_artifacts_cleanup_period_hours", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="xrayIndex")
    def xray_index(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "xray_index")

    @xray_index.setter
    def xray_index(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "xray_index", value)


@pulumi.input_type
class _RemoteCargoRepositoryState:
    def __init__(__self__, *,
                 allow_any_host_auth: Optional[pulumi.Input[bool]] = None,
                 anonymous_access: Optional[pulumi.Input[bool]] = None,
                 assumed_offline_period_secs: Optional[pulumi.Input[int]] = None,
                 blacked_out: Optional[pulumi.Input[bool]] = None,
                 block_mismatching_mime_types: Optional[pulumi.Input[bool]] = None,
                 bypass_head_requests: Optional[pulumi.Input[bool]] = None,
                 client_tls_certificate: Optional[pulumi.Input[str]] = None,
                 content_synchronisation: Optional[pulumi.Input['RemoteCargoRepositoryContentSynchronisationArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 enable_cookie_management: Optional[pulumi.Input[bool]] = None,
                 excludes_pattern: Optional[pulumi.Input[str]] = None,
                 failed_retrieval_cache_period_secs: Optional[pulumi.Input[int]] = None,
                 git_registry_url: Optional[pulumi.Input[str]] = None,
                 hard_fail: Optional[pulumi.Input[bool]] = None,
                 includes_pattern: Optional[pulumi.Input[str]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 local_address: Optional[pulumi.Input[str]] = None,
                 missed_cache_period_seconds: Optional[pulumi.Input[int]] = None,
                 notes: Optional[pulumi.Input[str]] = None,
                 offline: Optional[pulumi.Input[bool]] = None,
                 package_type: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 priority_resolution: Optional[pulumi.Input[bool]] = None,
                 propagate_query_params: Optional[pulumi.Input[bool]] = None,
                 property_sets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 proxy: Optional[pulumi.Input[str]] = None,
                 remote_repo_layout_ref: Optional[pulumi.Input[str]] = None,
                 repo_layout_ref: Optional[pulumi.Input[str]] = None,
                 retrieval_cache_period_seconds: Optional[pulumi.Input[int]] = None,
                 share_configuration: Optional[pulumi.Input[bool]] = None,
                 socket_timeout_millis: Optional[pulumi.Input[int]] = None,
                 store_artifacts_locally: Optional[pulumi.Input[bool]] = None,
                 synchronize_properties: Optional[pulumi.Input[bool]] = None,
                 unused_artifacts_cleanup_period_enabled: Optional[pulumi.Input[bool]] = None,
                 unused_artifacts_cleanup_period_hours: Optional[pulumi.Input[int]] = None,
                 url: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None,
                 xray_index: Optional[pulumi.Input[bool]] = None):
        """
        Input properties used for looking up and filtering RemoteCargoRepository resources.
        :param pulumi.Input[bool] allow_any_host_auth: Also known as 'Lenient Host Authentication', Allow credentials of this repository to be used on requests redirected to
               any other host.
        :param pulumi.Input[bool] anonymous_access: - Cargo client does not send credentials when performing download and search for crates. Enable this to allow anonymous access to these resources (only), note that this will override the security anonymous access option.
        :param pulumi.Input[int] assumed_offline_period_secs: The number of seconds the repository stays in assumed offline state after a connection error. At the end of this time,
               an online check is attempted in order to reset the offline status. A value of 0 means the repository is never assumed
               offline. Default to 300.
        :param pulumi.Input[bool] blacked_out: (A.K.A 'Ignore Repository' on the UI) When set, the repository or its local cache do not participate in artifact
               resolution.
        :param pulumi.Input[bool] block_mismatching_mime_types: Before caching an artifact, Artifactory first sends a HEAD request to the remote resource. In some remote resources,
               HEAD requests are disallowed and therefore rejected, even though downloading the artifact is allowed. When checked,
               Artifactory will bypass the HEAD request and cache the artifact directly using a GET request.
        :param pulumi.Input[bool] bypass_head_requests: Before caching an artifact, Artifactory first sends a HEAD request to the remote resource. In some remote resources,
               HEAD requests are disallowed and therefore rejected, even though downloading the artifact is allowed. When checked,
               Artifactory will bypass the HEAD request and cache the artifact directly using a GET request.
        :param pulumi.Input['RemoteCargoRepositoryContentSynchronisationArgs'] content_synchronisation: Reference [JFROG Smart Remote Repositories](https://www.jfrog.com/confluence/display/JFROG/Smart+Remote+Repositories)
        :param pulumi.Input[bool] enable_cookie_management: Enables cookie management if the remote repository uses cookies to manage client state.
        :param pulumi.Input[str] git_registry_url: - This is the index url, expected to be a git repository. for remote artifactory use "arturl/git/repokey.git"
        :param pulumi.Input[str] key: The repository identifier. Must be unique system-wide
        :param pulumi.Input[int] missed_cache_period_seconds: This is actually the missedRetrievalCachePeriodSecs in the API
        :param pulumi.Input[bool] offline: If set, Artifactory does not try to fetch remote artifacts. Only locally-cached artifacts are retrieved.
        :param pulumi.Input[bool] priority_resolution: Setting repositories with priority will cause metadata to be merged only from repositories set with this field
        :param pulumi.Input[int] retrieval_cache_period_seconds: The metadataRetrievalTimeoutSecs field not allowed to be bigger then retrievalCachePeriodSecs field.
        :param pulumi.Input[bool] store_artifacts_locally: When set, the repository should store cached artifacts locally. When not set, artifacts are not stored locally, and
               direct repository-to-client streaming is used. This can be useful for multi-server setups over a high-speed LAN, with
               one Artifactory caching certain data on central storage, and streaming it directly to satellite pass-though Artifactory
               servers.
        :param pulumi.Input[bool] synchronize_properties: When set, remote artifacts are fetched along with their properties.
        """
        if allow_any_host_auth is not None:
            pulumi.set(__self__, "allow_any_host_auth", allow_any_host_auth)
        if anonymous_access is not None:
            pulumi.set(__self__, "anonymous_access", anonymous_access)
        if assumed_offline_period_secs is not None:
            pulumi.set(__self__, "assumed_offline_period_secs", assumed_offline_period_secs)
        if blacked_out is not None:
            pulumi.set(__self__, "blacked_out", blacked_out)
        if block_mismatching_mime_types is not None:
            pulumi.set(__self__, "block_mismatching_mime_types", block_mismatching_mime_types)
        if bypass_head_requests is not None:
            pulumi.set(__self__, "bypass_head_requests", bypass_head_requests)
        if client_tls_certificate is not None:
            pulumi.set(__self__, "client_tls_certificate", client_tls_certificate)
        if content_synchronisation is not None:
            pulumi.set(__self__, "content_synchronisation", content_synchronisation)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enable_cookie_management is not None:
            pulumi.set(__self__, "enable_cookie_management", enable_cookie_management)
        if excludes_pattern is not None:
            pulumi.set(__self__, "excludes_pattern", excludes_pattern)
        if failed_retrieval_cache_period_secs is not None:
            warnings.warn("""This field is not returned in a get payload but is offered on the UI. It's inserted here for inclusive and informational reasons. It does not function""", DeprecationWarning)
            pulumi.log.warn("""failed_retrieval_cache_period_secs is deprecated: This field is not returned in a get payload but is offered on the UI. It's inserted here for inclusive and informational reasons. It does not function""")
        if failed_retrieval_cache_period_secs is not None:
            pulumi.set(__self__, "failed_retrieval_cache_period_secs", failed_retrieval_cache_period_secs)
        if git_registry_url is not None:
            pulumi.set(__self__, "git_registry_url", git_registry_url)
        if hard_fail is not None:
            pulumi.set(__self__, "hard_fail", hard_fail)
        if includes_pattern is not None:
            pulumi.set(__self__, "includes_pattern", includes_pattern)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if local_address is not None:
            pulumi.set(__self__, "local_address", local_address)
        if missed_cache_period_seconds is not None:
            pulumi.set(__self__, "missed_cache_period_seconds", missed_cache_period_seconds)
        if notes is not None:
            pulumi.set(__self__, "notes", notes)
        if offline is not None:
            pulumi.set(__self__, "offline", offline)
        if package_type is not None:
            pulumi.set(__self__, "package_type", package_type)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if priority_resolution is not None:
            pulumi.set(__self__, "priority_resolution", priority_resolution)
        if propagate_query_params is not None:
            pulumi.set(__self__, "propagate_query_params", propagate_query_params)
        if property_sets is not None:
            pulumi.set(__self__, "property_sets", property_sets)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if remote_repo_layout_ref is not None:
            pulumi.set(__self__, "remote_repo_layout_ref", remote_repo_layout_ref)
        if repo_layout_ref is not None:
            pulumi.set(__self__, "repo_layout_ref", repo_layout_ref)
        if retrieval_cache_period_seconds is not None:
            pulumi.set(__self__, "retrieval_cache_period_seconds", retrieval_cache_period_seconds)
        if share_configuration is not None:
            pulumi.set(__self__, "share_configuration", share_configuration)
        if socket_timeout_millis is not None:
            pulumi.set(__self__, "socket_timeout_millis", socket_timeout_millis)
        if store_artifacts_locally is not None:
            pulumi.set(__self__, "store_artifacts_locally", store_artifacts_locally)
        if synchronize_properties is not None:
            pulumi.set(__self__, "synchronize_properties", synchronize_properties)
        if unused_artifacts_cleanup_period_enabled is not None:
            pulumi.set(__self__, "unused_artifacts_cleanup_period_enabled", unused_artifacts_cleanup_period_enabled)
        if unused_artifacts_cleanup_period_hours is not None:
            pulumi.set(__self__, "unused_artifacts_cleanup_period_hours", unused_artifacts_cleanup_period_hours)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if xray_index is not None:
            pulumi.set(__self__, "xray_index", xray_index)

    @property
    @pulumi.getter(name="allowAnyHostAuth")
    def allow_any_host_auth(self) -> Optional[pulumi.Input[bool]]:
        """
        Also known as 'Lenient Host Authentication', Allow credentials of this repository to be used on requests redirected to
        any other host.
        """
        return pulumi.get(self, "allow_any_host_auth")

    @allow_any_host_auth.setter
    def allow_any_host_auth(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_any_host_auth", value)

    @property
    @pulumi.getter(name="anonymousAccess")
    def anonymous_access(self) -> Optional[pulumi.Input[bool]]:
        """
        - Cargo client does not send credentials when performing download and search for crates. Enable this to allow anonymous access to these resources (only), note that this will override the security anonymous access option.
        """
        return pulumi.get(self, "anonymous_access")

    @anonymous_access.setter
    def anonymous_access(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "anonymous_access", value)

    @property
    @pulumi.getter(name="assumedOfflinePeriodSecs")
    def assumed_offline_period_secs(self) -> Optional[pulumi.Input[int]]:
        """
        The number of seconds the repository stays in assumed offline state after a connection error. At the end of this time,
        an online check is attempted in order to reset the offline status. A value of 0 means the repository is never assumed
        offline. Default to 300.
        """
        return pulumi.get(self, "assumed_offline_period_secs")

    @assumed_offline_period_secs.setter
    def assumed_offline_period_secs(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "assumed_offline_period_secs", value)

    @property
    @pulumi.getter(name="blackedOut")
    def blacked_out(self) -> Optional[pulumi.Input[bool]]:
        """
        (A.K.A 'Ignore Repository' on the UI) When set, the repository or its local cache do not participate in artifact
        resolution.
        """
        return pulumi.get(self, "blacked_out")

    @blacked_out.setter
    def blacked_out(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "blacked_out", value)

    @property
    @pulumi.getter(name="blockMismatchingMimeTypes")
    def block_mismatching_mime_types(self) -> Optional[pulumi.Input[bool]]:
        """
        Before caching an artifact, Artifactory first sends a HEAD request to the remote resource. In some remote resources,
        HEAD requests are disallowed and therefore rejected, even though downloading the artifact is allowed. When checked,
        Artifactory will bypass the HEAD request and cache the artifact directly using a GET request.
        """
        return pulumi.get(self, "block_mismatching_mime_types")

    @block_mismatching_mime_types.setter
    def block_mismatching_mime_types(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "block_mismatching_mime_types", value)

    @property
    @pulumi.getter(name="bypassHeadRequests")
    def bypass_head_requests(self) -> Optional[pulumi.Input[bool]]:
        """
        Before caching an artifact, Artifactory first sends a HEAD request to the remote resource. In some remote resources,
        HEAD requests are disallowed and therefore rejected, even though downloading the artifact is allowed. When checked,
        Artifactory will bypass the HEAD request and cache the artifact directly using a GET request.
        """
        return pulumi.get(self, "bypass_head_requests")

    @bypass_head_requests.setter
    def bypass_head_requests(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "bypass_head_requests", value)

    @property
    @pulumi.getter(name="clientTlsCertificate")
    def client_tls_certificate(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "client_tls_certificate")

    @client_tls_certificate.setter
    def client_tls_certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_tls_certificate", value)

    @property
    @pulumi.getter(name="contentSynchronisation")
    def content_synchronisation(self) -> Optional[pulumi.Input['RemoteCargoRepositoryContentSynchronisationArgs']]:
        """
        Reference [JFROG Smart Remote Repositories](https://www.jfrog.com/confluence/display/JFROG/Smart+Remote+Repositories)
        """
        return pulumi.get(self, "content_synchronisation")

    @content_synchronisation.setter
    def content_synchronisation(self, value: Optional[pulumi.Input['RemoteCargoRepositoryContentSynchronisationArgs']]):
        pulumi.set(self, "content_synchronisation", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="enableCookieManagement")
    def enable_cookie_management(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables cookie management if the remote repository uses cookies to manage client state.
        """
        return pulumi.get(self, "enable_cookie_management")

    @enable_cookie_management.setter
    def enable_cookie_management(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_cookie_management", value)

    @property
    @pulumi.getter(name="excludesPattern")
    def excludes_pattern(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "excludes_pattern")

    @excludes_pattern.setter
    def excludes_pattern(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "excludes_pattern", value)

    @property
    @pulumi.getter(name="failedRetrievalCachePeriodSecs")
    def failed_retrieval_cache_period_secs(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "failed_retrieval_cache_period_secs")

    @failed_retrieval_cache_period_secs.setter
    def failed_retrieval_cache_period_secs(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failed_retrieval_cache_period_secs", value)

    @property
    @pulumi.getter(name="gitRegistryUrl")
    def git_registry_url(self) -> Optional[pulumi.Input[str]]:
        """
        - This is the index url, expected to be a git repository. for remote artifactory use "arturl/git/repokey.git"
        """
        return pulumi.get(self, "git_registry_url")

    @git_registry_url.setter
    def git_registry_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "git_registry_url", value)

    @property
    @pulumi.getter(name="hardFail")
    def hard_fail(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "hard_fail")

    @hard_fail.setter
    def hard_fail(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "hard_fail", value)

    @property
    @pulumi.getter(name="includesPattern")
    def includes_pattern(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "includes_pattern")

    @includes_pattern.setter
    def includes_pattern(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "includes_pattern", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        The repository identifier. Must be unique system-wide
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="localAddress")
    def local_address(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "local_address")

    @local_address.setter
    def local_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "local_address", value)

    @property
    @pulumi.getter(name="missedCachePeriodSeconds")
    def missed_cache_period_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        This is actually the missedRetrievalCachePeriodSecs in the API
        """
        return pulumi.get(self, "missed_cache_period_seconds")

    @missed_cache_period_seconds.setter
    def missed_cache_period_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "missed_cache_period_seconds", value)

    @property
    @pulumi.getter
    def notes(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "notes")

    @notes.setter
    def notes(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "notes", value)

    @property
    @pulumi.getter
    def offline(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory does not try to fetch remote artifacts. Only locally-cached artifacts are retrieved.
        """
        return pulumi.get(self, "offline")

    @offline.setter
    def offline(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "offline", value)

    @property
    @pulumi.getter(name="packageType")
    def package_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "package_type")

    @package_type.setter
    def package_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "package_type", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="priorityResolution")
    def priority_resolution(self) -> Optional[pulumi.Input[bool]]:
        """
        Setting repositories with priority will cause metadata to be merged only from repositories set with this field
        """
        return pulumi.get(self, "priority_resolution")

    @priority_resolution.setter
    def priority_resolution(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "priority_resolution", value)

    @property
    @pulumi.getter(name="propagateQueryParams")
    def propagate_query_params(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "propagate_query_params")

    @propagate_query_params.setter
    def propagate_query_params(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "propagate_query_params", value)

    @property
    @pulumi.getter(name="propertySets")
    def property_sets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "property_sets")

    @property_sets.setter
    def property_sets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "property_sets", value)

    @property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy", value)

    @property
    @pulumi.getter(name="remoteRepoLayoutRef")
    def remote_repo_layout_ref(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "remote_repo_layout_ref")

    @remote_repo_layout_ref.setter
    def remote_repo_layout_ref(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "remote_repo_layout_ref", value)

    @property
    @pulumi.getter(name="repoLayoutRef")
    def repo_layout_ref(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "repo_layout_ref")

    @repo_layout_ref.setter
    def repo_layout_ref(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo_layout_ref", value)

    @property
    @pulumi.getter(name="retrievalCachePeriodSeconds")
    def retrieval_cache_period_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The metadataRetrievalTimeoutSecs field not allowed to be bigger then retrievalCachePeriodSecs field.
        """
        return pulumi.get(self, "retrieval_cache_period_seconds")

    @retrieval_cache_period_seconds.setter
    def retrieval_cache_period_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retrieval_cache_period_seconds", value)

    @property
    @pulumi.getter(name="shareConfiguration")
    def share_configuration(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "share_configuration")

    @share_configuration.setter
    def share_configuration(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "share_configuration", value)

    @property
    @pulumi.getter(name="socketTimeoutMillis")
    def socket_timeout_millis(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "socket_timeout_millis")

    @socket_timeout_millis.setter
    def socket_timeout_millis(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "socket_timeout_millis", value)

    @property
    @pulumi.getter(name="storeArtifactsLocally")
    def store_artifacts_locally(self) -> Optional[pulumi.Input[bool]]:
        """
        When set, the repository should store cached artifacts locally. When not set, artifacts are not stored locally, and
        direct repository-to-client streaming is used. This can be useful for multi-server setups over a high-speed LAN, with
        one Artifactory caching certain data on central storage, and streaming it directly to satellite pass-though Artifactory
        servers.
        """
        return pulumi.get(self, "store_artifacts_locally")

    @store_artifacts_locally.setter
    def store_artifacts_locally(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "store_artifacts_locally", value)

    @property
    @pulumi.getter(name="synchronizeProperties")
    def synchronize_properties(self) -> Optional[pulumi.Input[bool]]:
        """
        When set, remote artifacts are fetched along with their properties.
        """
        return pulumi.get(self, "synchronize_properties")

    @synchronize_properties.setter
    def synchronize_properties(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "synchronize_properties", value)

    @property
    @pulumi.getter(name="unusedArtifactsCleanupPeriodEnabled")
    def unused_artifacts_cleanup_period_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "unused_artifacts_cleanup_period_enabled")

    @unused_artifacts_cleanup_period_enabled.setter
    def unused_artifacts_cleanup_period_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "unused_artifacts_cleanup_period_enabled", value)

    @property
    @pulumi.getter(name="unusedArtifactsCleanupPeriodHours")
    def unused_artifacts_cleanup_period_hours(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "unused_artifacts_cleanup_period_hours")

    @unused_artifacts_cleanup_period_hours.setter
    def unused_artifacts_cleanup_period_hours(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "unused_artifacts_cleanup_period_hours", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="xrayIndex")
    def xray_index(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "xray_index")

    @xray_index.setter
    def xray_index(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "xray_index", value)


class RemoteCargoRepository(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 allow_any_host_auth: Optional[pulumi.Input[bool]] = None,
                 anonymous_access: Optional[pulumi.Input[bool]] = None,
                 assumed_offline_period_secs: Optional[pulumi.Input[int]] = None,
                 blacked_out: Optional[pulumi.Input[bool]] = None,
                 block_mismatching_mime_types: Optional[pulumi.Input[bool]] = None,
                 bypass_head_requests: Optional[pulumi.Input[bool]] = None,
                 client_tls_certificate: Optional[pulumi.Input[str]] = None,
                 content_synchronisation: Optional[pulumi.Input[pulumi.InputType['RemoteCargoRepositoryContentSynchronisationArgs']]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 enable_cookie_management: Optional[pulumi.Input[bool]] = None,
                 excludes_pattern: Optional[pulumi.Input[str]] = None,
                 git_registry_url: Optional[pulumi.Input[str]] = None,
                 hard_fail: Optional[pulumi.Input[bool]] = None,
                 includes_pattern: Optional[pulumi.Input[str]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 local_address: Optional[pulumi.Input[str]] = None,
                 missed_cache_period_seconds: Optional[pulumi.Input[int]] = None,
                 notes: Optional[pulumi.Input[str]] = None,
                 offline: Optional[pulumi.Input[bool]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 priority_resolution: Optional[pulumi.Input[bool]] = None,
                 propagate_query_params: Optional[pulumi.Input[bool]] = None,
                 property_sets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 proxy: Optional[pulumi.Input[str]] = None,
                 remote_repo_layout_ref: Optional[pulumi.Input[str]] = None,
                 repo_layout_ref: Optional[pulumi.Input[str]] = None,
                 retrieval_cache_period_seconds: Optional[pulumi.Input[int]] = None,
                 share_configuration: Optional[pulumi.Input[bool]] = None,
                 socket_timeout_millis: Optional[pulumi.Input[int]] = None,
                 store_artifacts_locally: Optional[pulumi.Input[bool]] = None,
                 synchronize_properties: Optional[pulumi.Input[bool]] = None,
                 unused_artifacts_cleanup_period_enabled: Optional[pulumi.Input[bool]] = None,
                 unused_artifacts_cleanup_period_hours: Optional[pulumi.Input[int]] = None,
                 url: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None,
                 xray_index: Optional[pulumi.Input[bool]] = None,
                 __props__=None):
        """
        ## # Artifactory Remote Cargo Repository Resource

        Provides an Artifactory remote `cargo` repository resource. This provides cargo specific fields and is the only way to get them
        Official documentation can be found [here](https://www.jfrog.com/confluence/display/JFROG/Cargo+Registry)

        ## Example Usage

        Create a new Artifactory remote cargo repository called my-remote-cargo
        for brevity sake, only cargo specific fields are included; for other fields see documentation for
        generic repo.
        ```python
        import pulumi
        import pulumi_artifactory as artifactory

        my_remote_cargo = artifactory.RemoteCargoRepository("my-remote-cargo",
            anonymous_access=True,
            git_registry_url="https://github.com/rust-lang/foo.index",
            key="my-remote-cargo")
        ```
        ## Note

        If you get a 400 error: `"Custom Base URL should be defined prior to creating a Cargo repository"`,
        you must set the base url at: `http://${host}/ui/admin/configuration/general`

        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[bool] allow_any_host_auth: Also known as 'Lenient Host Authentication', Allow credentials of this repository to be used on requests redirected to
               any other host.
        :param pulumi.Input[bool] anonymous_access: - Cargo client does not send credentials when performing download and search for crates. Enable this to allow anonymous access to these resources (only), note that this will override the security anonymous access option.
        :param pulumi.Input[int] assumed_offline_period_secs: The number of seconds the repository stays in assumed offline state after a connection error. At the end of this time,
               an online check is attempted in order to reset the offline status. A value of 0 means the repository is never assumed
               offline. Default to 300.
        :param pulumi.Input[bool] blacked_out: (A.K.A 'Ignore Repository' on the UI) When set, the repository or its local cache do not participate in artifact
               resolution.
        :param pulumi.Input[bool] block_mismatching_mime_types: Before caching an artifact, Artifactory first sends a HEAD request to the remote resource. In some remote resources,
               HEAD requests are disallowed and therefore rejected, even though downloading the artifact is allowed. When checked,
               Artifactory will bypass the HEAD request and cache the artifact directly using a GET request.
        :param pulumi.Input[bool] bypass_head_requests: Before caching an artifact, Artifactory first sends a HEAD request to the remote resource. In some remote resources,
               HEAD requests are disallowed and therefore rejected, even though downloading the artifact is allowed. When checked,
               Artifactory will bypass the HEAD request and cache the artifact directly using a GET request.
        :param pulumi.Input[pulumi.InputType['RemoteCargoRepositoryContentSynchronisationArgs']] content_synchronisation: Reference [JFROG Smart Remote Repositories](https://www.jfrog.com/confluence/display/JFROG/Smart+Remote+Repositories)
        :param pulumi.Input[bool] enable_cookie_management: Enables cookie management if the remote repository uses cookies to manage client state.
        :param pulumi.Input[str] git_registry_url: - This is the index url, expected to be a git repository. for remote artifactory use "arturl/git/repokey.git"
        :param pulumi.Input[str] key: The repository identifier. Must be unique system-wide
        :param pulumi.Input[int] missed_cache_period_seconds: This is actually the missedRetrievalCachePeriodSecs in the API
        :param pulumi.Input[bool] offline: If set, Artifactory does not try to fetch remote artifacts. Only locally-cached artifacts are retrieved.
        :param pulumi.Input[bool] priority_resolution: Setting repositories with priority will cause metadata to be merged only from repositories set with this field
        :param pulumi.Input[int] retrieval_cache_period_seconds: The metadataRetrievalTimeoutSecs field not allowed to be bigger then retrievalCachePeriodSecs field.
        :param pulumi.Input[bool] store_artifacts_locally: When set, the repository should store cached artifacts locally. When not set, artifacts are not stored locally, and
               direct repository-to-client streaming is used. This can be useful for multi-server setups over a high-speed LAN, with
               one Artifactory caching certain data on central storage, and streaming it directly to satellite pass-though Artifactory
               servers.
        :param pulumi.Input[bool] synchronize_properties: When set, remote artifacts are fetched along with their properties.
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: RemoteCargoRepositoryArgs,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        ## # Artifactory Remote Cargo Repository Resource

        Provides an Artifactory remote `cargo` repository resource. This provides cargo specific fields and is the only way to get them
        Official documentation can be found [here](https://www.jfrog.com/confluence/display/JFROG/Cargo+Registry)

        ## Example Usage

        Create a new Artifactory remote cargo repository called my-remote-cargo
        for brevity sake, only cargo specific fields are included; for other fields see documentation for
        generic repo.
        ```python
        import pulumi
        import pulumi_artifactory as artifactory

        my_remote_cargo = artifactory.RemoteCargoRepository("my-remote-cargo",
            anonymous_access=True,
            git_registry_url="https://github.com/rust-lang/foo.index",
            key="my-remote-cargo")
        ```
        ## Note

        If you get a 400 error: `"Custom Base URL should be defined prior to creating a Cargo repository"`,
        you must set the base url at: `http://${host}/ui/admin/configuration/general`

        :param str resource_name: The name of the resource.
        :param RemoteCargoRepositoryArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(RemoteCargoRepositoryArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 allow_any_host_auth: Optional[pulumi.Input[bool]] = None,
                 anonymous_access: Optional[pulumi.Input[bool]] = None,
                 assumed_offline_period_secs: Optional[pulumi.Input[int]] = None,
                 blacked_out: Optional[pulumi.Input[bool]] = None,
                 block_mismatching_mime_types: Optional[pulumi.Input[bool]] = None,
                 bypass_head_requests: Optional[pulumi.Input[bool]] = None,
                 client_tls_certificate: Optional[pulumi.Input[str]] = None,
                 content_synchronisation: Optional[pulumi.Input[pulumi.InputType['RemoteCargoRepositoryContentSynchronisationArgs']]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 enable_cookie_management: Optional[pulumi.Input[bool]] = None,
                 excludes_pattern: Optional[pulumi.Input[str]] = None,
                 git_registry_url: Optional[pulumi.Input[str]] = None,
                 hard_fail: Optional[pulumi.Input[bool]] = None,
                 includes_pattern: Optional[pulumi.Input[str]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 local_address: Optional[pulumi.Input[str]] = None,
                 missed_cache_period_seconds: Optional[pulumi.Input[int]] = None,
                 notes: Optional[pulumi.Input[str]] = None,
                 offline: Optional[pulumi.Input[bool]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 priority_resolution: Optional[pulumi.Input[bool]] = None,
                 propagate_query_params: Optional[pulumi.Input[bool]] = None,
                 property_sets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 proxy: Optional[pulumi.Input[str]] = None,
                 remote_repo_layout_ref: Optional[pulumi.Input[str]] = None,
                 repo_layout_ref: Optional[pulumi.Input[str]] = None,
                 retrieval_cache_period_seconds: Optional[pulumi.Input[int]] = None,
                 share_configuration: Optional[pulumi.Input[bool]] = None,
                 socket_timeout_millis: Optional[pulumi.Input[int]] = None,
                 store_artifacts_locally: Optional[pulumi.Input[bool]] = None,
                 synchronize_properties: Optional[pulumi.Input[bool]] = None,
                 unused_artifacts_cleanup_period_enabled: Optional[pulumi.Input[bool]] = None,
                 unused_artifacts_cleanup_period_hours: Optional[pulumi.Input[int]] = None,
                 url: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None,
                 xray_index: Optional[pulumi.Input[bool]] = None,
                 __props__=None):
        if opts is None:
            opts = pulumi.ResourceOptions()
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.version is None:
            opts.version = _utilities.get_version()
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = RemoteCargoRepositoryArgs.__new__(RemoteCargoRepositoryArgs)

            __props__.__dict__["allow_any_host_auth"] = allow_any_host_auth
            __props__.__dict__["anonymous_access"] = anonymous_access
            __props__.__dict__["assumed_offline_period_secs"] = assumed_offline_period_secs
            __props__.__dict__["blacked_out"] = blacked_out
            __props__.__dict__["block_mismatching_mime_types"] = block_mismatching_mime_types
            __props__.__dict__["bypass_head_requests"] = bypass_head_requests
            __props__.__dict__["client_tls_certificate"] = client_tls_certificate
            __props__.__dict__["content_synchronisation"] = content_synchronisation
            __props__.__dict__["description"] = description
            __props__.__dict__["enable_cookie_management"] = enable_cookie_management
            __props__.__dict__["excludes_pattern"] = excludes_pattern
            if git_registry_url is None and not opts.urn:
                raise TypeError("Missing required property 'git_registry_url'")
            __props__.__dict__["git_registry_url"] = git_registry_url
            __props__.__dict__["hard_fail"] = hard_fail
            __props__.__dict__["includes_pattern"] = includes_pattern
            if key is None and not opts.urn:
                raise TypeError("Missing required property 'key'")
            __props__.__dict__["key"] = key
            __props__.__dict__["local_address"] = local_address
            __props__.__dict__["missed_cache_period_seconds"] = missed_cache_period_seconds
            __props__.__dict__["notes"] = notes
            __props__.__dict__["offline"] = offline
            __props__.__dict__["password"] = password
            __props__.__dict__["priority_resolution"] = priority_resolution
            __props__.__dict__["propagate_query_params"] = propagate_query_params
            __props__.__dict__["property_sets"] = property_sets
            __props__.__dict__["proxy"] = proxy
            __props__.__dict__["remote_repo_layout_ref"] = remote_repo_layout_ref
            __props__.__dict__["repo_layout_ref"] = repo_layout_ref
            __props__.__dict__["retrieval_cache_period_seconds"] = retrieval_cache_period_seconds
            __props__.__dict__["share_configuration"] = share_configuration
            __props__.__dict__["socket_timeout_millis"] = socket_timeout_millis
            __props__.__dict__["store_artifacts_locally"] = store_artifacts_locally
            __props__.__dict__["synchronize_properties"] = synchronize_properties
            __props__.__dict__["unused_artifacts_cleanup_period_enabled"] = unused_artifacts_cleanup_period_enabled
            __props__.__dict__["unused_artifacts_cleanup_period_hours"] = unused_artifacts_cleanup_period_hours
            if url is None and not opts.urn:
                raise TypeError("Missing required property 'url'")
            __props__.__dict__["url"] = url
            __props__.__dict__["username"] = username
            __props__.__dict__["xray_index"] = xray_index
            __props__.__dict__["failed_retrieval_cache_period_secs"] = None
            __props__.__dict__["package_type"] = None
        super(RemoteCargoRepository, __self__).__init__(
            'artifactory:index/remoteCargoRepository:RemoteCargoRepository',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            allow_any_host_auth: Optional[pulumi.Input[bool]] = None,
            anonymous_access: Optional[pulumi.Input[bool]] = None,
            assumed_offline_period_secs: Optional[pulumi.Input[int]] = None,
            blacked_out: Optional[pulumi.Input[bool]] = None,
            block_mismatching_mime_types: Optional[pulumi.Input[bool]] = None,
            bypass_head_requests: Optional[pulumi.Input[bool]] = None,
            client_tls_certificate: Optional[pulumi.Input[str]] = None,
            content_synchronisation: Optional[pulumi.Input[pulumi.InputType['RemoteCargoRepositoryContentSynchronisationArgs']]] = None,
            description: Optional[pulumi.Input[str]] = None,
            enable_cookie_management: Optional[pulumi.Input[bool]] = None,
            excludes_pattern: Optional[pulumi.Input[str]] = None,
            failed_retrieval_cache_period_secs: Optional[pulumi.Input[int]] = None,
            git_registry_url: Optional[pulumi.Input[str]] = None,
            hard_fail: Optional[pulumi.Input[bool]] = None,
            includes_pattern: Optional[pulumi.Input[str]] = None,
            key: Optional[pulumi.Input[str]] = None,
            local_address: Optional[pulumi.Input[str]] = None,
            missed_cache_period_seconds: Optional[pulumi.Input[int]] = None,
            notes: Optional[pulumi.Input[str]] = None,
            offline: Optional[pulumi.Input[bool]] = None,
            package_type: Optional[pulumi.Input[str]] = None,
            password: Optional[pulumi.Input[str]] = None,
            priority_resolution: Optional[pulumi.Input[bool]] = None,
            propagate_query_params: Optional[pulumi.Input[bool]] = None,
            property_sets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            proxy: Optional[pulumi.Input[str]] = None,
            remote_repo_layout_ref: Optional[pulumi.Input[str]] = None,
            repo_layout_ref: Optional[pulumi.Input[str]] = None,
            retrieval_cache_period_seconds: Optional[pulumi.Input[int]] = None,
            share_configuration: Optional[pulumi.Input[bool]] = None,
            socket_timeout_millis: Optional[pulumi.Input[int]] = None,
            store_artifacts_locally: Optional[pulumi.Input[bool]] = None,
            synchronize_properties: Optional[pulumi.Input[bool]] = None,
            unused_artifacts_cleanup_period_enabled: Optional[pulumi.Input[bool]] = None,
            unused_artifacts_cleanup_period_hours: Optional[pulumi.Input[int]] = None,
            url: Optional[pulumi.Input[str]] = None,
            username: Optional[pulumi.Input[str]] = None,
            xray_index: Optional[pulumi.Input[bool]] = None) -> 'RemoteCargoRepository':
        """
        Get an existing RemoteCargoRepository resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[bool] allow_any_host_auth: Also known as 'Lenient Host Authentication', Allow credentials of this repository to be used on requests redirected to
               any other host.
        :param pulumi.Input[bool] anonymous_access: - Cargo client does not send credentials when performing download and search for crates. Enable this to allow anonymous access to these resources (only), note that this will override the security anonymous access option.
        :param pulumi.Input[int] assumed_offline_period_secs: The number of seconds the repository stays in assumed offline state after a connection error. At the end of this time,
               an online check is attempted in order to reset the offline status. A value of 0 means the repository is never assumed
               offline. Default to 300.
        :param pulumi.Input[bool] blacked_out: (A.K.A 'Ignore Repository' on the UI) When set, the repository or its local cache do not participate in artifact
               resolution.
        :param pulumi.Input[bool] block_mismatching_mime_types: Before caching an artifact, Artifactory first sends a HEAD request to the remote resource. In some remote resources,
               HEAD requests are disallowed and therefore rejected, even though downloading the artifact is allowed. When checked,
               Artifactory will bypass the HEAD request and cache the artifact directly using a GET request.
        :param pulumi.Input[bool] bypass_head_requests: Before caching an artifact, Artifactory first sends a HEAD request to the remote resource. In some remote resources,
               HEAD requests are disallowed and therefore rejected, even though downloading the artifact is allowed. When checked,
               Artifactory will bypass the HEAD request and cache the artifact directly using a GET request.
        :param pulumi.Input[pulumi.InputType['RemoteCargoRepositoryContentSynchronisationArgs']] content_synchronisation: Reference [JFROG Smart Remote Repositories](https://www.jfrog.com/confluence/display/JFROG/Smart+Remote+Repositories)
        :param pulumi.Input[bool] enable_cookie_management: Enables cookie management if the remote repository uses cookies to manage client state.
        :param pulumi.Input[str] git_registry_url: - This is the index url, expected to be a git repository. for remote artifactory use "arturl/git/repokey.git"
        :param pulumi.Input[str] key: The repository identifier. Must be unique system-wide
        :param pulumi.Input[int] missed_cache_period_seconds: This is actually the missedRetrievalCachePeriodSecs in the API
        :param pulumi.Input[bool] offline: If set, Artifactory does not try to fetch remote artifacts. Only locally-cached artifacts are retrieved.
        :param pulumi.Input[bool] priority_resolution: Setting repositories with priority will cause metadata to be merged only from repositories set with this field
        :param pulumi.Input[int] retrieval_cache_period_seconds: The metadataRetrievalTimeoutSecs field not allowed to be bigger then retrievalCachePeriodSecs field.
        :param pulumi.Input[bool] store_artifacts_locally: When set, the repository should store cached artifacts locally. When not set, artifacts are not stored locally, and
               direct repository-to-client streaming is used. This can be useful for multi-server setups over a high-speed LAN, with
               one Artifactory caching certain data on central storage, and streaming it directly to satellite pass-though Artifactory
               servers.
        :param pulumi.Input[bool] synchronize_properties: When set, remote artifacts are fetched along with their properties.
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _RemoteCargoRepositoryState.__new__(_RemoteCargoRepositoryState)

        __props__.__dict__["allow_any_host_auth"] = allow_any_host_auth
        __props__.__dict__["anonymous_access"] = anonymous_access
        __props__.__dict__["assumed_offline_period_secs"] = assumed_offline_period_secs
        __props__.__dict__["blacked_out"] = blacked_out
        __props__.__dict__["block_mismatching_mime_types"] = block_mismatching_mime_types
        __props__.__dict__["bypass_head_requests"] = bypass_head_requests
        __props__.__dict__["client_tls_certificate"] = client_tls_certificate
        __props__.__dict__["content_synchronisation"] = content_synchronisation
        __props__.__dict__["description"] = description
        __props__.__dict__["enable_cookie_management"] = enable_cookie_management
        __props__.__dict__["excludes_pattern"] = excludes_pattern
        __props__.__dict__["failed_retrieval_cache_period_secs"] = failed_retrieval_cache_period_secs
        __props__.__dict__["git_registry_url"] = git_registry_url
        __props__.__dict__["hard_fail"] = hard_fail
        __props__.__dict__["includes_pattern"] = includes_pattern
        __props__.__dict__["key"] = key
        __props__.__dict__["local_address"] = local_address
        __props__.__dict__["missed_cache_period_seconds"] = missed_cache_period_seconds
        __props__.__dict__["notes"] = notes
        __props__.__dict__["offline"] = offline
        __props__.__dict__["package_type"] = package_type
        __props__.__dict__["password"] = password
        __props__.__dict__["priority_resolution"] = priority_resolution
        __props__.__dict__["propagate_query_params"] = propagate_query_params
        __props__.__dict__["property_sets"] = property_sets
        __props__.__dict__["proxy"] = proxy
        __props__.__dict__["remote_repo_layout_ref"] = remote_repo_layout_ref
        __props__.__dict__["repo_layout_ref"] = repo_layout_ref
        __props__.__dict__["retrieval_cache_period_seconds"] = retrieval_cache_period_seconds
        __props__.__dict__["share_configuration"] = share_configuration
        __props__.__dict__["socket_timeout_millis"] = socket_timeout_millis
        __props__.__dict__["store_artifacts_locally"] = store_artifacts_locally
        __props__.__dict__["synchronize_properties"] = synchronize_properties
        __props__.__dict__["unused_artifacts_cleanup_period_enabled"] = unused_artifacts_cleanup_period_enabled
        __props__.__dict__["unused_artifacts_cleanup_period_hours"] = unused_artifacts_cleanup_period_hours
        __props__.__dict__["url"] = url
        __props__.__dict__["username"] = username
        __props__.__dict__["xray_index"] = xray_index
        return RemoteCargoRepository(resource_name, opts=opts, __props__=__props__)

    @property
    @pulumi.getter(name="allowAnyHostAuth")
    def allow_any_host_auth(self) -> pulumi.Output[bool]:
        """
        Also known as 'Lenient Host Authentication', Allow credentials of this repository to be used on requests redirected to
        any other host.
        """
        return pulumi.get(self, "allow_any_host_auth")

    @property
    @pulumi.getter(name="anonymousAccess")
    def anonymous_access(self) -> pulumi.Output[Optional[bool]]:
        """
        - Cargo client does not send credentials when performing download and search for crates. Enable this to allow anonymous access to these resources (only), note that this will override the security anonymous access option.
        """
        return pulumi.get(self, "anonymous_access")

    @property
    @pulumi.getter(name="assumedOfflinePeriodSecs")
    def assumed_offline_period_secs(self) -> pulumi.Output[Optional[int]]:
        """
        The number of seconds the repository stays in assumed offline state after a connection error. At the end of this time,
        an online check is attempted in order to reset the offline status. A value of 0 means the repository is never assumed
        offline. Default to 300.
        """
        return pulumi.get(self, "assumed_offline_period_secs")

    @property
    @pulumi.getter(name="blackedOut")
    def blacked_out(self) -> pulumi.Output[bool]:
        """
        (A.K.A 'Ignore Repository' on the UI) When set, the repository or its local cache do not participate in artifact
        resolution.
        """
        return pulumi.get(self, "blacked_out")

    @property
    @pulumi.getter(name="blockMismatchingMimeTypes")
    def block_mismatching_mime_types(self) -> pulumi.Output[bool]:
        """
        Before caching an artifact, Artifactory first sends a HEAD request to the remote resource. In some remote resources,
        HEAD requests are disallowed and therefore rejected, even though downloading the artifact is allowed. When checked,
        Artifactory will bypass the HEAD request and cache the artifact directly using a GET request.
        """
        return pulumi.get(self, "block_mismatching_mime_types")

    @property
    @pulumi.getter(name="bypassHeadRequests")
    def bypass_head_requests(self) -> pulumi.Output[bool]:
        """
        Before caching an artifact, Artifactory first sends a HEAD request to the remote resource. In some remote resources,
        HEAD requests are disallowed and therefore rejected, even though downloading the artifact is allowed. When checked,
        Artifactory will bypass the HEAD request and cache the artifact directly using a GET request.
        """
        return pulumi.get(self, "bypass_head_requests")

    @property
    @pulumi.getter(name="clientTlsCertificate")
    def client_tls_certificate(self) -> pulumi.Output[str]:
        return pulumi.get(self, "client_tls_certificate")

    @property
    @pulumi.getter(name="contentSynchronisation")
    def content_synchronisation(self) -> pulumi.Output['outputs.RemoteCargoRepositoryContentSynchronisation']:
        """
        Reference [JFROG Smart Remote Repositories](https://www.jfrog.com/confluence/display/JFROG/Smart+Remote+Repositories)
        """
        return pulumi.get(self, "content_synchronisation")

    @property
    @pulumi.getter
    def description(self) -> pulumi.Output[str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="enableCookieManagement")
    def enable_cookie_management(self) -> pulumi.Output[bool]:
        """
        Enables cookie management if the remote repository uses cookies to manage client state.
        """
        return pulumi.get(self, "enable_cookie_management")

    @property
    @pulumi.getter(name="excludesPattern")
    def excludes_pattern(self) -> pulumi.Output[str]:
        return pulumi.get(self, "excludes_pattern")

    @property
    @pulumi.getter(name="failedRetrievalCachePeriodSecs")
    def failed_retrieval_cache_period_secs(self) -> pulumi.Output[int]:
        return pulumi.get(self, "failed_retrieval_cache_period_secs")

    @property
    @pulumi.getter(name="gitRegistryUrl")
    def git_registry_url(self) -> pulumi.Output[str]:
        """
        - This is the index url, expected to be a git repository. for remote artifactory use "arturl/git/repokey.git"
        """
        return pulumi.get(self, "git_registry_url")

    @property
    @pulumi.getter(name="hardFail")
    def hard_fail(self) -> pulumi.Output[bool]:
        return pulumi.get(self, "hard_fail")

    @property
    @pulumi.getter(name="includesPattern")
    def includes_pattern(self) -> pulumi.Output[str]:
        return pulumi.get(self, "includes_pattern")

    @property
    @pulumi.getter
    def key(self) -> pulumi.Output[str]:
        """
        The repository identifier. Must be unique system-wide
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="localAddress")
    def local_address(self) -> pulumi.Output[Optional[str]]:
        return pulumi.get(self, "local_address")

    @property
    @pulumi.getter(name="missedCachePeriodSeconds")
    def missed_cache_period_seconds(self) -> pulumi.Output[int]:
        """
        This is actually the missedRetrievalCachePeriodSecs in the API
        """
        return pulumi.get(self, "missed_cache_period_seconds")

    @property
    @pulumi.getter
    def notes(self) -> pulumi.Output[Optional[str]]:
        return pulumi.get(self, "notes")

    @property
    @pulumi.getter
    def offline(self) -> pulumi.Output[bool]:
        """
        If set, Artifactory does not try to fetch remote artifacts. Only locally-cached artifacts are retrieved.
        """
        return pulumi.get(self, "offline")

    @property
    @pulumi.getter(name="packageType")
    def package_type(self) -> pulumi.Output[str]:
        return pulumi.get(self, "package_type")

    @property
    @pulumi.getter
    def password(self) -> pulumi.Output[Optional[str]]:
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="priorityResolution")
    def priority_resolution(self) -> pulumi.Output[bool]:
        """
        Setting repositories with priority will cause metadata to be merged only from repositories set with this field
        """
        return pulumi.get(self, "priority_resolution")

    @property
    @pulumi.getter(name="propagateQueryParams")
    def propagate_query_params(self) -> pulumi.Output[Optional[bool]]:
        return pulumi.get(self, "propagate_query_params")

    @property
    @pulumi.getter(name="propertySets")
    def property_sets(self) -> pulumi.Output[Optional[Sequence[str]]]:
        return pulumi.get(self, "property_sets")

    @property
    @pulumi.getter
    def proxy(self) -> pulumi.Output[str]:
        return pulumi.get(self, "proxy")

    @property
    @pulumi.getter(name="remoteRepoLayoutRef")
    def remote_repo_layout_ref(self) -> pulumi.Output[str]:
        return pulumi.get(self, "remote_repo_layout_ref")

    @property
    @pulumi.getter(name="repoLayoutRef")
    def repo_layout_ref(self) -> pulumi.Output[str]:
        return pulumi.get(self, "repo_layout_ref")

    @property
    @pulumi.getter(name="retrievalCachePeriodSeconds")
    def retrieval_cache_period_seconds(self) -> pulumi.Output[int]:
        """
        The metadataRetrievalTimeoutSecs field not allowed to be bigger then retrievalCachePeriodSecs field.
        """
        return pulumi.get(self, "retrieval_cache_period_seconds")

    @property
    @pulumi.getter(name="shareConfiguration")
    def share_configuration(self) -> pulumi.Output[bool]:
        return pulumi.get(self, "share_configuration")

    @property
    @pulumi.getter(name="socketTimeoutMillis")
    def socket_timeout_millis(self) -> pulumi.Output[int]:
        return pulumi.get(self, "socket_timeout_millis")

    @property
    @pulumi.getter(name="storeArtifactsLocally")
    def store_artifacts_locally(self) -> pulumi.Output[bool]:
        """
        When set, the repository should store cached artifacts locally. When not set, artifacts are not stored locally, and
        direct repository-to-client streaming is used. This can be useful for multi-server setups over a high-speed LAN, with
        one Artifactory caching certain data on central storage, and streaming it directly to satellite pass-though Artifactory
        servers.
        """
        return pulumi.get(self, "store_artifacts_locally")

    @property
    @pulumi.getter(name="synchronizeProperties")
    def synchronize_properties(self) -> pulumi.Output[bool]:
        """
        When set, remote artifacts are fetched along with their properties.
        """
        return pulumi.get(self, "synchronize_properties")

    @property
    @pulumi.getter(name="unusedArtifactsCleanupPeriodEnabled")
    def unused_artifacts_cleanup_period_enabled(self) -> pulumi.Output[bool]:
        return pulumi.get(self, "unused_artifacts_cleanup_period_enabled")

    @property
    @pulumi.getter(name="unusedArtifactsCleanupPeriodHours")
    def unused_artifacts_cleanup_period_hours(self) -> pulumi.Output[int]:
        return pulumi.get(self, "unused_artifacts_cleanup_period_hours")

    @property
    @pulumi.getter
    def url(self) -> pulumi.Output[str]:
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def username(self) -> pulumi.Output[Optional[str]]:
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="xrayIndex")
    def xray_index(self) -> pulumi.Output[bool]:
        return pulumi.get(self, "xray_index")

