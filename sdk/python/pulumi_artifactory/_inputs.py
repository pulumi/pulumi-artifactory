# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities

__all__ = [
    'AccessTokenAdminTokenArgs',
    'ArtifactCustomWebhookCriteriaArgs',
    'ArtifactCustomWebhookHandlerArgs',
    'ArtifactLifecycleCustomWebhookHandlerArgs',
    'ArtifactLifecycleWebhookHandlerArgs',
    'ArtifactPropertyCustomWebhookCriteriaArgs',
    'ArtifactPropertyCustomWebhookHandlerArgs',
    'ArtifactPropertyWebhookCriteriaArgs',
    'ArtifactPropertyWebhookHandlerArgs',
    'ArtifactWebhookCriteriaArgs',
    'ArtifactWebhookHandlerArgs',
    'ArtifactoryReleaseBundleCustomWebhookCriteriaArgs',
    'ArtifactoryReleaseBundleCustomWebhookHandlerArgs',
    'ArtifactoryReleaseBundleWebhookCriteriaArgs',
    'ArtifactoryReleaseBundleWebhookHandlerArgs',
    'BuildCustomWebhookCriteriaArgs',
    'BuildCustomWebhookHandlerArgs',
    'BuildWebhookCriteriaArgs',
    'BuildWebhookHandlerArgs',
    'DestinationCustomWebhookCriteriaArgs',
    'DestinationCustomWebhookHandlerArgs',
    'DestinationWebhookCriteriaArgs',
    'DestinationWebhookHandlerArgs',
    'DistributionCustomWebhookCriteriaArgs',
    'DistributionCustomWebhookHandlerArgs',
    'DistributionWebhookCriteriaArgs',
    'DistributionWebhookHandlerArgs',
    'DockerCustomWebhookCriteriaArgs',
    'DockerCustomWebhookHandlerArgs',
    'DockerWebhookCriteriaArgs',
    'DockerWebhookHandlerArgs',
    'FederatedAlpineRepositoryMemberArgs',
    'FederatedAnsibleRepositoryMemberArgs',
    'FederatedBowerRepositoryMemberArgs',
    'FederatedCargoRepositoryMemberArgs',
    'FederatedChefRepositoryMemberArgs',
    'FederatedCocoapodsRepositoryMemberArgs',
    'FederatedComposerRepositoryMemberArgs',
    'FederatedConanRepositoryMemberArgs',
    'FederatedCondaRepositoryMemberArgs',
    'FederatedCranRepositoryMemberArgs',
    'FederatedDebianRepositoryMemberArgs',
    'FederatedDockerRepositoryMemberArgs',
    'FederatedDockerV1RepositoryMemberArgs',
    'FederatedDockerV2RepositoryMemberArgs',
    'FederatedGemsRepositoryMemberArgs',
    'FederatedGenericRepositoryMemberArgs',
    'FederatedGitltfsRepositoryMemberArgs',
    'FederatedGoRepositoryMemberArgs',
    'FederatedGradleRepositoryMemberArgs',
    'FederatedHelmRepositoryMemberArgs',
    'FederatedHelmociRepositoryMemberArgs',
    'FederatedIvyRepositoryMemberArgs',
    'FederatedMavenRepositoryMemberArgs',
    'FederatedNpmRepositoryMemberArgs',
    'FederatedNugetRepositoryMemberArgs',
    'FederatedOciRepositoryMemberArgs',
    'FederatedOpkgRepositoryMemberArgs',
    'FederatedPuppetRepositoryMemberArgs',
    'FederatedPypiRepositoryMemberArgs',
    'FederatedRpmRepositoryMemberArgs',
    'FederatedSbtRepositoryMemberArgs',
    'FederatedSwiftRepositoryMemberArgs',
    'FederatedTerraformModuleRepositoryMemberArgs',
    'FederatedTerraformProviderRepositoryMemberArgs',
    'FederatedVagrantRepositoryMemberArgs',
    'LocalRepositoryMultiReplicationReplicationArgs',
    'ManagedUserPasswordPolicyArgs',
    'OauthSettingsOauthProviderArgs',
    'PackageCleanupPolicySearchCriteriaArgs',
    'PermissionTargetBuildArgs',
    'PermissionTargetBuildActionsArgs',
    'PermissionTargetBuildActionsGroupArgs',
    'PermissionTargetBuildActionsUserArgs',
    'PermissionTargetReleaseBundleArgs',
    'PermissionTargetReleaseBundleActionsArgs',
    'PermissionTargetReleaseBundleActionsGroupArgs',
    'PermissionTargetReleaseBundleActionsUserArgs',
    'PermissionTargetRepoArgs',
    'PermissionTargetRepoActionsArgs',
    'PermissionTargetRepoActionsGroupArgs',
    'PermissionTargetRepoActionsUserArgs',
    'PropertySetPropertyArgs',
    'PropertySetPropertyPredefinedValueArgs',
    'PushReplicationReplicationArgs',
    'ReleaseBundleCustomWebhookCriteriaArgs',
    'ReleaseBundleCustomWebhookHandlerArgs',
    'ReleaseBundleV2CustomWebhookCriteriaArgs',
    'ReleaseBundleV2CustomWebhookHandlerArgs',
    'ReleaseBundleV2PromotionCustomWebhookCriteriaArgs',
    'ReleaseBundleV2PromotionCustomWebhookHandlerArgs',
    'ReleaseBundleV2PromotionWebhookCriteriaArgs',
    'ReleaseBundleV2PromotionWebhookHandlerArgs',
    'ReleaseBundleV2SourceArgs',
    'ReleaseBundleV2SourceArtifactArgs',
    'ReleaseBundleV2SourceBuildArgs',
    'ReleaseBundleV2SourceReleaseBundleArgs',
    'ReleaseBundleV2WebhookCriteriaArgs',
    'ReleaseBundleV2WebhookHandlerArgs',
    'ReleaseBundleWebhookCriteriaArgs',
    'ReleaseBundleWebhookHandlerArgs',
    'RemoteAlpineRepositoryContentSynchronisationArgs',
    'RemoteAnsibleRepositoryContentSynchronisationArgs',
    'RemoteBowerRepositoryContentSynchronisationArgs',
    'RemoteCargoRepositoryContentSynchronisationArgs',
    'RemoteChefRepositoryContentSynchronisationArgs',
    'RemoteCocoapodsRepositoryContentSynchronisationArgs',
    'RemoteComposerRepositoryContentSynchronisationArgs',
    'RemoteConanRepositoryContentSynchronisationArgs',
    'RemoteCondaRepositoryContentSynchronisationArgs',
    'RemoteCranRepositoryContentSynchronisationArgs',
    'RemoteDebianRepositoryContentSynchronisationArgs',
    'RemoteDockerRepositoryContentSynchronisationArgs',
    'RemoteGemsRepositoryContentSynchronisationArgs',
    'RemoteGenericRepositoryContentSynchronisationArgs',
    'RemoteGitlfsRepositoryContentSynchronisationArgs',
    'RemoteGoRepositoryContentSynchronisationArgs',
    'RemoteGradleRepositoryContentSynchronisationArgs',
    'RemoteHelmRepositoryContentSynchronisationArgs',
    'RemoteHelmociRepositoryContentSynchronisationArgs',
    'RemoteHuggingfacemlRepositoryContentSynchronisationArgs',
    'RemoteIvyRepositoryContentSynchronisationArgs',
    'RemoteMavenRepositoryContentSynchronisationArgs',
    'RemoteNpmRepositoryContentSynchronisationArgs',
    'RemoteNugetRepositoryContentSynchronisationArgs',
    'RemoteOciRepositoryContentSynchronisationArgs',
    'RemoteOpkgRepositoryContentSynchronisationArgs',
    'RemoteP2RepositoryContentSynchronisationArgs',
    'RemotePubRepositoryContentSynchronisationArgs',
    'RemotePuppetRepositoryContentSynchronisationArgs',
    'RemotePypiRepositoryContentSynchronisationArgs',
    'RemoteRpmRepositoryContentSynchronisationArgs',
    'RemoteSbtRepositoryContentSynchronisationArgs',
    'RemoteSwiftRepositoryContentSynchronisationArgs',
    'RemoteTerraformRepositoryContentSynchronisationArgs',
    'RemoteVcsRepositoryContentSynchronisationArgs',
    'ReplicationConfigReplicationArgs',
    'UnmanagedUserPasswordPolicyArgs',
    'UserCustomWebhookHandlerArgs',
    'UserPasswordPolicyArgs',
    'UserWebhookHandlerArgs',
    'VaultConfigurationConfigArgs',
    'VaultConfigurationConfigAuthArgs',
    'VaultConfigurationConfigMountArgs',
    'GetFederatedAlpineRepositoryMemberArgs',
    'GetFederatedAnsibleRepositoryMemberArgs',
    'GetFederatedBowerRepositoryMemberArgs',
    'GetFederatedCargoRepositoryMemberArgs',
    'GetFederatedChefRepositoryMemberArgs',
    'GetFederatedCocoapodsRepositoryMemberArgs',
    'GetFederatedComposerRepositoryMemberArgs',
    'GetFederatedConanRepositoryMemberArgs',
    'GetFederatedCondaRepositoryMemberArgs',
    'GetFederatedCranRepositoryMemberArgs',
    'GetFederatedDebianRepositoryMemberArgs',
    'GetFederatedDockerRepositoryMemberArgs',
    'GetFederatedDockerV1RepositoryMemberArgs',
    'GetFederatedDockerV2RepositoryMemberArgs',
    'GetFederatedGemsRepositoryMemberArgs',
    'GetFederatedGenericRepositoryMemberArgs',
    'GetFederatedGitlfsRepositoryMemberArgs',
    'GetFederatedGoRepositoryMemberArgs',
    'GetFederatedGradleRepositoryMemberArgs',
    'GetFederatedHelmRepositoryMemberArgs',
    'GetFederatedHelmociRepositoryMemberArgs',
    'GetFederatedIvyRepositoryMemberArgs',
    'GetFederatedMavenRepositoryMemberArgs',
    'GetFederatedNpmRepositoryMemberArgs',
    'GetFederatedNugetRepositoryMemberArgs',
    'GetFederatedOciRepositoryMemberArgs',
    'GetFederatedOpkgRepositoryMemberArgs',
    'GetFederatedPuppetRepositoryMemberArgs',
    'GetFederatedPypiRepositoryMemberArgs',
    'GetFederatedRpmRepositoryMemberArgs',
    'GetFederatedSbtRepositoryMemberArgs',
    'GetFederatedSwiftRepositoryMemberArgs',
    'GetFederatedTerraformModuleRepositoryMemberArgs',
    'GetFederatedTerraformProviderRepositoryMemberArgs',
    'GetFederatedVagrantRepositoryMemberArgs',
    'GetPermissionTargetBuildArgs',
    'GetPermissionTargetBuildActionsArgs',
    'GetPermissionTargetBuildActionsGroupArgs',
    'GetPermissionTargetBuildActionsUserArgs',
    'GetPermissionTargetReleaseBundleArgs',
    'GetPermissionTargetReleaseBundleActionsArgs',
    'GetPermissionTargetReleaseBundleActionsGroupArgs',
    'GetPermissionTargetReleaseBundleActionsUserArgs',
    'GetPermissionTargetRepoArgs',
    'GetPermissionTargetRepoActionsArgs',
    'GetPermissionTargetRepoActionsGroupArgs',
    'GetPermissionTargetRepoActionsUserArgs',
    'GetRemoteAlpineRepositoryContentSynchronisationArgs',
    'GetRemoteAnsibleRepositoryContentSynchronisationArgs',
    'GetRemoteBowerRepositoryContentSynchronisationArgs',
    'GetRemoteCargoRepositoryContentSynchronisationArgs',
    'GetRemoteChefRepositoryContentSynchronisationArgs',
    'GetRemoteCocoapodsRepositoryContentSynchronisationArgs',
    'GetRemoteComposerRepositoryContentSynchronisationArgs',
    'GetRemoteConanRepositoryContentSynchronisationArgs',
    'GetRemoteCondaRepositoryContentSynchronisationArgs',
    'GetRemoteCranRepositoryContentSynchronisationArgs',
    'GetRemoteDebianRepositoryContentSynchronisationArgs',
    'GetRemoteDockerRepositoryContentSynchronisationArgs',
    'GetRemoteGemsRepositoryContentSynchronisationArgs',
    'GetRemoteGenericRepositoryContentSynchronisationArgs',
    'GetRemoteGitlfsRepositoryContentSynchronisationArgs',
    'GetRemoteGoRepositoryContentSynchronisationArgs',
    'GetRemoteGradleRepositoryContentSynchronisationArgs',
    'GetRemoteHelmRepositoryContentSynchronisationArgs',
    'GetRemoteHelmociRepositoryContentSynchronisationArgs',
    'GetRemoteIvyRepositoryContentSynchronisationArgs',
    'GetRemoteMavenRepositoryContentSynchronisationArgs',
    'GetRemoteNpmRepositoryContentSynchronisationArgs',
    'GetRemoteNugetRepositoryContentSynchronisationArgs',
    'GetRemoteOciRepositoryContentSynchronisationArgs',
    'GetRemoteOpkgRepositoryContentSynchronisationArgs',
    'GetRemoteP2RepositoryContentSynchronisationArgs',
    'GetRemotePubRepositoryContentSynchronisationArgs',
    'GetRemotePuppetRepositoryContentSynchronisationArgs',
    'GetRemotePypiRepositoryContentSynchronisationArgs',
    'GetRemoteRpmRepositoryContentSynchronisationArgs',
    'GetRemoteSbtRepositoryContentSynchronisationArgs',
    'GetRemoteSwiftRepositoryContentSynchronisationArgs',
    'GetRemoteTerraformRepositoryContentSynchronisationArgs',
    'GetRemoteVcsRepositoryContentSynchronisationArgs',
]

@pulumi.input_type
class AccessTokenAdminTokenArgs:
    def __init__(__self__, *,
                 instance_id: pulumi.Input[str]):
        pulumi.set(__self__, "instance_id", instance_id)

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "instance_id", value)


@pulumi.input_type
class ArtifactCustomWebhookCriteriaArgs:
    def __init__(__self__, *,
                 any_federated: pulumi.Input[bool],
                 any_local: pulumi.Input[bool],
                 any_remote: pulumi.Input[bool],
                 repo_keys: pulumi.Input[Sequence[pulumi.Input[str]]],
                 exclude_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 include_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] any_federated: Trigger on any federated repositories
        :param pulumi.Input[bool] any_local: Trigger on any local repo.
        :param pulumi.Input[bool] any_remote: Trigger on any remote repo.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] repo_keys: Trigger on this list of repo keys.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        pulumi.set(__self__, "any_federated", any_federated)
        pulumi.set(__self__, "any_local", any_local)
        pulumi.set(__self__, "any_remote", any_remote)
        pulumi.set(__self__, "repo_keys", repo_keys)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @property
    @pulumi.getter(name="anyFederated")
    def any_federated(self) -> pulumi.Input[bool]:
        """
        Trigger on any federated repositories
        """
        return pulumi.get(self, "any_federated")

    @any_federated.setter
    def any_federated(self, value: pulumi.Input[bool]):
        pulumi.set(self, "any_federated", value)

    @property
    @pulumi.getter(name="anyLocal")
    def any_local(self) -> pulumi.Input[bool]:
        """
        Trigger on any local repo.
        """
        return pulumi.get(self, "any_local")

    @any_local.setter
    def any_local(self, value: pulumi.Input[bool]):
        pulumi.set(self, "any_local", value)

    @property
    @pulumi.getter(name="anyRemote")
    def any_remote(self) -> pulumi.Input[bool]:
        """
        Trigger on any remote repo.
        """
        return pulumi.get(self, "any_remote")

    @any_remote.setter
    def any_remote(self, value: pulumi.Input[bool]):
        pulumi.set(self, "any_remote", value)

    @property
    @pulumi.getter(name="repoKeys")
    def repo_keys(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Trigger on this list of repo keys.
        """
        return pulumi.get(self, "repo_keys")

    @repo_keys.setter
    def repo_keys(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "repo_keys", value)

    @property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "exclude_patterns")

    @exclude_patterns.setter
    def exclude_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_patterns", value)

    @property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "include_patterns")

    @include_patterns.setter
    def include_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "include_patterns", value)


@pulumi.input_type
class ArtifactCustomWebhookHandlerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 payload: Optional[pulumi.Input[str]] = None,
                 proxy: Optional[pulumi.Input[str]] = None,
                 secrets: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] http_headers: HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        :param pulumi.Input[str] payload: This attribute is used to build the request body. Used in custom webhooks
        :param pulumi.Input[str] proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] secrets: Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example: 
        """
        pulumi.set(__self__, "url", url)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        """
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "http_headers", value)

    @property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[str]]:
        """
        This attribute is used to build the request body. Used in custom webhooks
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "payload", value)

    @property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[str]]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy", value)

    @property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example: 
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "secrets", value)


@pulumi.input_type
class ArtifactLifecycleCustomWebhookHandlerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 payload: Optional[pulumi.Input[str]] = None,
                 proxy: Optional[pulumi.Input[str]] = None,
                 secrets: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] http_headers: HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        :param pulumi.Input[str] payload: This attribute is used to build the request body. Used in custom webhooks
        :param pulumi.Input[str] proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] secrets: Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
        pulumi.set(__self__, "url", url)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        """
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "http_headers", value)

    @property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[str]]:
        """
        This attribute is used to build the request body. Used in custom webhooks
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "payload", value)

    @property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[str]]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy", value)

    @property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "secrets", value)


@pulumi.input_type
class ArtifactLifecycleWebhookHandlerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 custom_http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 proxy: Optional[pulumi.Input[str]] = None,
                 secret: Optional[pulumi.Input[str]] = None,
                 use_secret_for_signing: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] custom_http_headers: Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        :param pulumi.Input[str] proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param pulumi.Input[str] secret: Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        :param pulumi.Input[bool] use_secret_for_signing: When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        pulumi.set(__self__, "url", url)
        if custom_http_headers is not None:
            pulumi.set(__self__, "custom_http_headers", custom_http_headers)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if use_secret_for_signing is not None:
            pulumi.set(__self__, "use_secret_for_signing", use_secret_for_signing)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="customHttpHeaders")
    def custom_http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        return pulumi.get(self, "custom_http_headers")

    @custom_http_headers.setter
    def custom_http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "custom_http_headers", value)

    @property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[str]]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy", value)

    @property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[str]]:
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret", value)

    @property
    @pulumi.getter(name="useSecretForSigning")
    def use_secret_for_signing(self) -> Optional[pulumi.Input[bool]]:
        """
        When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        return pulumi.get(self, "use_secret_for_signing")

    @use_secret_for_signing.setter
    def use_secret_for_signing(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_secret_for_signing", value)


@pulumi.input_type
class ArtifactPropertyCustomWebhookCriteriaArgs:
    def __init__(__self__, *,
                 any_federated: pulumi.Input[bool],
                 any_local: pulumi.Input[bool],
                 any_remote: pulumi.Input[bool],
                 repo_keys: pulumi.Input[Sequence[pulumi.Input[str]]],
                 exclude_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 include_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] any_federated: Trigger on any federated repositories
        :param pulumi.Input[bool] any_local: Trigger on any local repo.
        :param pulumi.Input[bool] any_remote: Trigger on any remote repo.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] repo_keys: Trigger on this list of repo keys.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        pulumi.set(__self__, "any_federated", any_federated)
        pulumi.set(__self__, "any_local", any_local)
        pulumi.set(__self__, "any_remote", any_remote)
        pulumi.set(__self__, "repo_keys", repo_keys)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @property
    @pulumi.getter(name="anyFederated")
    def any_federated(self) -> pulumi.Input[bool]:
        """
        Trigger on any federated repositories
        """
        return pulumi.get(self, "any_federated")

    @any_federated.setter
    def any_federated(self, value: pulumi.Input[bool]):
        pulumi.set(self, "any_federated", value)

    @property
    @pulumi.getter(name="anyLocal")
    def any_local(self) -> pulumi.Input[bool]:
        """
        Trigger on any local repo.
        """
        return pulumi.get(self, "any_local")

    @any_local.setter
    def any_local(self, value: pulumi.Input[bool]):
        pulumi.set(self, "any_local", value)

    @property
    @pulumi.getter(name="anyRemote")
    def any_remote(self) -> pulumi.Input[bool]:
        """
        Trigger on any remote repo.
        """
        return pulumi.get(self, "any_remote")

    @any_remote.setter
    def any_remote(self, value: pulumi.Input[bool]):
        pulumi.set(self, "any_remote", value)

    @property
    @pulumi.getter(name="repoKeys")
    def repo_keys(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Trigger on this list of repo keys.
        """
        return pulumi.get(self, "repo_keys")

    @repo_keys.setter
    def repo_keys(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "repo_keys", value)

    @property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "exclude_patterns")

    @exclude_patterns.setter
    def exclude_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_patterns", value)

    @property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "include_patterns")

    @include_patterns.setter
    def include_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "include_patterns", value)


@pulumi.input_type
class ArtifactPropertyCustomWebhookHandlerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 payload: Optional[pulumi.Input[str]] = None,
                 proxy: Optional[pulumi.Input[str]] = None,
                 secrets: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] http_headers: HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        :param pulumi.Input[str] payload: This attribute is used to build the request body. Used in custom webhooks
        :param pulumi.Input[str] proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] secrets: Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
        pulumi.set(__self__, "url", url)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        """
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "http_headers", value)

    @property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[str]]:
        """
        This attribute is used to build the request body. Used in custom webhooks
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "payload", value)

    @property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[str]]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy", value)

    @property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "secrets", value)


@pulumi.input_type
class ArtifactPropertyWebhookCriteriaArgs:
    def __init__(__self__, *,
                 any_federated: pulumi.Input[bool],
                 any_local: pulumi.Input[bool],
                 any_remote: pulumi.Input[bool],
                 repo_keys: pulumi.Input[Sequence[pulumi.Input[str]]],
                 exclude_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 include_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] any_federated: Trigger on any federated repo.
        :param pulumi.Input[bool] any_local: Trigger on any local repo.
        :param pulumi.Input[bool] any_remote: Trigger on any remote repo.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] repo_keys: Trigger on this list of repo keys.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        pulumi.set(__self__, "any_federated", any_federated)
        pulumi.set(__self__, "any_local", any_local)
        pulumi.set(__self__, "any_remote", any_remote)
        pulumi.set(__self__, "repo_keys", repo_keys)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @property
    @pulumi.getter(name="anyFederated")
    def any_federated(self) -> pulumi.Input[bool]:
        """
        Trigger on any federated repo.
        """
        return pulumi.get(self, "any_federated")

    @any_federated.setter
    def any_federated(self, value: pulumi.Input[bool]):
        pulumi.set(self, "any_federated", value)

    @property
    @pulumi.getter(name="anyLocal")
    def any_local(self) -> pulumi.Input[bool]:
        """
        Trigger on any local repo.
        """
        return pulumi.get(self, "any_local")

    @any_local.setter
    def any_local(self, value: pulumi.Input[bool]):
        pulumi.set(self, "any_local", value)

    @property
    @pulumi.getter(name="anyRemote")
    def any_remote(self) -> pulumi.Input[bool]:
        """
        Trigger on any remote repo.
        """
        return pulumi.get(self, "any_remote")

    @any_remote.setter
    def any_remote(self, value: pulumi.Input[bool]):
        pulumi.set(self, "any_remote", value)

    @property
    @pulumi.getter(name="repoKeys")
    def repo_keys(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Trigger on this list of repo keys.
        """
        return pulumi.get(self, "repo_keys")

    @repo_keys.setter
    def repo_keys(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "repo_keys", value)

    @property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "exclude_patterns")

    @exclude_patterns.setter
    def exclude_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_patterns", value)

    @property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "include_patterns")

    @include_patterns.setter
    def include_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "include_patterns", value)


@pulumi.input_type
class ArtifactPropertyWebhookHandlerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 custom_http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 proxy: Optional[pulumi.Input[str]] = None,
                 secret: Optional[pulumi.Input[str]] = None,
                 use_secret_for_signing: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] custom_http_headers: Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        :param pulumi.Input[str] proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param pulumi.Input[str] secret: Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        :param pulumi.Input[bool] use_secret_for_signing: When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        pulumi.set(__self__, "url", url)
        if custom_http_headers is not None:
            pulumi.set(__self__, "custom_http_headers", custom_http_headers)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if use_secret_for_signing is not None:
            pulumi.set(__self__, "use_secret_for_signing", use_secret_for_signing)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="customHttpHeaders")
    def custom_http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        return pulumi.get(self, "custom_http_headers")

    @custom_http_headers.setter
    def custom_http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "custom_http_headers", value)

    @property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[str]]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy", value)

    @property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[str]]:
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret", value)

    @property
    @pulumi.getter(name="useSecretForSigning")
    def use_secret_for_signing(self) -> Optional[pulumi.Input[bool]]:
        """
        When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        return pulumi.get(self, "use_secret_for_signing")

    @use_secret_for_signing.setter
    def use_secret_for_signing(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_secret_for_signing", value)


@pulumi.input_type
class ArtifactWebhookCriteriaArgs:
    def __init__(__self__, *,
                 any_federated: pulumi.Input[bool],
                 any_local: pulumi.Input[bool],
                 any_remote: pulumi.Input[bool],
                 repo_keys: pulumi.Input[Sequence[pulumi.Input[str]]],
                 exclude_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 include_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] any_federated: Trigger on any federated repo.
        :param pulumi.Input[bool] any_local: Trigger on any local repo.
        :param pulumi.Input[bool] any_remote: Trigger on any remote repo.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] repo_keys: Trigger on this list of repo keys.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        pulumi.set(__self__, "any_federated", any_federated)
        pulumi.set(__self__, "any_local", any_local)
        pulumi.set(__self__, "any_remote", any_remote)
        pulumi.set(__self__, "repo_keys", repo_keys)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @property
    @pulumi.getter(name="anyFederated")
    def any_federated(self) -> pulumi.Input[bool]:
        """
        Trigger on any federated repo.
        """
        return pulumi.get(self, "any_federated")

    @any_federated.setter
    def any_federated(self, value: pulumi.Input[bool]):
        pulumi.set(self, "any_federated", value)

    @property
    @pulumi.getter(name="anyLocal")
    def any_local(self) -> pulumi.Input[bool]:
        """
        Trigger on any local repo.
        """
        return pulumi.get(self, "any_local")

    @any_local.setter
    def any_local(self, value: pulumi.Input[bool]):
        pulumi.set(self, "any_local", value)

    @property
    @pulumi.getter(name="anyRemote")
    def any_remote(self) -> pulumi.Input[bool]:
        """
        Trigger on any remote repo.
        """
        return pulumi.get(self, "any_remote")

    @any_remote.setter
    def any_remote(self, value: pulumi.Input[bool]):
        pulumi.set(self, "any_remote", value)

    @property
    @pulumi.getter(name="repoKeys")
    def repo_keys(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Trigger on this list of repo keys.
        """
        return pulumi.get(self, "repo_keys")

    @repo_keys.setter
    def repo_keys(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "repo_keys", value)

    @property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "exclude_patterns")

    @exclude_patterns.setter
    def exclude_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_patterns", value)

    @property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "include_patterns")

    @include_patterns.setter
    def include_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "include_patterns", value)


@pulumi.input_type
class ArtifactWebhookHandlerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 custom_http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 proxy: Optional[pulumi.Input[str]] = None,
                 secret: Optional[pulumi.Input[str]] = None,
                 use_secret_for_signing: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] custom_http_headers: Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        :param pulumi.Input[str] proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param pulumi.Input[str] secret: Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        :param pulumi.Input[bool] use_secret_for_signing: When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        pulumi.set(__self__, "url", url)
        if custom_http_headers is not None:
            pulumi.set(__self__, "custom_http_headers", custom_http_headers)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if use_secret_for_signing is not None:
            pulumi.set(__self__, "use_secret_for_signing", use_secret_for_signing)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="customHttpHeaders")
    def custom_http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        return pulumi.get(self, "custom_http_headers")

    @custom_http_headers.setter
    def custom_http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "custom_http_headers", value)

    @property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[str]]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy", value)

    @property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[str]]:
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret", value)

    @property
    @pulumi.getter(name="useSecretForSigning")
    def use_secret_for_signing(self) -> Optional[pulumi.Input[bool]]:
        """
        When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        return pulumi.get(self, "use_secret_for_signing")

    @use_secret_for_signing.setter
    def use_secret_for_signing(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_secret_for_signing", value)


@pulumi.input_type
class ArtifactoryReleaseBundleCustomWebhookCriteriaArgs:
    def __init__(__self__, *,
                 any_release_bundle: pulumi.Input[bool],
                 registered_release_bundle_names: pulumi.Input[Sequence[pulumi.Input[str]]],
                 exclude_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 include_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] any_release_bundle: Trigger on any release bundle
        :param pulumi.Input[Sequence[pulumi.Input[str]]] registered_release_bundle_names: Trigger on this list of release bundle names
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`
        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`
        """
        pulumi.set(__self__, "any_release_bundle", any_release_bundle)
        pulumi.set(__self__, "registered_release_bundle_names", registered_release_bundle_names)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @property
    @pulumi.getter(name="anyReleaseBundle")
    def any_release_bundle(self) -> pulumi.Input[bool]:
        """
        Trigger on any release bundle
        """
        return pulumi.get(self, "any_release_bundle")

    @any_release_bundle.setter
    def any_release_bundle(self, value: pulumi.Input[bool]):
        pulumi.set(self, "any_release_bundle", value)

    @property
    @pulumi.getter(name="registeredReleaseBundleNames")
    def registered_release_bundle_names(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Trigger on this list of release bundle names
        """
        return pulumi.get(self, "registered_release_bundle_names")

    @registered_release_bundle_names.setter
    def registered_release_bundle_names(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "registered_release_bundle_names", value)

    @property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`
        """
        return pulumi.get(self, "exclude_patterns")

    @exclude_patterns.setter
    def exclude_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_patterns", value)

    @property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`
        """
        return pulumi.get(self, "include_patterns")

    @include_patterns.setter
    def include_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "include_patterns", value)


@pulumi.input_type
class ArtifactoryReleaseBundleCustomWebhookHandlerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 payload: Optional[pulumi.Input[str]] = None,
                 proxy: Optional[pulumi.Input[str]] = None,
                 secrets: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] http_headers: HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        :param pulumi.Input[str] payload: This attribute is used to build the request body. Used in custom webhooks
        :param pulumi.Input[str] proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] secrets: Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
        pulumi.set(__self__, "url", url)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        """
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "http_headers", value)

    @property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[str]]:
        """
        This attribute is used to build the request body. Used in custom webhooks
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "payload", value)

    @property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[str]]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy", value)

    @property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "secrets", value)


@pulumi.input_type
class ArtifactoryReleaseBundleWebhookCriteriaArgs:
    def __init__(__self__, *,
                 any_release_bundle: pulumi.Input[bool],
                 registered_release_bundle_names: pulumi.Input[Sequence[pulumi.Input[str]]],
                 exclude_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 include_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] any_release_bundle: Trigger on any release bundle
        :param pulumi.Input[Sequence[pulumi.Input[str]]] registered_release_bundle_names: Trigger on this list of release bundle names
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`
        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`
        """
        pulumi.set(__self__, "any_release_bundle", any_release_bundle)
        pulumi.set(__self__, "registered_release_bundle_names", registered_release_bundle_names)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @property
    @pulumi.getter(name="anyReleaseBundle")
    def any_release_bundle(self) -> pulumi.Input[bool]:
        """
        Trigger on any release bundle
        """
        return pulumi.get(self, "any_release_bundle")

    @any_release_bundle.setter
    def any_release_bundle(self, value: pulumi.Input[bool]):
        pulumi.set(self, "any_release_bundle", value)

    @property
    @pulumi.getter(name="registeredReleaseBundleNames")
    def registered_release_bundle_names(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Trigger on this list of release bundle names
        """
        return pulumi.get(self, "registered_release_bundle_names")

    @registered_release_bundle_names.setter
    def registered_release_bundle_names(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "registered_release_bundle_names", value)

    @property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`
        """
        return pulumi.get(self, "exclude_patterns")

    @exclude_patterns.setter
    def exclude_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_patterns", value)

    @property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`
        """
        return pulumi.get(self, "include_patterns")

    @include_patterns.setter
    def include_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "include_patterns", value)


@pulumi.input_type
class ArtifactoryReleaseBundleWebhookHandlerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 custom_http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 proxy: Optional[pulumi.Input[str]] = None,
                 secret: Optional[pulumi.Input[str]] = None,
                 use_secret_for_signing: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] custom_http_headers: Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        :param pulumi.Input[str] proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param pulumi.Input[str] secret: Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        :param pulumi.Input[bool] use_secret_for_signing: When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        pulumi.set(__self__, "url", url)
        if custom_http_headers is not None:
            pulumi.set(__self__, "custom_http_headers", custom_http_headers)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if use_secret_for_signing is not None:
            pulumi.set(__self__, "use_secret_for_signing", use_secret_for_signing)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="customHttpHeaders")
    def custom_http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        return pulumi.get(self, "custom_http_headers")

    @custom_http_headers.setter
    def custom_http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "custom_http_headers", value)

    @property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[str]]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy", value)

    @property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[str]]:
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret", value)

    @property
    @pulumi.getter(name="useSecretForSigning")
    def use_secret_for_signing(self) -> Optional[pulumi.Input[bool]]:
        """
        When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        return pulumi.get(self, "use_secret_for_signing")

    @use_secret_for_signing.setter
    def use_secret_for_signing(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_secret_for_signing", value)


@pulumi.input_type
class BuildCustomWebhookCriteriaArgs:
    def __init__(__self__, *,
                 any_build: pulumi.Input[bool],
                 selected_builds: pulumi.Input[Sequence[pulumi.Input[str]]],
                 exclude_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 include_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] any_build: Trigger on any build.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] selected_builds: Trigger on this list of build names.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        pulumi.set(__self__, "any_build", any_build)
        pulumi.set(__self__, "selected_builds", selected_builds)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @property
    @pulumi.getter(name="anyBuild")
    def any_build(self) -> pulumi.Input[bool]:
        """
        Trigger on any build.
        """
        return pulumi.get(self, "any_build")

    @any_build.setter
    def any_build(self, value: pulumi.Input[bool]):
        pulumi.set(self, "any_build", value)

    @property
    @pulumi.getter(name="selectedBuilds")
    def selected_builds(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Trigger on this list of build names.
        """
        return pulumi.get(self, "selected_builds")

    @selected_builds.setter
    def selected_builds(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "selected_builds", value)

    @property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "exclude_patterns")

    @exclude_patterns.setter
    def exclude_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_patterns", value)

    @property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "include_patterns")

    @include_patterns.setter
    def include_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "include_patterns", value)


@pulumi.input_type
class BuildCustomWebhookHandlerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 payload: Optional[pulumi.Input[str]] = None,
                 proxy: Optional[pulumi.Input[str]] = None,
                 secrets: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] http_headers: HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        :param pulumi.Input[str] payload: This attribute is used to build the request body. Used in custom webhooks
        :param pulumi.Input[str] proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] secrets: Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
        pulumi.set(__self__, "url", url)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        """
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "http_headers", value)

    @property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[str]]:
        """
        This attribute is used to build the request body. Used in custom webhooks
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "payload", value)

    @property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[str]]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy", value)

    @property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "secrets", value)


@pulumi.input_type
class BuildWebhookCriteriaArgs:
    def __init__(__self__, *,
                 any_build: pulumi.Input[bool],
                 selected_builds: pulumi.Input[Sequence[pulumi.Input[str]]],
                 exclude_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 include_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] any_build: Trigger on any build.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] selected_builds: Trigger on this list of build names.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        pulumi.set(__self__, "any_build", any_build)
        pulumi.set(__self__, "selected_builds", selected_builds)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @property
    @pulumi.getter(name="anyBuild")
    def any_build(self) -> pulumi.Input[bool]:
        """
        Trigger on any build.
        """
        return pulumi.get(self, "any_build")

    @any_build.setter
    def any_build(self, value: pulumi.Input[bool]):
        pulumi.set(self, "any_build", value)

    @property
    @pulumi.getter(name="selectedBuilds")
    def selected_builds(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Trigger on this list of build names.
        """
        return pulumi.get(self, "selected_builds")

    @selected_builds.setter
    def selected_builds(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "selected_builds", value)

    @property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "exclude_patterns")

    @exclude_patterns.setter
    def exclude_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_patterns", value)

    @property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "include_patterns")

    @include_patterns.setter
    def include_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "include_patterns", value)


@pulumi.input_type
class BuildWebhookHandlerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 custom_http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 proxy: Optional[pulumi.Input[str]] = None,
                 secret: Optional[pulumi.Input[str]] = None,
                 use_secret_for_signing: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] custom_http_headers: Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        :param pulumi.Input[str] proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param pulumi.Input[str] secret: Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        :param pulumi.Input[bool] use_secret_for_signing: When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        pulumi.set(__self__, "url", url)
        if custom_http_headers is not None:
            pulumi.set(__self__, "custom_http_headers", custom_http_headers)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if use_secret_for_signing is not None:
            pulumi.set(__self__, "use_secret_for_signing", use_secret_for_signing)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="customHttpHeaders")
    def custom_http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        return pulumi.get(self, "custom_http_headers")

    @custom_http_headers.setter
    def custom_http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "custom_http_headers", value)

    @property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[str]]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy", value)

    @property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[str]]:
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret", value)

    @property
    @pulumi.getter(name="useSecretForSigning")
    def use_secret_for_signing(self) -> Optional[pulumi.Input[bool]]:
        """
        When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        return pulumi.get(self, "use_secret_for_signing")

    @use_secret_for_signing.setter
    def use_secret_for_signing(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_secret_for_signing", value)


@pulumi.input_type
class DestinationCustomWebhookCriteriaArgs:
    def __init__(__self__, *,
                 any_release_bundle: pulumi.Input[bool],
                 registered_release_bundle_names: pulumi.Input[Sequence[pulumi.Input[str]]],
                 exclude_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 include_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] any_release_bundle: Trigger on any release bundle
        :param pulumi.Input[Sequence[pulumi.Input[str]]] registered_release_bundle_names: Trigger on this list of release bundle names
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`
        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`
        """
        pulumi.set(__self__, "any_release_bundle", any_release_bundle)
        pulumi.set(__self__, "registered_release_bundle_names", registered_release_bundle_names)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @property
    @pulumi.getter(name="anyReleaseBundle")
    def any_release_bundle(self) -> pulumi.Input[bool]:
        """
        Trigger on any release bundle
        """
        return pulumi.get(self, "any_release_bundle")

    @any_release_bundle.setter
    def any_release_bundle(self, value: pulumi.Input[bool]):
        pulumi.set(self, "any_release_bundle", value)

    @property
    @pulumi.getter(name="registeredReleaseBundleNames")
    def registered_release_bundle_names(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Trigger on this list of release bundle names
        """
        return pulumi.get(self, "registered_release_bundle_names")

    @registered_release_bundle_names.setter
    def registered_release_bundle_names(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "registered_release_bundle_names", value)

    @property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`
        """
        return pulumi.get(self, "exclude_patterns")

    @exclude_patterns.setter
    def exclude_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_patterns", value)

    @property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`
        """
        return pulumi.get(self, "include_patterns")

    @include_patterns.setter
    def include_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "include_patterns", value)


@pulumi.input_type
class DestinationCustomWebhookHandlerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 payload: Optional[pulumi.Input[str]] = None,
                 proxy: Optional[pulumi.Input[str]] = None,
                 secrets: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] http_headers: HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        :param pulumi.Input[str] payload: This attribute is used to build the request body. Used in custom webhooks
        :param pulumi.Input[str] proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] secrets: Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
        pulumi.set(__self__, "url", url)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        """
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "http_headers", value)

    @property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[str]]:
        """
        This attribute is used to build the request body. Used in custom webhooks
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "payload", value)

    @property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[str]]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy", value)

    @property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "secrets", value)


@pulumi.input_type
class DestinationWebhookCriteriaArgs:
    def __init__(__self__, *,
                 any_release_bundle: pulumi.Input[bool],
                 registered_release_bundle_names: pulumi.Input[Sequence[pulumi.Input[str]]],
                 exclude_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 include_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] any_release_bundle: Trigger on any release bundle
        :param pulumi.Input[Sequence[pulumi.Input[str]]] registered_release_bundle_names: Trigger on this list of release bundle names
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`
        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`
        """
        pulumi.set(__self__, "any_release_bundle", any_release_bundle)
        pulumi.set(__self__, "registered_release_bundle_names", registered_release_bundle_names)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @property
    @pulumi.getter(name="anyReleaseBundle")
    def any_release_bundle(self) -> pulumi.Input[bool]:
        """
        Trigger on any release bundle
        """
        return pulumi.get(self, "any_release_bundle")

    @any_release_bundle.setter
    def any_release_bundle(self, value: pulumi.Input[bool]):
        pulumi.set(self, "any_release_bundle", value)

    @property
    @pulumi.getter(name="registeredReleaseBundleNames")
    def registered_release_bundle_names(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Trigger on this list of release bundle names
        """
        return pulumi.get(self, "registered_release_bundle_names")

    @registered_release_bundle_names.setter
    def registered_release_bundle_names(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "registered_release_bundle_names", value)

    @property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`
        """
        return pulumi.get(self, "exclude_patterns")

    @exclude_patterns.setter
    def exclude_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_patterns", value)

    @property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`
        """
        return pulumi.get(self, "include_patterns")

    @include_patterns.setter
    def include_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "include_patterns", value)


@pulumi.input_type
class DestinationWebhookHandlerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 custom_http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 proxy: Optional[pulumi.Input[str]] = None,
                 secret: Optional[pulumi.Input[str]] = None,
                 use_secret_for_signing: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] custom_http_headers: Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        :param pulumi.Input[str] proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param pulumi.Input[str] secret: Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        :param pulumi.Input[bool] use_secret_for_signing: When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        pulumi.set(__self__, "url", url)
        if custom_http_headers is not None:
            pulumi.set(__self__, "custom_http_headers", custom_http_headers)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if use_secret_for_signing is not None:
            pulumi.set(__self__, "use_secret_for_signing", use_secret_for_signing)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="customHttpHeaders")
    def custom_http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        return pulumi.get(self, "custom_http_headers")

    @custom_http_headers.setter
    def custom_http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "custom_http_headers", value)

    @property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[str]]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy", value)

    @property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[str]]:
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret", value)

    @property
    @pulumi.getter(name="useSecretForSigning")
    def use_secret_for_signing(self) -> Optional[pulumi.Input[bool]]:
        """
        When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        return pulumi.get(self, "use_secret_for_signing")

    @use_secret_for_signing.setter
    def use_secret_for_signing(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_secret_for_signing", value)


@pulumi.input_type
class DistributionCustomWebhookCriteriaArgs:
    def __init__(__self__, *,
                 any_release_bundle: pulumi.Input[bool],
                 registered_release_bundle_names: pulumi.Input[Sequence[pulumi.Input[str]]],
                 exclude_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 include_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] any_release_bundle: Trigger on any release bundle.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] registered_release_bundle_names: Trigger on this list of release bundle names.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        pulumi.set(__self__, "any_release_bundle", any_release_bundle)
        pulumi.set(__self__, "registered_release_bundle_names", registered_release_bundle_names)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @property
    @pulumi.getter(name="anyReleaseBundle")
    def any_release_bundle(self) -> pulumi.Input[bool]:
        """
        Trigger on any release bundle.
        """
        return pulumi.get(self, "any_release_bundle")

    @any_release_bundle.setter
    def any_release_bundle(self, value: pulumi.Input[bool]):
        pulumi.set(self, "any_release_bundle", value)

    @property
    @pulumi.getter(name="registeredReleaseBundleNames")
    def registered_release_bundle_names(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Trigger on this list of release bundle names.
        """
        return pulumi.get(self, "registered_release_bundle_names")

    @registered_release_bundle_names.setter
    def registered_release_bundle_names(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "registered_release_bundle_names", value)

    @property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "exclude_patterns")

    @exclude_patterns.setter
    def exclude_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_patterns", value)

    @property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "include_patterns")

    @include_patterns.setter
    def include_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "include_patterns", value)


@pulumi.input_type
class DistributionCustomWebhookHandlerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 payload: Optional[pulumi.Input[str]] = None,
                 proxy: Optional[pulumi.Input[str]] = None,
                 secrets: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] http_headers: HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        :param pulumi.Input[str] payload: This attribute is used to build the request body. Used in custom webhooks
        :param pulumi.Input[str] proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] secrets: Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
        pulumi.set(__self__, "url", url)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        """
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "http_headers", value)

    @property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[str]]:
        """
        This attribute is used to build the request body. Used in custom webhooks
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "payload", value)

    @property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[str]]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy", value)

    @property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "secrets", value)


@pulumi.input_type
class DistributionWebhookCriteriaArgs:
    def __init__(__self__, *,
                 any_release_bundle: pulumi.Input[bool],
                 registered_release_bundle_names: pulumi.Input[Sequence[pulumi.Input[str]]],
                 exclude_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 include_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] any_release_bundle: Trigger on any release bundle.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] registered_release_bundle_names: Trigger on this list of release bundle names.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        pulumi.set(__self__, "any_release_bundle", any_release_bundle)
        pulumi.set(__self__, "registered_release_bundle_names", registered_release_bundle_names)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @property
    @pulumi.getter(name="anyReleaseBundle")
    def any_release_bundle(self) -> pulumi.Input[bool]:
        """
        Trigger on any release bundle.
        """
        return pulumi.get(self, "any_release_bundle")

    @any_release_bundle.setter
    def any_release_bundle(self, value: pulumi.Input[bool]):
        pulumi.set(self, "any_release_bundle", value)

    @property
    @pulumi.getter(name="registeredReleaseBundleNames")
    def registered_release_bundle_names(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Trigger on this list of release bundle names.
        """
        return pulumi.get(self, "registered_release_bundle_names")

    @registered_release_bundle_names.setter
    def registered_release_bundle_names(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "registered_release_bundle_names", value)

    @property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "exclude_patterns")

    @exclude_patterns.setter
    def exclude_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_patterns", value)

    @property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "include_patterns")

    @include_patterns.setter
    def include_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "include_patterns", value)


@pulumi.input_type
class DistributionWebhookHandlerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 custom_http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 proxy: Optional[pulumi.Input[str]] = None,
                 secret: Optional[pulumi.Input[str]] = None,
                 use_secret_for_signing: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] custom_http_headers: Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        :param pulumi.Input[str] proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param pulumi.Input[str] secret: Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        :param pulumi.Input[bool] use_secret_for_signing: When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        pulumi.set(__self__, "url", url)
        if custom_http_headers is not None:
            pulumi.set(__self__, "custom_http_headers", custom_http_headers)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if use_secret_for_signing is not None:
            pulumi.set(__self__, "use_secret_for_signing", use_secret_for_signing)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="customHttpHeaders")
    def custom_http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        return pulumi.get(self, "custom_http_headers")

    @custom_http_headers.setter
    def custom_http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "custom_http_headers", value)

    @property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[str]]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy", value)

    @property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[str]]:
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret", value)

    @property
    @pulumi.getter(name="useSecretForSigning")
    def use_secret_for_signing(self) -> Optional[pulumi.Input[bool]]:
        """
        When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        return pulumi.get(self, "use_secret_for_signing")

    @use_secret_for_signing.setter
    def use_secret_for_signing(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_secret_for_signing", value)


@pulumi.input_type
class DockerCustomWebhookCriteriaArgs:
    def __init__(__self__, *,
                 any_federated: pulumi.Input[bool],
                 any_local: pulumi.Input[bool],
                 any_remote: pulumi.Input[bool],
                 repo_keys: pulumi.Input[Sequence[pulumi.Input[str]]],
                 exclude_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 include_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] any_federated: Trigger on any federated repositories
        :param pulumi.Input[bool] any_local: Trigger on any local repo.
        :param pulumi.Input[bool] any_remote: Trigger on any remote repo.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] repo_keys: Trigger on this list of repo keys.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        pulumi.set(__self__, "any_federated", any_federated)
        pulumi.set(__self__, "any_local", any_local)
        pulumi.set(__self__, "any_remote", any_remote)
        pulumi.set(__self__, "repo_keys", repo_keys)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @property
    @pulumi.getter(name="anyFederated")
    def any_federated(self) -> pulumi.Input[bool]:
        """
        Trigger on any federated repositories
        """
        return pulumi.get(self, "any_federated")

    @any_federated.setter
    def any_federated(self, value: pulumi.Input[bool]):
        pulumi.set(self, "any_federated", value)

    @property
    @pulumi.getter(name="anyLocal")
    def any_local(self) -> pulumi.Input[bool]:
        """
        Trigger on any local repo.
        """
        return pulumi.get(self, "any_local")

    @any_local.setter
    def any_local(self, value: pulumi.Input[bool]):
        pulumi.set(self, "any_local", value)

    @property
    @pulumi.getter(name="anyRemote")
    def any_remote(self) -> pulumi.Input[bool]:
        """
        Trigger on any remote repo.
        """
        return pulumi.get(self, "any_remote")

    @any_remote.setter
    def any_remote(self, value: pulumi.Input[bool]):
        pulumi.set(self, "any_remote", value)

    @property
    @pulumi.getter(name="repoKeys")
    def repo_keys(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Trigger on this list of repo keys.
        """
        return pulumi.get(self, "repo_keys")

    @repo_keys.setter
    def repo_keys(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "repo_keys", value)

    @property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "exclude_patterns")

    @exclude_patterns.setter
    def exclude_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_patterns", value)

    @property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "include_patterns")

    @include_patterns.setter
    def include_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "include_patterns", value)


@pulumi.input_type
class DockerCustomWebhookHandlerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 payload: Optional[pulumi.Input[str]] = None,
                 proxy: Optional[pulumi.Input[str]] = None,
                 secrets: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] http_headers: HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        :param pulumi.Input[str] payload: This attribute is used to build the request body. Used in custom webhooks
        :param pulumi.Input[str] proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] secrets: Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
        pulumi.set(__self__, "url", url)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        """
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "http_headers", value)

    @property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[str]]:
        """
        This attribute is used to build the request body. Used in custom webhooks
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "payload", value)

    @property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[str]]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy", value)

    @property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "secrets", value)


@pulumi.input_type
class DockerWebhookCriteriaArgs:
    def __init__(__self__, *,
                 any_federated: pulumi.Input[bool],
                 any_local: pulumi.Input[bool],
                 any_remote: pulumi.Input[bool],
                 repo_keys: pulumi.Input[Sequence[pulumi.Input[str]]],
                 exclude_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 include_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] any_federated: Trigger on any federated repo.
        :param pulumi.Input[bool] any_local: Trigger on any local repo.
        :param pulumi.Input[bool] any_remote: Trigger on any remote repo.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] repo_keys: Trigger on this list of repo keys.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        pulumi.set(__self__, "any_federated", any_federated)
        pulumi.set(__self__, "any_local", any_local)
        pulumi.set(__self__, "any_remote", any_remote)
        pulumi.set(__self__, "repo_keys", repo_keys)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @property
    @pulumi.getter(name="anyFederated")
    def any_federated(self) -> pulumi.Input[bool]:
        """
        Trigger on any federated repo.
        """
        return pulumi.get(self, "any_federated")

    @any_federated.setter
    def any_federated(self, value: pulumi.Input[bool]):
        pulumi.set(self, "any_federated", value)

    @property
    @pulumi.getter(name="anyLocal")
    def any_local(self) -> pulumi.Input[bool]:
        """
        Trigger on any local repo.
        """
        return pulumi.get(self, "any_local")

    @any_local.setter
    def any_local(self, value: pulumi.Input[bool]):
        pulumi.set(self, "any_local", value)

    @property
    @pulumi.getter(name="anyRemote")
    def any_remote(self) -> pulumi.Input[bool]:
        """
        Trigger on any remote repo.
        """
        return pulumi.get(self, "any_remote")

    @any_remote.setter
    def any_remote(self, value: pulumi.Input[bool]):
        pulumi.set(self, "any_remote", value)

    @property
    @pulumi.getter(name="repoKeys")
    def repo_keys(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Trigger on this list of repo keys.
        """
        return pulumi.get(self, "repo_keys")

    @repo_keys.setter
    def repo_keys(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "repo_keys", value)

    @property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "exclude_patterns")

    @exclude_patterns.setter
    def exclude_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_patterns", value)

    @property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "include_patterns")

    @include_patterns.setter
    def include_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "include_patterns", value)


@pulumi.input_type
class DockerWebhookHandlerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 custom_http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 proxy: Optional[pulumi.Input[str]] = None,
                 secret: Optional[pulumi.Input[str]] = None,
                 use_secret_for_signing: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] custom_http_headers: Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        :param pulumi.Input[str] proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param pulumi.Input[str] secret: Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        :param pulumi.Input[bool] use_secret_for_signing: When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        pulumi.set(__self__, "url", url)
        if custom_http_headers is not None:
            pulumi.set(__self__, "custom_http_headers", custom_http_headers)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if use_secret_for_signing is not None:
            pulumi.set(__self__, "use_secret_for_signing", use_secret_for_signing)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="customHttpHeaders")
    def custom_http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        return pulumi.get(self, "custom_http_headers")

    @custom_http_headers.setter
    def custom_http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "custom_http_headers", value)

    @property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[str]]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy", value)

    @property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[str]]:
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret", value)

    @property
    @pulumi.getter(name="useSecretForSigning")
    def use_secret_for_signing(self) -> Optional[pulumi.Input[bool]]:
        """
        When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        return pulumi.get(self, "use_secret_for_signing")

    @use_secret_for_signing.setter
    def use_secret_for_signing(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_secret_for_signing", value)


@pulumi.input_type
class FederatedAlpineRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str],
                 access_token: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        :param pulumi.Input[str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class FederatedAnsibleRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str],
                 access_token: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        :param pulumi.Input[str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class FederatedBowerRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str],
                 access_token: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        :param pulumi.Input[str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class FederatedCargoRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str],
                 access_token: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        :param pulumi.Input[str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class FederatedChefRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str],
                 access_token: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        :param pulumi.Input[str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class FederatedCocoapodsRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str],
                 access_token: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        :param pulumi.Input[str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class FederatedComposerRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str],
                 access_token: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        :param pulumi.Input[str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class FederatedConanRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str],
                 access_token: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        :param pulumi.Input[str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class FederatedCondaRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str],
                 access_token: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        :param pulumi.Input[str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class FederatedCranRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str],
                 access_token: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        :param pulumi.Input[str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class FederatedDebianRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str],
                 access_token: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        :param pulumi.Input[str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class FederatedDockerRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str],
                 access_token: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        :param pulumi.Input[str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class FederatedDockerV1RepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str],
                 access_token: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        :param pulumi.Input[str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class FederatedDockerV2RepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str],
                 access_token: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        :param pulumi.Input[str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class FederatedGemsRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str],
                 access_token: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        :param pulumi.Input[str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class FederatedGenericRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str],
                 access_token: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        :param pulumi.Input[str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class FederatedGitltfsRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str],
                 access_token: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        :param pulumi.Input[str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class FederatedGoRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str],
                 access_token: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        :param pulumi.Input[str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class FederatedGradleRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str],
                 access_token: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        :param pulumi.Input[str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class FederatedHelmRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str],
                 access_token: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        :param pulumi.Input[str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class FederatedHelmociRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str],
                 access_token: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        :param pulumi.Input[str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class FederatedIvyRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str],
                 access_token: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        :param pulumi.Input[str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class FederatedMavenRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str],
                 access_token: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        :param pulumi.Input[str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class FederatedNpmRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str],
                 access_token: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        :param pulumi.Input[str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class FederatedNugetRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str],
                 access_token: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        :param pulumi.Input[str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class FederatedOciRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str],
                 access_token: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        :param pulumi.Input[str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class FederatedOpkgRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str],
                 access_token: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        :param pulumi.Input[str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class FederatedPuppetRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str],
                 access_token: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        :param pulumi.Input[str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class FederatedPypiRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str],
                 access_token: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        :param pulumi.Input[str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class FederatedRpmRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str],
                 access_token: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        :param pulumi.Input[str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class FederatedSbtRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str],
                 access_token: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        :param pulumi.Input[str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class FederatedSwiftRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str],
                 access_token: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        :param pulumi.Input[str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class FederatedTerraformModuleRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str],
                 access_token: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        :param pulumi.Input[str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class FederatedTerraformProviderRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str],
                 access_token: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        :param pulumi.Input[str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class FederatedVagrantRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str],
                 access_token: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        :param pulumi.Input[str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class LocalRepositoryMultiReplicationReplicationArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 username: pulumi.Input[str],
                 check_binary_existence_in_filestore: Optional[pulumi.Input[bool]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 exclude_path_prefix_pattern: Optional[pulumi.Input[str]] = None,
                 include_path_prefix_pattern: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 proxy: Optional[pulumi.Input[str]] = None,
                 replication_key: Optional[pulumi.Input[str]] = None,
                 socket_timeout_millis: Optional[pulumi.Input[int]] = None,
                 sync_deletes: Optional[pulumi.Input[bool]] = None,
                 sync_properties: Optional[pulumi.Input[bool]] = None,
                 sync_statistics: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] url: The URL of the target local repository on a remote Artifactory server. Use the format `https://<artifactory_url>/artifactory/<repository_name>`.
        :param pulumi.Input[str] username: Username on the remote Artifactory instance.
        :param pulumi.Input[bool] check_binary_existence_in_filestore: Enabling the `check_binary_existence_in_filestore` flag requires an Enterprise Plus license. When true, enables distributed checksum storage. For more information, see [Optimizing Repository Replication with Checksum-Based Storage](https://www.jfrog.com/confluence/display/JFROG/Repository+Replication#RepositoryReplication-OptimizingRepositoryReplicationUsingStorageLevelSynchronizationOptions).
        :param pulumi.Input[bool] enabled: When set, enables replication of this repository to the target specified in `url` attribute. Default value is `true`.
        :param pulumi.Input[str] exclude_path_prefix_pattern: List of artifact patterns to exclude when evaluating artifact requests, in the form of `x/y/**/z/*`. By default, no artifacts are excluded.
        :param pulumi.Input[str] include_path_prefix_pattern: List of artifact patterns to include when evaluating artifact requests in the form of `x/y/**/z/*`. When used, only artifacts matching one of the include patterns are served. By default, all artifacts are included `(**/*)`.
        :param pulumi.Input[str] password: Use either the HTTP authentication password or [identity token](https://www.jfrog.com/confluence/display/JFROG/User+Profile#UserProfile-IdentityTokenidentitytoken).
        :param pulumi.Input[str] proxy: Proxy key from Artifactory Proxies settings. The proxy configuration will be used when communicating with the remote instance.
        :param pulumi.Input[str] replication_key: Replication ID, the value is unknown until the resource is created. Can't be set or updated.
        :param pulumi.Input[int] socket_timeout_millis: The network timeout in milliseconds to use for remote operations. Default value is `15000`.
        :param pulumi.Input[bool] sync_deletes: When set, items that were deleted locally should also be deleted remotely (also applies to properties metadata). Note that enabling this option, will delete artifacts on the target that do not exist in the source repository. Default value is `false`.
        :param pulumi.Input[bool] sync_properties: When set, the task also synchronizes the properties of replicated artifacts. Default value is `true`.
        :param pulumi.Input[bool] sync_statistics: When set, the task also synchronizes artifact download statistics. Set to avoid inadvertent cleanup at the target instance when setting up replication for disaster recovery. Default value is `false`
        """
        pulumi.set(__self__, "url", url)
        pulumi.set(__self__, "username", username)
        if check_binary_existence_in_filestore is not None:
            pulumi.set(__self__, "check_binary_existence_in_filestore", check_binary_existence_in_filestore)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if exclude_path_prefix_pattern is not None:
            pulumi.set(__self__, "exclude_path_prefix_pattern", exclude_path_prefix_pattern)
        if include_path_prefix_pattern is not None:
            pulumi.set(__self__, "include_path_prefix_pattern", include_path_prefix_pattern)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if replication_key is not None:
            pulumi.set(__self__, "replication_key", replication_key)
        if socket_timeout_millis is not None:
            pulumi.set(__self__, "socket_timeout_millis", socket_timeout_millis)
        if sync_deletes is not None:
            pulumi.set(__self__, "sync_deletes", sync_deletes)
        if sync_properties is not None:
            pulumi.set(__self__, "sync_properties", sync_properties)
        if sync_statistics is not None:
            pulumi.set(__self__, "sync_statistics", sync_statistics)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        The URL of the target local repository on a remote Artifactory server. Use the format `https://<artifactory_url>/artifactory/<repository_name>`.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        Username on the remote Artifactory instance.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="checkBinaryExistenceInFilestore")
    def check_binary_existence_in_filestore(self) -> Optional[pulumi.Input[bool]]:
        """
        Enabling the `check_binary_existence_in_filestore` flag requires an Enterprise Plus license. When true, enables distributed checksum storage. For more information, see [Optimizing Repository Replication with Checksum-Based Storage](https://www.jfrog.com/confluence/display/JFROG/Repository+Replication#RepositoryReplication-OptimizingRepositoryReplicationUsingStorageLevelSynchronizationOptions).
        """
        return pulumi.get(self, "check_binary_existence_in_filestore")

    @check_binary_existence_in_filestore.setter
    def check_binary_existence_in_filestore(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "check_binary_existence_in_filestore", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        When set, enables replication of this repository to the target specified in `url` attribute. Default value is `true`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="excludePathPrefixPattern")
    def exclude_path_prefix_pattern(self) -> Optional[pulumi.Input[str]]:
        """
        List of artifact patterns to exclude when evaluating artifact requests, in the form of `x/y/**/z/*`. By default, no artifacts are excluded.
        """
        return pulumi.get(self, "exclude_path_prefix_pattern")

    @exclude_path_prefix_pattern.setter
    def exclude_path_prefix_pattern(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exclude_path_prefix_pattern", value)

    @property
    @pulumi.getter(name="includePathPrefixPattern")
    def include_path_prefix_pattern(self) -> Optional[pulumi.Input[str]]:
        """
        List of artifact patterns to include when evaluating artifact requests in the form of `x/y/**/z/*`. When used, only artifacts matching one of the include patterns are served. By default, all artifacts are included `(**/*)`.
        """
        return pulumi.get(self, "include_path_prefix_pattern")

    @include_path_prefix_pattern.setter
    def include_path_prefix_pattern(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "include_path_prefix_pattern", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        Use either the HTTP authentication password or [identity token](https://www.jfrog.com/confluence/display/JFROG/User+Profile#UserProfile-IdentityTokenidentitytoken).
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[str]]:
        """
        Proxy key from Artifactory Proxies settings. The proxy configuration will be used when communicating with the remote instance.
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy", value)

    @property
    @pulumi.getter(name="replicationKey")
    def replication_key(self) -> Optional[pulumi.Input[str]]:
        """
        Replication ID, the value is unknown until the resource is created. Can't be set or updated.
        """
        return pulumi.get(self, "replication_key")

    @replication_key.setter
    def replication_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replication_key", value)

    @property
    @pulumi.getter(name="socketTimeoutMillis")
    def socket_timeout_millis(self) -> Optional[pulumi.Input[int]]:
        """
        The network timeout in milliseconds to use for remote operations. Default value is `15000`.
        """
        return pulumi.get(self, "socket_timeout_millis")

    @socket_timeout_millis.setter
    def socket_timeout_millis(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "socket_timeout_millis", value)

    @property
    @pulumi.getter(name="syncDeletes")
    def sync_deletes(self) -> Optional[pulumi.Input[bool]]:
        """
        When set, items that were deleted locally should also be deleted remotely (also applies to properties metadata). Note that enabling this option, will delete artifacts on the target that do not exist in the source repository. Default value is `false`.
        """
        return pulumi.get(self, "sync_deletes")

    @sync_deletes.setter
    def sync_deletes(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sync_deletes", value)

    @property
    @pulumi.getter(name="syncProperties")
    def sync_properties(self) -> Optional[pulumi.Input[bool]]:
        """
        When set, the task also synchronizes the properties of replicated artifacts. Default value is `true`.
        """
        return pulumi.get(self, "sync_properties")

    @sync_properties.setter
    def sync_properties(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sync_properties", value)

    @property
    @pulumi.getter(name="syncStatistics")
    def sync_statistics(self) -> Optional[pulumi.Input[bool]]:
        """
        When set, the task also synchronizes artifact download statistics. Set to avoid inadvertent cleanup at the target instance when setting up replication for disaster recovery. Default value is `false`
        """
        return pulumi.get(self, "sync_statistics")

    @sync_statistics.setter
    def sync_statistics(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sync_statistics", value)


@pulumi.input_type
class ManagedUserPasswordPolicyArgs:
    def __init__(__self__, *,
                 digit: Optional[pulumi.Input[int]] = None,
                 length: Optional[pulumi.Input[int]] = None,
                 lowercase: Optional[pulumi.Input[int]] = None,
                 special_char: Optional[pulumi.Input[int]] = None,
                 uppercase: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] digit: Minimum number of digits that the password must contain
        :param pulumi.Input[int] length: Minimum length of the password
        :param pulumi.Input[int] lowercase: Minimum number of lowercase letters that the password must contain
        :param pulumi.Input[int] special_char: Minimum number of special char that the password must contain. Special chars list: `!"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~`
        :param pulumi.Input[int] uppercase: Minimum number of uppercase letters that the password must contain
        """
        if digit is not None:
            pulumi.set(__self__, "digit", digit)
        if length is not None:
            pulumi.set(__self__, "length", length)
        if lowercase is not None:
            pulumi.set(__self__, "lowercase", lowercase)
        if special_char is not None:
            pulumi.set(__self__, "special_char", special_char)
        if uppercase is not None:
            pulumi.set(__self__, "uppercase", uppercase)

    @property
    @pulumi.getter
    def digit(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum number of digits that the password must contain
        """
        return pulumi.get(self, "digit")

    @digit.setter
    def digit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "digit", value)

    @property
    @pulumi.getter
    def length(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum length of the password
        """
        return pulumi.get(self, "length")

    @length.setter
    def length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "length", value)

    @property
    @pulumi.getter
    def lowercase(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum number of lowercase letters that the password must contain
        """
        return pulumi.get(self, "lowercase")

    @lowercase.setter
    def lowercase(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lowercase", value)

    @property
    @pulumi.getter(name="specialChar")
    def special_char(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum number of special char that the password must contain. Special chars list: `!"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~`
        """
        return pulumi.get(self, "special_char")

    @special_char.setter
    def special_char(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "special_char", value)

    @property
    @pulumi.getter
    def uppercase(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum number of uppercase letters that the password must contain
        """
        return pulumi.get(self, "uppercase")

    @uppercase.setter
    def uppercase(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "uppercase", value)


@pulumi.input_type
class OauthSettingsOauthProviderArgs:
    def __init__(__self__, *,
                 api_url: pulumi.Input[str],
                 auth_url: pulumi.Input[str],
                 client_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str],
                 name: pulumi.Input[str],
                 token_url: pulumi.Input[str],
                 type: pulumi.Input[str],
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] api_url: OAuth user info endpoint for the IdP.
        :param pulumi.Input[str] auth_url: OAuth authorization endpoint for the IdP.
        :param pulumi.Input[str] client_id: OAuth client ID configured on the IdP.
        :param pulumi.Input[str] client_secret: OAuth client secret configured on the IdP.
        :param pulumi.Input[str] name: Name of the Artifactory OAuth provider.
        :param pulumi.Input[str] token_url: OAuth token endpoint for the IdP.
        :param pulumi.Input[str] type: Type of OAuth provider. (e.g., `github`, `google`, `cloudfoundry`, or `openId`)
        :param pulumi.Input[bool] enabled: Enable the Artifactory OAuth provider.  Default value is `true`.
        """
        pulumi.set(__self__, "api_url", api_url)
        pulumi.set(__self__, "auth_url", auth_url)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "token_url", token_url)
        pulumi.set(__self__, "type", type)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="apiUrl")
    def api_url(self) -> pulumi.Input[str]:
        """
        OAuth user info endpoint for the IdP.
        """
        return pulumi.get(self, "api_url")

    @api_url.setter
    def api_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_url", value)

    @property
    @pulumi.getter(name="authUrl")
    def auth_url(self) -> pulumi.Input[str]:
        """
        OAuth authorization endpoint for the IdP.
        """
        return pulumi.get(self, "auth_url")

    @auth_url.setter
    def auth_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "auth_url", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        OAuth client ID configured on the IdP.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        """
        OAuth client secret configured on the IdP.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the Artifactory OAuth provider.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="tokenUrl")
    def token_url(self) -> pulumi.Input[str]:
        """
        OAuth token endpoint for the IdP.
        """
        return pulumi.get(self, "token_url")

    @token_url.setter
    def token_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "token_url", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of OAuth provider. (e.g., `github`, `google`, `cloudfoundry`, or `openId`)
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable the Artifactory OAuth provider.  Default value is `true`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class PackageCleanupPolicySearchCriteriaArgs:
    def __init__(__self__, *,
                 included_packages: pulumi.Input[Sequence[pulumi.Input[str]]],
                 package_types: pulumi.Input[Sequence[pulumi.Input[str]]],
                 repos: pulumi.Input[Sequence[pulumi.Input[str]]],
                 created_before_in_months: Optional[pulumi.Input[int]] = None,
                 excluded_packages: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 excluded_repos: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 include_all_projects: Optional[pulumi.Input[bool]] = None,
                 included_projects: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 keep_last_n_versions: Optional[pulumi.Input[int]] = None,
                 last_downloaded_before_in_months: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_packages: Specify a pattern for a package name or an explicit package name. It accept only single element which can be specific package or pattern, and for including all packages use `**`. Example: `included_packages = ["**"]`
        :param pulumi.Input[Sequence[pulumi.Input[str]]] package_types: Types of packages to be removed. Support: conan, docker, generic, gradle, maven, npm, nuget, rpm.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] repos: Specify patterns for repository names or explicit repository names. For including all repos use `**`. Example: `repos = ["**"]`
        :param pulumi.Input[int] created_before_in_months: Remove packages based on when they were created. For example, remove packages that were created more than a year ago. The default value is to remove packages created more than 2 years ago.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_packages: Specify explicit package names that you want excluded from the policy. Only Name explicit names (and not patterns) are accepted.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_repos: Specify patterns for repository names or explicit repository names that you want excluded from the cleanup policy.
        :param pulumi.Input[bool] include_all_projects: Set this to `true` if you want the policy to run on all projects on the platform.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_projects: List of projects on which you want this policy to run. To include repositories that are not assigned to any project, enter the project key `default`.
        :param pulumi.Input[int] keep_last_n_versions: Select the number of latest versions to keep. The cleanup policy will remove all versions prior to the number you select here. The latest version is always excluded. Versions are determined by creation date.
               
               ~>Not all package types support this condition. For information on which package types support this condition, [learn more](https://jfrog.com/help/r/jfrog-platform-administration-documentation/retention-policies/package-types-coverage).
        :param pulumi.Input[int] last_downloaded_before_in_months: Removes packages based on when they were last downloaded. For example, removes packages that were not downloaded in the past year. The default value is to remove packages that were downloaded more than 2 years ago.
               
               ~>If a package was never downloaded, the policy will remove it based only on the age-condition (`created_before_in_months`).
               
               ~>JFrog recommends using the `last_downloaded_before_in_months` condition to ensure that packages currently in use are not deleted.
        """
        pulumi.set(__self__, "included_packages", included_packages)
        pulumi.set(__self__, "package_types", package_types)
        pulumi.set(__self__, "repos", repos)
        if created_before_in_months is not None:
            pulumi.set(__self__, "created_before_in_months", created_before_in_months)
        if excluded_packages is not None:
            pulumi.set(__self__, "excluded_packages", excluded_packages)
        if excluded_repos is not None:
            pulumi.set(__self__, "excluded_repos", excluded_repos)
        if include_all_projects is not None:
            pulumi.set(__self__, "include_all_projects", include_all_projects)
        if included_projects is not None:
            pulumi.set(__self__, "included_projects", included_projects)
        if keep_last_n_versions is not None:
            pulumi.set(__self__, "keep_last_n_versions", keep_last_n_versions)
        if last_downloaded_before_in_months is not None:
            pulumi.set(__self__, "last_downloaded_before_in_months", last_downloaded_before_in_months)

    @property
    @pulumi.getter(name="includedPackages")
    def included_packages(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specify a pattern for a package name or an explicit package name. It accept only single element which can be specific package or pattern, and for including all packages use `**`. Example: `included_packages = ["**"]`
        """
        return pulumi.get(self, "included_packages")

    @included_packages.setter
    def included_packages(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "included_packages", value)

    @property
    @pulumi.getter(name="packageTypes")
    def package_types(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Types of packages to be removed. Support: conan, docker, generic, gradle, maven, npm, nuget, rpm.
        """
        return pulumi.get(self, "package_types")

    @package_types.setter
    def package_types(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "package_types", value)

    @property
    @pulumi.getter
    def repos(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specify patterns for repository names or explicit repository names. For including all repos use `**`. Example: `repos = ["**"]`
        """
        return pulumi.get(self, "repos")

    @repos.setter
    def repos(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "repos", value)

    @property
    @pulumi.getter(name="createdBeforeInMonths")
    def created_before_in_months(self) -> Optional[pulumi.Input[int]]:
        """
        Remove packages based on when they were created. For example, remove packages that were created more than a year ago. The default value is to remove packages created more than 2 years ago.
        """
        return pulumi.get(self, "created_before_in_months")

    @created_before_in_months.setter
    def created_before_in_months(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "created_before_in_months", value)

    @property
    @pulumi.getter(name="excludedPackages")
    def excluded_packages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify explicit package names that you want excluded from the policy. Only Name explicit names (and not patterns) are accepted.
        """
        return pulumi.get(self, "excluded_packages")

    @excluded_packages.setter
    def excluded_packages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_packages", value)

    @property
    @pulumi.getter(name="excludedRepos")
    def excluded_repos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specify patterns for repository names or explicit repository names that you want excluded from the cleanup policy.
        """
        return pulumi.get(self, "excluded_repos")

    @excluded_repos.setter
    def excluded_repos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_repos", value)

    @property
    @pulumi.getter(name="includeAllProjects")
    def include_all_projects(self) -> Optional[pulumi.Input[bool]]:
        """
        Set this to `true` if you want the policy to run on all projects on the platform.
        """
        return pulumi.get(self, "include_all_projects")

    @include_all_projects.setter
    def include_all_projects(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_all_projects", value)

    @property
    @pulumi.getter(name="includedProjects")
    def included_projects(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of projects on which you want this policy to run. To include repositories that are not assigned to any project, enter the project key `default`.
        """
        return pulumi.get(self, "included_projects")

    @included_projects.setter
    def included_projects(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_projects", value)

    @property
    @pulumi.getter(name="keepLastNVersions")
    def keep_last_n_versions(self) -> Optional[pulumi.Input[int]]:
        """
        Select the number of latest versions to keep. The cleanup policy will remove all versions prior to the number you select here. The latest version is always excluded. Versions are determined by creation date.

        ~>Not all package types support this condition. For information on which package types support this condition, [learn more](https://jfrog.com/help/r/jfrog-platform-administration-documentation/retention-policies/package-types-coverage).
        """
        return pulumi.get(self, "keep_last_n_versions")

    @keep_last_n_versions.setter
    def keep_last_n_versions(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "keep_last_n_versions", value)

    @property
    @pulumi.getter(name="lastDownloadedBeforeInMonths")
    def last_downloaded_before_in_months(self) -> Optional[pulumi.Input[int]]:
        """
        Removes packages based on when they were last downloaded. For example, removes packages that were not downloaded in the past year. The default value is to remove packages that were downloaded more than 2 years ago.

        ~>If a package was never downloaded, the policy will remove it based only on the age-condition (`created_before_in_months`).

        ~>JFrog recommends using the `last_downloaded_before_in_months` condition to ensure that packages currently in use are not deleted.
        """
        return pulumi.get(self, "last_downloaded_before_in_months")

    @last_downloaded_before_in_months.setter
    def last_downloaded_before_in_months(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "last_downloaded_before_in_months", value)


@pulumi.input_type
class PermissionTargetBuildArgs:
    def __init__(__self__, *,
                 repositories: pulumi.Input[Sequence[pulumi.Input[str]]],
                 actions: Optional[pulumi.Input['PermissionTargetBuildActionsArgs']] = None,
                 excludes_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 includes_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] repositories: This can only be 1 value: "artifactory-build-info", and currently, validation of sets/lists is not allowed. Artifactory will reject the request if you change this
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excludes_patterns: The default value will be [] if nothing is supplied
        :param pulumi.Input[Sequence[pulumi.Input[str]]] includes_patterns: The default value will be [""] if nothing is supplied
        """
        pulumi.set(__self__, "repositories", repositories)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if excludes_patterns is not None:
            pulumi.set(__self__, "excludes_patterns", excludes_patterns)
        if includes_patterns is not None:
            pulumi.set(__self__, "includes_patterns", includes_patterns)

    @property
    @pulumi.getter
    def repositories(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        This can only be 1 value: "artifactory-build-info", and currently, validation of sets/lists is not allowed. Artifactory will reject the request if you change this
        """
        return pulumi.get(self, "repositories")

    @repositories.setter
    def repositories(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "repositories", value)

    @property
    @pulumi.getter
    def actions(self) -> Optional[pulumi.Input['PermissionTargetBuildActionsArgs']]:
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional[pulumi.Input['PermissionTargetBuildActionsArgs']]):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter(name="excludesPatterns")
    def excludes_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The default value will be [] if nothing is supplied
        """
        return pulumi.get(self, "excludes_patterns")

    @excludes_patterns.setter
    def excludes_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excludes_patterns", value)

    @property
    @pulumi.getter(name="includesPatterns")
    def includes_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The default value will be [""] if nothing is supplied
        """
        return pulumi.get(self, "includes_patterns")

    @includes_patterns.setter
    def includes_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "includes_patterns", value)


@pulumi.input_type
class PermissionTargetBuildActionsArgs:
    def __init__(__self__, *,
                 groups: Optional[pulumi.Input[Sequence[pulumi.Input['PermissionTargetBuildActionsGroupArgs']]]] = None,
                 users: Optional[pulumi.Input[Sequence[pulumi.Input['PermissionTargetBuildActionsUserArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PermissionTargetBuildActionsGroupArgs']]] groups: Groups this permission applies for.
        :param pulumi.Input[Sequence[pulumi.Input['PermissionTargetBuildActionsUserArgs']]] users: Users this permission target applies for.
        """
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PermissionTargetBuildActionsGroupArgs']]]]:
        """
        Groups this permission applies for.
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PermissionTargetBuildActionsGroupArgs']]]]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter
    def users(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PermissionTargetBuildActionsUserArgs']]]]:
        """
        Users this permission target applies for.
        """
        return pulumi.get(self, "users")

    @users.setter
    def users(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PermissionTargetBuildActionsUserArgs']]]]):
        pulumi.set(self, "users", value)


@pulumi.input_type
class PermissionTargetBuildActionsGroupArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 permissions: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] name: Name of permission.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of permission.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def permissions(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "permissions", value)


@pulumi.input_type
class PermissionTargetBuildActionsUserArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 permissions: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] name: Name of permission.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of permission.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def permissions(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "permissions", value)


@pulumi.input_type
class PermissionTargetReleaseBundleArgs:
    def __init__(__self__, *,
                 repositories: pulumi.Input[Sequence[pulumi.Input[str]]],
                 actions: Optional[pulumi.Input['PermissionTargetReleaseBundleActionsArgs']] = None,
                 excludes_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 includes_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] repositories: This can only be 1 value: "artifactory-build-info", and currently, validation of sets/lists is not allowed. Artifactory will reject the request if you change this
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excludes_patterns: The default value will be [] if nothing is supplied
        :param pulumi.Input[Sequence[pulumi.Input[str]]] includes_patterns: The default value will be [""] if nothing is supplied
        """
        pulumi.set(__self__, "repositories", repositories)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if excludes_patterns is not None:
            pulumi.set(__self__, "excludes_patterns", excludes_patterns)
        if includes_patterns is not None:
            pulumi.set(__self__, "includes_patterns", includes_patterns)

    @property
    @pulumi.getter
    def repositories(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        This can only be 1 value: "artifactory-build-info", and currently, validation of sets/lists is not allowed. Artifactory will reject the request if you change this
        """
        return pulumi.get(self, "repositories")

    @repositories.setter
    def repositories(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "repositories", value)

    @property
    @pulumi.getter
    def actions(self) -> Optional[pulumi.Input['PermissionTargetReleaseBundleActionsArgs']]:
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional[pulumi.Input['PermissionTargetReleaseBundleActionsArgs']]):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter(name="excludesPatterns")
    def excludes_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The default value will be [] if nothing is supplied
        """
        return pulumi.get(self, "excludes_patterns")

    @excludes_patterns.setter
    def excludes_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excludes_patterns", value)

    @property
    @pulumi.getter(name="includesPatterns")
    def includes_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The default value will be [""] if nothing is supplied
        """
        return pulumi.get(self, "includes_patterns")

    @includes_patterns.setter
    def includes_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "includes_patterns", value)


@pulumi.input_type
class PermissionTargetReleaseBundleActionsArgs:
    def __init__(__self__, *,
                 groups: Optional[pulumi.Input[Sequence[pulumi.Input['PermissionTargetReleaseBundleActionsGroupArgs']]]] = None,
                 users: Optional[pulumi.Input[Sequence[pulumi.Input['PermissionTargetReleaseBundleActionsUserArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PermissionTargetReleaseBundleActionsGroupArgs']]] groups: Groups this permission applies for.
        :param pulumi.Input[Sequence[pulumi.Input['PermissionTargetReleaseBundleActionsUserArgs']]] users: Users this permission target applies for.
        """
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PermissionTargetReleaseBundleActionsGroupArgs']]]]:
        """
        Groups this permission applies for.
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PermissionTargetReleaseBundleActionsGroupArgs']]]]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter
    def users(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PermissionTargetReleaseBundleActionsUserArgs']]]]:
        """
        Users this permission target applies for.
        """
        return pulumi.get(self, "users")

    @users.setter
    def users(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PermissionTargetReleaseBundleActionsUserArgs']]]]):
        pulumi.set(self, "users", value)


@pulumi.input_type
class PermissionTargetReleaseBundleActionsGroupArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 permissions: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] name: Name of permission.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of permission.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def permissions(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "permissions", value)


@pulumi.input_type
class PermissionTargetReleaseBundleActionsUserArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 permissions: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] name: Name of permission.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of permission.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def permissions(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "permissions", value)


@pulumi.input_type
class PermissionTargetRepoArgs:
    def __init__(__self__, *,
                 repositories: pulumi.Input[Sequence[pulumi.Input[str]]],
                 actions: Optional[pulumi.Input['PermissionTargetRepoActionsArgs']] = None,
                 excludes_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 includes_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] repositories: List of repositories this permission target is applicable for. You can specify the name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excludes_patterns: Pattern of artifacts to exclude.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] includes_patterns: Pattern of artifacts to include.
        """
        pulumi.set(__self__, "repositories", repositories)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if excludes_patterns is not None:
            pulumi.set(__self__, "excludes_patterns", excludes_patterns)
        if includes_patterns is not None:
            pulumi.set(__self__, "includes_patterns", includes_patterns)

    @property
    @pulumi.getter
    def repositories(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of repositories this permission target is applicable for. You can specify the name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        """
        return pulumi.get(self, "repositories")

    @repositories.setter
    def repositories(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "repositories", value)

    @property
    @pulumi.getter
    def actions(self) -> Optional[pulumi.Input['PermissionTargetRepoActionsArgs']]:
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional[pulumi.Input['PermissionTargetRepoActionsArgs']]):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter(name="excludesPatterns")
    def excludes_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Pattern of artifacts to exclude.
        """
        return pulumi.get(self, "excludes_patterns")

    @excludes_patterns.setter
    def excludes_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excludes_patterns", value)

    @property
    @pulumi.getter(name="includesPatterns")
    def includes_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Pattern of artifacts to include.
        """
        return pulumi.get(self, "includes_patterns")

    @includes_patterns.setter
    def includes_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "includes_patterns", value)


@pulumi.input_type
class PermissionTargetRepoActionsArgs:
    def __init__(__self__, *,
                 groups: Optional[pulumi.Input[Sequence[pulumi.Input['PermissionTargetRepoActionsGroupArgs']]]] = None,
                 users: Optional[pulumi.Input[Sequence[pulumi.Input['PermissionTargetRepoActionsUserArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PermissionTargetRepoActionsGroupArgs']]] groups: Groups this permission applies for.
        :param pulumi.Input[Sequence[pulumi.Input['PermissionTargetRepoActionsUserArgs']]] users: Users this permission target applies for.
        """
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PermissionTargetRepoActionsGroupArgs']]]]:
        """
        Groups this permission applies for.
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PermissionTargetRepoActionsGroupArgs']]]]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter
    def users(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PermissionTargetRepoActionsUserArgs']]]]:
        """
        Users this permission target applies for.
        """
        return pulumi.get(self, "users")

    @users.setter
    def users(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PermissionTargetRepoActionsUserArgs']]]]):
        pulumi.set(self, "users", value)


@pulumi.input_type
class PermissionTargetRepoActionsGroupArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 permissions: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] name: Name of permission.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of permission.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def permissions(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "permissions", value)


@pulumi.input_type
class PermissionTargetRepoActionsUserArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 permissions: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] name: Name of permission.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of permission.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def permissions(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "permissions", value)


@pulumi.input_type
class PropertySetPropertyArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 closed_predefined_values: Optional[pulumi.Input[bool]] = None,
                 multiple_choice: Optional[pulumi.Input[bool]] = None,
                 predefined_values: Optional[pulumi.Input[Sequence[pulumi.Input['PropertySetPropertyPredefinedValueArgs']]]] = None):
        """
        :param pulumi.Input[str] name: The name pf the property.
        :param pulumi.Input[bool] closed_predefined_values: Disables `multiple_choice` if set to `false` at the same time with multiple_choice set to `true`. Default value is `false`
        :param pulumi.Input[bool] multiple_choice: Defines if user can select multiple values. `closed_predefined_values` should be set to `true`. Default value is `false`.
        :param pulumi.Input[Sequence[pulumi.Input['PropertySetPropertyPredefinedValueArgs']]] predefined_values: Properties in the property set.
        """
        pulumi.set(__self__, "name", name)
        if closed_predefined_values is not None:
            pulumi.set(__self__, "closed_predefined_values", closed_predefined_values)
        if multiple_choice is not None:
            pulumi.set(__self__, "multiple_choice", multiple_choice)
        if predefined_values is not None:
            pulumi.set(__self__, "predefined_values", predefined_values)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name pf the property.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="closedPredefinedValues")
    def closed_predefined_values(self) -> Optional[pulumi.Input[bool]]:
        """
        Disables `multiple_choice` if set to `false` at the same time with multiple_choice set to `true`. Default value is `false`
        """
        return pulumi.get(self, "closed_predefined_values")

    @closed_predefined_values.setter
    def closed_predefined_values(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "closed_predefined_values", value)

    @property
    @pulumi.getter(name="multipleChoice")
    def multiple_choice(self) -> Optional[pulumi.Input[bool]]:
        """
        Defines if user can select multiple values. `closed_predefined_values` should be set to `true`. Default value is `false`.
        """
        return pulumi.get(self, "multiple_choice")

    @multiple_choice.setter
    def multiple_choice(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "multiple_choice", value)

    @property
    @pulumi.getter(name="predefinedValues")
    def predefined_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PropertySetPropertyPredefinedValueArgs']]]]:
        """
        Properties in the property set.
        """
        return pulumi.get(self, "predefined_values")

    @predefined_values.setter
    def predefined_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PropertySetPropertyPredefinedValueArgs']]]]):
        pulumi.set(self, "predefined_values", value)


@pulumi.input_type
class PropertySetPropertyPredefinedValueArgs:
    def __init__(__self__, *,
                 default_value: pulumi.Input[bool],
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[bool] default_value: Whether the value is selected by default in the UI.
        :param pulumi.Input[str] name: Property set name.
        """
        pulumi.set(__self__, "default_value", default_value)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> pulumi.Input[bool]:
        """
        Whether the value is selected by default in the UI.
        """
        return pulumi.get(self, "default_value")

    @default_value.setter
    def default_value(self, value: pulumi.Input[bool]):
        pulumi.set(self, "default_value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Property set name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class PushReplicationReplicationArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 url: pulumi.Input[str],
                 username: pulumi.Input[str],
                 check_binary_existence_in_filestore: Optional[pulumi.Input[bool]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 path_prefix: Optional[pulumi.Input[str]] = None,
                 proxy: Optional[pulumi.Input[str]] = None,
                 socket_timeout_millis: Optional[pulumi.Input[int]] = None,
                 sync_deletes: Optional[pulumi.Input[bool]] = None,
                 sync_properties: Optional[pulumi.Input[bool]] = None,
                 sync_statistics: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] password: Required for local repository, but not needed for remote repository.
        :param pulumi.Input[str] url: The URL of the target local repository on a remote Artifactory server. Required for local repository, but not needed for remote repository.
        :param pulumi.Input[str] username: Required for local repository, but not needed for remote repository.
        :param pulumi.Input[bool] check_binary_existence_in_filestore: When true, enables distributed checksum storage. For more information, see
               [Optimizing Repository Replication with Checksum-Based Storage](https://www.jfrog.com/confluence/display/JFROG/Repository+Replication#RepositoryReplication-OptimizingRepositoryReplicationUsingStorageLevelSynchronizationOptions).
        :param pulumi.Input[bool] enabled: When set, this replication will be enabled when saved.
        :param pulumi.Input[str] path_prefix: Only artifacts that located in path that matches the subpath within the remote repository will be replicated.
        :param pulumi.Input[str] proxy: Proxy key from Artifactory Proxies settings. The proxy configuration will be used when communicating with the remote instance.
        :param pulumi.Input[int] socket_timeout_millis: The network timeout in milliseconds to use for remote operations.
        :param pulumi.Input[bool] sync_deletes: When set, items that were deleted locally should also be deleted remotely (also applies to properties metadata).
               Note that enabling this option, will delete artifacts on the target that do not exist in the source repository.
        :param pulumi.Input[bool] sync_properties: When set, the task also synchronizes the properties of replicated artifacts.
        :param pulumi.Input[bool] sync_statistics: When set, artifact download statistics will also be replicated. Set to avoid inadvertent cleanup at the target instance when setting up replication for disaster recovery.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "url", url)
        pulumi.set(__self__, "username", username)
        if check_binary_existence_in_filestore is not None:
            pulumi.set(__self__, "check_binary_existence_in_filestore", check_binary_existence_in_filestore)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if path_prefix is not None:
            pulumi.set(__self__, "path_prefix", path_prefix)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if socket_timeout_millis is not None:
            pulumi.set(__self__, "socket_timeout_millis", socket_timeout_millis)
        if sync_deletes is not None:
            pulumi.set(__self__, "sync_deletes", sync_deletes)
        if sync_properties is not None:
            pulumi.set(__self__, "sync_properties", sync_properties)
        if sync_statistics is not None:
            pulumi.set(__self__, "sync_statistics", sync_statistics)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        Required for local repository, but not needed for remote repository.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        The URL of the target local repository on a remote Artifactory server. Required for local repository, but not needed for remote repository.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        Required for local repository, but not needed for remote repository.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="checkBinaryExistenceInFilestore")
    def check_binary_existence_in_filestore(self) -> Optional[pulumi.Input[bool]]:
        """
        When true, enables distributed checksum storage. For more information, see
        [Optimizing Repository Replication with Checksum-Based Storage](https://www.jfrog.com/confluence/display/JFROG/Repository+Replication#RepositoryReplication-OptimizingRepositoryReplicationUsingStorageLevelSynchronizationOptions).
        """
        return pulumi.get(self, "check_binary_existence_in_filestore")

    @check_binary_existence_in_filestore.setter
    def check_binary_existence_in_filestore(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "check_binary_existence_in_filestore", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        When set, this replication will be enabled when saved.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="pathPrefix")
    def path_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Only artifacts that located in path that matches the subpath within the remote repository will be replicated.
        """
        return pulumi.get(self, "path_prefix")

    @path_prefix.setter
    def path_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path_prefix", value)

    @property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[str]]:
        """
        Proxy key from Artifactory Proxies settings. The proxy configuration will be used when communicating with the remote instance.
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy", value)

    @property
    @pulumi.getter(name="socketTimeoutMillis")
    def socket_timeout_millis(self) -> Optional[pulumi.Input[int]]:
        """
        The network timeout in milliseconds to use for remote operations.
        """
        return pulumi.get(self, "socket_timeout_millis")

    @socket_timeout_millis.setter
    def socket_timeout_millis(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "socket_timeout_millis", value)

    @property
    @pulumi.getter(name="syncDeletes")
    def sync_deletes(self) -> Optional[pulumi.Input[bool]]:
        """
        When set, items that were deleted locally should also be deleted remotely (also applies to properties metadata).
        Note that enabling this option, will delete artifacts on the target that do not exist in the source repository.
        """
        return pulumi.get(self, "sync_deletes")

    @sync_deletes.setter
    def sync_deletes(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sync_deletes", value)

    @property
    @pulumi.getter(name="syncProperties")
    def sync_properties(self) -> Optional[pulumi.Input[bool]]:
        """
        When set, the task also synchronizes the properties of replicated artifacts.
        """
        return pulumi.get(self, "sync_properties")

    @sync_properties.setter
    def sync_properties(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sync_properties", value)

    @property
    @pulumi.getter(name="syncStatistics")
    def sync_statistics(self) -> Optional[pulumi.Input[bool]]:
        """
        When set, artifact download statistics will also be replicated. Set to avoid inadvertent cleanup at the target instance when setting up replication for disaster recovery.
        """
        return pulumi.get(self, "sync_statistics")

    @sync_statistics.setter
    def sync_statistics(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sync_statistics", value)


@pulumi.input_type
class ReleaseBundleCustomWebhookCriteriaArgs:
    def __init__(__self__, *,
                 any_release_bundle: pulumi.Input[bool],
                 registered_release_bundle_names: pulumi.Input[Sequence[pulumi.Input[str]]],
                 exclude_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 include_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] any_release_bundle: Trigger on any release bundle.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] registered_release_bundle_names: Trigger on this list of release bundle names.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: "org/apache/**".
        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: "org/apache/**".
        """
        pulumi.set(__self__, "any_release_bundle", any_release_bundle)
        pulumi.set(__self__, "registered_release_bundle_names", registered_release_bundle_names)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @property
    @pulumi.getter(name="anyReleaseBundle")
    def any_release_bundle(self) -> pulumi.Input[bool]:
        """
        Trigger on any release bundle.
        """
        return pulumi.get(self, "any_release_bundle")

    @any_release_bundle.setter
    def any_release_bundle(self, value: pulumi.Input[bool]):
        pulumi.set(self, "any_release_bundle", value)

    @property
    @pulumi.getter(name="registeredReleaseBundleNames")
    def registered_release_bundle_names(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Trigger on this list of release bundle names.
        """
        return pulumi.get(self, "registered_release_bundle_names")

    @registered_release_bundle_names.setter
    def registered_release_bundle_names(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "registered_release_bundle_names", value)

    @property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: "org/apache/**".
        """
        return pulumi.get(self, "exclude_patterns")

    @exclude_patterns.setter
    def exclude_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_patterns", value)

    @property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: "org/apache/**".
        """
        return pulumi.get(self, "include_patterns")

    @include_patterns.setter
    def include_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "include_patterns", value)


@pulumi.input_type
class ReleaseBundleCustomWebhookHandlerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 payload: Optional[pulumi.Input[str]] = None,
                 proxy: Optional[pulumi.Input[str]] = None,
                 secrets: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] http_headers: HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        :param pulumi.Input[str] payload: This attribute is used to build the request body. Used in custom webhooks
        :param pulumi.Input[str] proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] secrets: Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
        pulumi.set(__self__, "url", url)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        """
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "http_headers", value)

    @property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[str]]:
        """
        This attribute is used to build the request body. Used in custom webhooks
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "payload", value)

    @property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[str]]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy", value)

    @property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "secrets", value)


@pulumi.input_type
class ReleaseBundleV2CustomWebhookCriteriaArgs:
    def __init__(__self__, *,
                 any_release_bundle: pulumi.Input[bool],
                 selected_release_bundles: pulumi.Input[Sequence[pulumi.Input[str]]],
                 exclude_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 include_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] any_release_bundle: Trigger on any release bundle.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] selected_release_bundles: Trigger on this list of release bundle names.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: "org/apache/**".
        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: "org/apache/**".
        """
        pulumi.set(__self__, "any_release_bundle", any_release_bundle)
        pulumi.set(__self__, "selected_release_bundles", selected_release_bundles)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @property
    @pulumi.getter(name="anyReleaseBundle")
    def any_release_bundle(self) -> pulumi.Input[bool]:
        """
        Trigger on any release bundle.
        """
        return pulumi.get(self, "any_release_bundle")

    @any_release_bundle.setter
    def any_release_bundle(self, value: pulumi.Input[bool]):
        pulumi.set(self, "any_release_bundle", value)

    @property
    @pulumi.getter(name="selectedReleaseBundles")
    def selected_release_bundles(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Trigger on this list of release bundle names.
        """
        return pulumi.get(self, "selected_release_bundles")

    @selected_release_bundles.setter
    def selected_release_bundles(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "selected_release_bundles", value)

    @property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: "org/apache/**".
        """
        return pulumi.get(self, "exclude_patterns")

    @exclude_patterns.setter
    def exclude_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_patterns", value)

    @property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: "org/apache/**".
        """
        return pulumi.get(self, "include_patterns")

    @include_patterns.setter
    def include_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "include_patterns", value)


@pulumi.input_type
class ReleaseBundleV2CustomWebhookHandlerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 payload: Optional[pulumi.Input[str]] = None,
                 proxy: Optional[pulumi.Input[str]] = None,
                 secrets: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] http_headers: HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        :param pulumi.Input[str] payload: This attribute is used to build the request body. Used in custom webhooks
        :param pulumi.Input[str] proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] secrets: Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
        pulumi.set(__self__, "url", url)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        """
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "http_headers", value)

    @property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[str]]:
        """
        This attribute is used to build the request body. Used in custom webhooks
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "payload", value)

    @property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[str]]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy", value)

    @property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "secrets", value)


@pulumi.input_type
class ReleaseBundleV2PromotionCustomWebhookCriteriaArgs:
    def __init__(__self__, *,
                 selected_environments: pulumi.Input[Sequence[pulumi.Input[str]]],
                 exclude_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 include_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] selected_environments: Trigger on this list of environment names.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash).\\nAnt-style path expressions are supported (*, **, ?).\\nFor example: "org/apache/**"
        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash).\\nAnt-style path expressions are supported (*, **, ?).\\nFor example: "org/apache/**"
        """
        pulumi.set(__self__, "selected_environments", selected_environments)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @property
    @pulumi.getter(name="selectedEnvironments")
    def selected_environments(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Trigger on this list of environment names.
        """
        return pulumi.get(self, "selected_environments")

    @selected_environments.setter
    def selected_environments(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "selected_environments", value)

    @property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash).\\nAnt-style path expressions are supported (*, **, ?).\\nFor example: "org/apache/**"
        """
        return pulumi.get(self, "exclude_patterns")

    @exclude_patterns.setter
    def exclude_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_patterns", value)

    @property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash).\\nAnt-style path expressions are supported (*, **, ?).\\nFor example: "org/apache/**"
        """
        return pulumi.get(self, "include_patterns")

    @include_patterns.setter
    def include_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "include_patterns", value)


@pulumi.input_type
class ReleaseBundleV2PromotionCustomWebhookHandlerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 payload: Optional[pulumi.Input[str]] = None,
                 proxy: Optional[pulumi.Input[str]] = None,
                 secrets: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] http_headers: HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        :param pulumi.Input[str] payload: This attribute is used to build the request body. Used in custom webhooks
        :param pulumi.Input[str] proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] secrets: Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
        pulumi.set(__self__, "url", url)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        """
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "http_headers", value)

    @property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[str]]:
        """
        This attribute is used to build the request body. Used in custom webhooks
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "payload", value)

    @property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[str]]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy", value)

    @property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "secrets", value)


@pulumi.input_type
class ReleaseBundleV2PromotionWebhookCriteriaArgs:
    def __init__(__self__, *,
                 selected_environments: pulumi.Input[Sequence[pulumi.Input[str]]],
                 exclude_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 include_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] selected_environments: Trigger on this list of environment names.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash).\\nAnt-style path expressions are supported (*, **, ?).\\nFor example: "org/apache/**"
        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash).\\nAnt-style path expressions are supported (*, **, ?).\\nFor example: "org/apache/**"
        """
        pulumi.set(__self__, "selected_environments", selected_environments)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @property
    @pulumi.getter(name="selectedEnvironments")
    def selected_environments(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Trigger on this list of environment names.
        """
        return pulumi.get(self, "selected_environments")

    @selected_environments.setter
    def selected_environments(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "selected_environments", value)

    @property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash).\\nAnt-style path expressions are supported (*, **, ?).\\nFor example: "org/apache/**"
        """
        return pulumi.get(self, "exclude_patterns")

    @exclude_patterns.setter
    def exclude_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_patterns", value)

    @property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash).\\nAnt-style path expressions are supported (*, **, ?).\\nFor example: "org/apache/**"
        """
        return pulumi.get(self, "include_patterns")

    @include_patterns.setter
    def include_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "include_patterns", value)


@pulumi.input_type
class ReleaseBundleV2PromotionWebhookHandlerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 custom_http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 proxy: Optional[pulumi.Input[str]] = None,
                 secret: Optional[pulumi.Input[str]] = None,
                 use_secret_for_signing: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] custom_http_headers: Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        :param pulumi.Input[str] proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param pulumi.Input[str] secret: Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        :param pulumi.Input[bool] use_secret_for_signing: When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        pulumi.set(__self__, "url", url)
        if custom_http_headers is not None:
            pulumi.set(__self__, "custom_http_headers", custom_http_headers)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if use_secret_for_signing is not None:
            pulumi.set(__self__, "use_secret_for_signing", use_secret_for_signing)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="customHttpHeaders")
    def custom_http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        return pulumi.get(self, "custom_http_headers")

    @custom_http_headers.setter
    def custom_http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "custom_http_headers", value)

    @property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[str]]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy", value)

    @property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[str]]:
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret", value)

    @property
    @pulumi.getter(name="useSecretForSigning")
    def use_secret_for_signing(self) -> Optional[pulumi.Input[bool]]:
        """
        When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        return pulumi.get(self, "use_secret_for_signing")

    @use_secret_for_signing.setter
    def use_secret_for_signing(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_secret_for_signing", value)


@pulumi.input_type
class ReleaseBundleV2SourceArgs:
    def __init__(__self__, *,
                 aql: Optional[pulumi.Input[str]] = None,
                 artifacts: Optional[pulumi.Input[Sequence[pulumi.Input['ReleaseBundleV2SourceArtifactArgs']]]] = None,
                 builds: Optional[pulumi.Input[Sequence[pulumi.Input['ReleaseBundleV2SourceBuildArgs']]]] = None,
                 release_bundles: Optional[pulumi.Input[Sequence[pulumi.Input['ReleaseBundleV2SourceReleaseBundleArgs']]]] = None):
        """
        :param pulumi.Input[str] aql: The contents of the AQL query.
        :param pulumi.Input[Sequence[pulumi.Input['ReleaseBundleV2SourceArtifactArgs']]] artifacts: Source type to create a Release Bundle v2 version by collecting source artifacts from a list of path/checksum pairs.
        :param pulumi.Input[Sequence[pulumi.Input['ReleaseBundleV2SourceBuildArgs']]] builds: Source type to create a Release Bundle v2 version by collecting source artifacts from one or multiple builds (also known as build-info).
        :param pulumi.Input[Sequence[pulumi.Input['ReleaseBundleV2SourceReleaseBundleArgs']]] release_bundles: Source type to create a Release Bundle v2 version by collecting source artifacts from existing Release Bundle versions. Must match `source_type` attribute value.
        """
        if aql is not None:
            pulumi.set(__self__, "aql", aql)
        if artifacts is not None:
            pulumi.set(__self__, "artifacts", artifacts)
        if builds is not None:
            pulumi.set(__self__, "builds", builds)
        if release_bundles is not None:
            pulumi.set(__self__, "release_bundles", release_bundles)

    @property
    @pulumi.getter
    def aql(self) -> Optional[pulumi.Input[str]]:
        """
        The contents of the AQL query.
        """
        return pulumi.get(self, "aql")

    @aql.setter
    def aql(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aql", value)

    @property
    @pulumi.getter
    def artifacts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ReleaseBundleV2SourceArtifactArgs']]]]:
        """
        Source type to create a Release Bundle v2 version by collecting source artifacts from a list of path/checksum pairs.
        """
        return pulumi.get(self, "artifacts")

    @artifacts.setter
    def artifacts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ReleaseBundleV2SourceArtifactArgs']]]]):
        pulumi.set(self, "artifacts", value)

    @property
    @pulumi.getter
    def builds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ReleaseBundleV2SourceBuildArgs']]]]:
        """
        Source type to create a Release Bundle v2 version by collecting source artifacts from one or multiple builds (also known as build-info).
        """
        return pulumi.get(self, "builds")

    @builds.setter
    def builds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ReleaseBundleV2SourceBuildArgs']]]]):
        pulumi.set(self, "builds", value)

    @property
    @pulumi.getter(name="releaseBundles")
    def release_bundles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ReleaseBundleV2SourceReleaseBundleArgs']]]]:
        """
        Source type to create a Release Bundle v2 version by collecting source artifacts from existing Release Bundle versions. Must match `source_type` attribute value.
        """
        return pulumi.get(self, "release_bundles")

    @release_bundles.setter
    def release_bundles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ReleaseBundleV2SourceReleaseBundleArgs']]]]):
        pulumi.set(self, "release_bundles", value)


@pulumi.input_type
class ReleaseBundleV2SourceArtifactArgs:
    def __init__(__self__, *,
                 path: pulumi.Input[str],
                 sha256: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] path: The path for the artifact
        :param pulumi.Input[str] sha256: The SHA256 for the artifact
        """
        pulumi.set(__self__, "path", path)
        if sha256 is not None:
            pulumi.set(__self__, "sha256", sha256)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        The path for the artifact
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def sha256(self) -> Optional[pulumi.Input[str]]:
        """
        The SHA256 for the artifact
        """
        return pulumi.get(self, "sha256")

    @sha256.setter
    def sha256(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sha256", value)


@pulumi.input_type
class ReleaseBundleV2SourceBuildArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 number: pulumi.Input[str],
                 include_dependencies: Optional[pulumi.Input[bool]] = None,
                 repository: Optional[pulumi.Input[str]] = None,
                 started: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the build.
        :param pulumi.Input[str] number: Number (run) of the build.
        :param pulumi.Input[bool] include_dependencies: Determines whether to include build dependencies in the Release Bundle. The default value is `false`.
        :param pulumi.Input[str] repository: The repository key of the build. If omitted, the system uses the default built-in repository, `artifactory-build-info`.
        :param pulumi.Input[str] started: Timestamp when the build was created. If omitted, the system uses the latest build run, as identified by the `name` and `number` combination. The timestamp is provided according to the ISO 8601 standard.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "number", number)
        if include_dependencies is not None:
            pulumi.set(__self__, "include_dependencies", include_dependencies)
        if repository is not None:
            pulumi.set(__self__, "repository", repository)
        if started is not None:
            pulumi.set(__self__, "started", started)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the build.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def number(self) -> pulumi.Input[str]:
        """
        Number (run) of the build.
        """
        return pulumi.get(self, "number")

    @number.setter
    def number(self, value: pulumi.Input[str]):
        pulumi.set(self, "number", value)

    @property
    @pulumi.getter(name="includeDependencies")
    def include_dependencies(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines whether to include build dependencies in the Release Bundle. The default value is `false`.
        """
        return pulumi.get(self, "include_dependencies")

    @include_dependencies.setter
    def include_dependencies(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_dependencies", value)

    @property
    @pulumi.getter
    def repository(self) -> Optional[pulumi.Input[str]]:
        """
        The repository key of the build. If omitted, the system uses the default built-in repository, `artifactory-build-info`.
        """
        return pulumi.get(self, "repository")

    @repository.setter
    def repository(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repository", value)

    @property
    @pulumi.getter
    def started(self) -> Optional[pulumi.Input[str]]:
        """
        Timestamp when the build was created. If omitted, the system uses the latest build run, as identified by the `name` and `number` combination. The timestamp is provided according to the ISO 8601 standard.
        """
        return pulumi.get(self, "started")

    @started.setter
    def started(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "started", value)


@pulumi.input_type
class ReleaseBundleV2SourceReleaseBundleArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 version: pulumi.Input[str],
                 project_key: Optional[pulumi.Input[str]] = None,
                 repository_key: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the release bundle.
        :param pulumi.Input[str] version: The version of the release bundle.
        :param pulumi.Input[str] project_key: Project key of the release bundle.
        :param pulumi.Input[str] repository_key: The key of the release bundle repository.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "version", version)
        if project_key is not None:
            pulumi.set(__self__, "project_key", project_key)
        if repository_key is not None:
            pulumi.set(__self__, "repository_key", repository_key)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the release bundle.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def version(self) -> pulumi.Input[str]:
        """
        The version of the release bundle.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[str]):
        pulumi.set(self, "version", value)

    @property
    @pulumi.getter(name="projectKey")
    def project_key(self) -> Optional[pulumi.Input[str]]:
        """
        Project key of the release bundle.
        """
        return pulumi.get(self, "project_key")

    @project_key.setter
    def project_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_key", value)

    @property
    @pulumi.getter(name="repositoryKey")
    def repository_key(self) -> Optional[pulumi.Input[str]]:
        """
        The key of the release bundle repository.
        """
        return pulumi.get(self, "repository_key")

    @repository_key.setter
    def repository_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repository_key", value)


@pulumi.input_type
class ReleaseBundleV2WebhookCriteriaArgs:
    def __init__(__self__, *,
                 any_release_bundle: pulumi.Input[bool],
                 selected_release_bundles: pulumi.Input[Sequence[pulumi.Input[str]]],
                 exclude_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 include_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] any_release_bundle: Trigger on any release bundle.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] selected_release_bundles: Trigger on this list of release bundle names.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: "org/apache/**".
        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: "org/apache/**".
        """
        pulumi.set(__self__, "any_release_bundle", any_release_bundle)
        pulumi.set(__self__, "selected_release_bundles", selected_release_bundles)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @property
    @pulumi.getter(name="anyReleaseBundle")
    def any_release_bundle(self) -> pulumi.Input[bool]:
        """
        Trigger on any release bundle.
        """
        return pulumi.get(self, "any_release_bundle")

    @any_release_bundle.setter
    def any_release_bundle(self, value: pulumi.Input[bool]):
        pulumi.set(self, "any_release_bundle", value)

    @property
    @pulumi.getter(name="selectedReleaseBundles")
    def selected_release_bundles(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Trigger on this list of release bundle names.
        """
        return pulumi.get(self, "selected_release_bundles")

    @selected_release_bundles.setter
    def selected_release_bundles(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "selected_release_bundles", value)

    @property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: "org/apache/**".
        """
        return pulumi.get(self, "exclude_patterns")

    @exclude_patterns.setter
    def exclude_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_patterns", value)

    @property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: "org/apache/**".
        """
        return pulumi.get(self, "include_patterns")

    @include_patterns.setter
    def include_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "include_patterns", value)


@pulumi.input_type
class ReleaseBundleV2WebhookHandlerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 custom_http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 proxy: Optional[pulumi.Input[str]] = None,
                 secret: Optional[pulumi.Input[str]] = None,
                 use_secret_for_signing: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] custom_http_headers: Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        :param pulumi.Input[str] proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param pulumi.Input[str] secret: Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        :param pulumi.Input[bool] use_secret_for_signing: When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        pulumi.set(__self__, "url", url)
        if custom_http_headers is not None:
            pulumi.set(__self__, "custom_http_headers", custom_http_headers)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if use_secret_for_signing is not None:
            pulumi.set(__self__, "use_secret_for_signing", use_secret_for_signing)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="customHttpHeaders")
    def custom_http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        return pulumi.get(self, "custom_http_headers")

    @custom_http_headers.setter
    def custom_http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "custom_http_headers", value)

    @property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[str]]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy", value)

    @property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[str]]:
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret", value)

    @property
    @pulumi.getter(name="useSecretForSigning")
    def use_secret_for_signing(self) -> Optional[pulumi.Input[bool]]:
        """
        When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        return pulumi.get(self, "use_secret_for_signing")

    @use_secret_for_signing.setter
    def use_secret_for_signing(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_secret_for_signing", value)


@pulumi.input_type
class ReleaseBundleWebhookCriteriaArgs:
    def __init__(__self__, *,
                 any_release_bundle: pulumi.Input[bool],
                 registered_release_bundle_names: pulumi.Input[Sequence[pulumi.Input[str]]],
                 exclude_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 include_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] any_release_bundle: Trigger on any release bundle.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] registered_release_bundle_names: Trigger on this list of release bundle names.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: "org/apache/**".
        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: "org/apache/**".
        """
        pulumi.set(__self__, "any_release_bundle", any_release_bundle)
        pulumi.set(__self__, "registered_release_bundle_names", registered_release_bundle_names)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @property
    @pulumi.getter(name="anyReleaseBundle")
    def any_release_bundle(self) -> pulumi.Input[bool]:
        """
        Trigger on any release bundle.
        """
        return pulumi.get(self, "any_release_bundle")

    @any_release_bundle.setter
    def any_release_bundle(self, value: pulumi.Input[bool]):
        pulumi.set(self, "any_release_bundle", value)

    @property
    @pulumi.getter(name="registeredReleaseBundleNames")
    def registered_release_bundle_names(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Trigger on this list of release bundle names.
        """
        return pulumi.get(self, "registered_release_bundle_names")

    @registered_release_bundle_names.setter
    def registered_release_bundle_names(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "registered_release_bundle_names", value)

    @property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: "org/apache/**".
        """
        return pulumi.get(self, "exclude_patterns")

    @exclude_patterns.setter
    def exclude_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_patterns", value)

    @property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: "org/apache/**".
        """
        return pulumi.get(self, "include_patterns")

    @include_patterns.setter
    def include_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "include_patterns", value)


@pulumi.input_type
class ReleaseBundleWebhookHandlerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 custom_http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 proxy: Optional[pulumi.Input[str]] = None,
                 secret: Optional[pulumi.Input[str]] = None,
                 use_secret_for_signing: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] custom_http_headers: Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        :param pulumi.Input[str] proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param pulumi.Input[str] secret: Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        :param pulumi.Input[bool] use_secret_for_signing: When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        pulumi.set(__self__, "url", url)
        if custom_http_headers is not None:
            pulumi.set(__self__, "custom_http_headers", custom_http_headers)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if use_secret_for_signing is not None:
            pulumi.set(__self__, "use_secret_for_signing", use_secret_for_signing)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="customHttpHeaders")
    def custom_http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        return pulumi.get(self, "custom_http_headers")

    @custom_http_headers.setter
    def custom_http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "custom_http_headers", value)

    @property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[str]]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy", value)

    @property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[str]]:
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret", value)

    @property
    @pulumi.getter(name="useSecretForSigning")
    def use_secret_for_signing(self) -> Optional[pulumi.Input[bool]]:
        """
        When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        return pulumi.get(self, "use_secret_for_signing")

    @use_secret_for_signing.setter
    def use_secret_for_signing(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_secret_for_signing", value)


@pulumi.input_type
class RemoteAlpineRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemoteAnsibleRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemoteBowerRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemoteCargoRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemoteChefRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemoteCocoapodsRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemoteComposerRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemoteConanRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemoteCondaRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemoteCranRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemoteDebianRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemoteDockerRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemoteGemsRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemoteGenericRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemoteGitlfsRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemoteGoRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemoteGradleRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemoteHelmRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemoteHelmociRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemoteHuggingfacemlRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemoteIvyRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemoteMavenRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemoteNpmRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemoteNugetRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemoteOciRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemoteOpkgRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemoteP2RepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemotePubRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemotePuppetRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemotePypiRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemoteRpmRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemoteSbtRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemoteSwiftRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemoteTerraformRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemoteVcsRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class ReplicationConfigReplicationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 path_prefix: Optional[pulumi.Input[str]] = None,
                 proxy: Optional[pulumi.Input[str]] = None,
                 socket_timeout_millis: Optional[pulumi.Input[int]] = None,
                 sync_deletes: Optional[pulumi.Input[bool]] = None,
                 sync_properties: Optional[pulumi.Input[bool]] = None,
                 sync_statistics: Optional[pulumi.Input[bool]] = None,
                 url: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] password: Requires password encryption to be turned off `POST /api/system/decrypt`.
        :param pulumi.Input[str] proxy: Proxy key from Artifactory Proxies setting
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if path_prefix is not None:
            pulumi.set(__self__, "path_prefix", path_prefix)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if socket_timeout_millis is not None:
            pulumi.set(__self__, "socket_timeout_millis", socket_timeout_millis)
        if sync_deletes is not None:
            pulumi.set(__self__, "sync_deletes", sync_deletes)
        if sync_properties is not None:
            pulumi.set(__self__, "sync_properties", sync_properties)
        if sync_statistics is not None:
            pulumi.set(__self__, "sync_statistics", sync_statistics)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        Requires password encryption to be turned off `POST /api/system/decrypt`.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="pathPrefix")
    def path_prefix(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "path_prefix")

    @path_prefix.setter
    def path_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path_prefix", value)

    @property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[str]]:
        """
        Proxy key from Artifactory Proxies setting
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy", value)

    @property
    @pulumi.getter(name="socketTimeoutMillis")
    def socket_timeout_millis(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "socket_timeout_millis")

    @socket_timeout_millis.setter
    def socket_timeout_millis(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "socket_timeout_millis", value)

    @property
    @pulumi.getter(name="syncDeletes")
    def sync_deletes(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "sync_deletes")

    @sync_deletes.setter
    def sync_deletes(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sync_deletes", value)

    @property
    @pulumi.getter(name="syncProperties")
    def sync_properties(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "sync_properties")

    @sync_properties.setter
    def sync_properties(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sync_properties", value)

    @property
    @pulumi.getter(name="syncStatistics")
    def sync_statistics(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "sync_statistics")

    @sync_statistics.setter
    def sync_statistics(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sync_statistics", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class UnmanagedUserPasswordPolicyArgs:
    def __init__(__self__, *,
                 digit: Optional[pulumi.Input[int]] = None,
                 length: Optional[pulumi.Input[int]] = None,
                 lowercase: Optional[pulumi.Input[int]] = None,
                 special_char: Optional[pulumi.Input[int]] = None,
                 uppercase: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] digit: Minimum number of digits that the password must contain
        :param pulumi.Input[int] length: Minimum length of the password
        :param pulumi.Input[int] lowercase: Minimum number of lowercase letters that the password must contain
        :param pulumi.Input[int] special_char: Minimum number of special char that the password must contain. Special chars list: ``!"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~``
        :param pulumi.Input[int] uppercase: Minimum number of uppercase letters that the password must contain
        """
        if digit is not None:
            pulumi.set(__self__, "digit", digit)
        if length is not None:
            pulumi.set(__self__, "length", length)
        if lowercase is not None:
            pulumi.set(__self__, "lowercase", lowercase)
        if special_char is not None:
            pulumi.set(__self__, "special_char", special_char)
        if uppercase is not None:
            pulumi.set(__self__, "uppercase", uppercase)

    @property
    @pulumi.getter
    def digit(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum number of digits that the password must contain
        """
        return pulumi.get(self, "digit")

    @digit.setter
    def digit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "digit", value)

    @property
    @pulumi.getter
    def length(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum length of the password
        """
        return pulumi.get(self, "length")

    @length.setter
    def length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "length", value)

    @property
    @pulumi.getter
    def lowercase(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum number of lowercase letters that the password must contain
        """
        return pulumi.get(self, "lowercase")

    @lowercase.setter
    def lowercase(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lowercase", value)

    @property
    @pulumi.getter(name="specialChar")
    def special_char(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum number of special char that the password must contain. Special chars list: ``!"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~``
        """
        return pulumi.get(self, "special_char")

    @special_char.setter
    def special_char(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "special_char", value)

    @property
    @pulumi.getter
    def uppercase(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum number of uppercase letters that the password must contain
        """
        return pulumi.get(self, "uppercase")

    @uppercase.setter
    def uppercase(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "uppercase", value)


@pulumi.input_type
class UserCustomWebhookHandlerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 payload: Optional[pulumi.Input[str]] = None,
                 proxy: Optional[pulumi.Input[str]] = None,
                 secrets: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] http_headers: HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        :param pulumi.Input[str] payload: This attribute is used to build the request body. Used in custom webhooks
        :param pulumi.Input[str] proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] secrets: Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
        pulumi.set(__self__, "url", url)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        """
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "http_headers", value)

    @property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[str]]:
        """
        This attribute is used to build the request body. Used in custom webhooks
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "payload", value)

    @property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[str]]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy", value)

    @property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "secrets", value)


@pulumi.input_type
class UserPasswordPolicyArgs:
    def __init__(__self__, *,
                 digit: Optional[pulumi.Input[int]] = None,
                 length: Optional[pulumi.Input[int]] = None,
                 lowercase: Optional[pulumi.Input[int]] = None,
                 special_char: Optional[pulumi.Input[int]] = None,
                 uppercase: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] digit: Minimum number of digits that the password must contain
        :param pulumi.Input[int] length: Minimum length of the password
        :param pulumi.Input[int] lowercase: Minimum number of lowercase letters that the password must contain
        :param pulumi.Input[int] special_char: Minimum number of special char that the password must contain. Special chars list: `!"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~`
        :param pulumi.Input[int] uppercase: Minimum number of uppercase letters that the password must contain
        """
        if digit is not None:
            pulumi.set(__self__, "digit", digit)
        if length is not None:
            pulumi.set(__self__, "length", length)
        if lowercase is not None:
            pulumi.set(__self__, "lowercase", lowercase)
        if special_char is not None:
            pulumi.set(__self__, "special_char", special_char)
        if uppercase is not None:
            pulumi.set(__self__, "uppercase", uppercase)

    @property
    @pulumi.getter
    def digit(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum number of digits that the password must contain
        """
        return pulumi.get(self, "digit")

    @digit.setter
    def digit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "digit", value)

    @property
    @pulumi.getter
    def length(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum length of the password
        """
        return pulumi.get(self, "length")

    @length.setter
    def length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "length", value)

    @property
    @pulumi.getter
    def lowercase(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum number of lowercase letters that the password must contain
        """
        return pulumi.get(self, "lowercase")

    @lowercase.setter
    def lowercase(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lowercase", value)

    @property
    @pulumi.getter(name="specialChar")
    def special_char(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum number of special char that the password must contain. Special chars list: `!"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~`
        """
        return pulumi.get(self, "special_char")

    @special_char.setter
    def special_char(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "special_char", value)

    @property
    @pulumi.getter
    def uppercase(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum number of uppercase letters that the password must contain
        """
        return pulumi.get(self, "uppercase")

    @uppercase.setter
    def uppercase(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "uppercase", value)


@pulumi.input_type
class UserWebhookHandlerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 custom_http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 proxy: Optional[pulumi.Input[str]] = None,
                 secret: Optional[pulumi.Input[str]] = None,
                 use_secret_for_signing: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] custom_http_headers: Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        :param pulumi.Input[str] proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param pulumi.Input[str] secret: Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        :param pulumi.Input[bool] use_secret_for_signing: When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        pulumi.set(__self__, "url", url)
        if custom_http_headers is not None:
            pulumi.set(__self__, "custom_http_headers", custom_http_headers)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if use_secret_for_signing is not None:
            pulumi.set(__self__, "use_secret_for_signing", use_secret_for_signing)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="customHttpHeaders")
    def custom_http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        return pulumi.get(self, "custom_http_headers")

    @custom_http_headers.setter
    def custom_http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "custom_http_headers", value)

    @property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[str]]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy", value)

    @property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[str]]:
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret", value)

    @property
    @pulumi.getter(name="useSecretForSigning")
    def use_secret_for_signing(self) -> Optional[pulumi.Input[bool]]:
        """
        When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        return pulumi.get(self, "use_secret_for_signing")

    @use_secret_for_signing.setter
    def use_secret_for_signing(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_secret_for_signing", value)


@pulumi.input_type
class VaultConfigurationConfigArgs:
    def __init__(__self__, *,
                 auth: pulumi.Input['VaultConfigurationConfigAuthArgs'],
                 mounts: pulumi.Input[Sequence[pulumi.Input['VaultConfigurationConfigMountArgs']]],
                 url: pulumi.Input[str]):
        """
        :param pulumi.Input[str] url: The base URL of the Vault server.
        """
        pulumi.set(__self__, "auth", auth)
        pulumi.set(__self__, "mounts", mounts)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def auth(self) -> pulumi.Input['VaultConfigurationConfigAuthArgs']:
        return pulumi.get(self, "auth")

    @auth.setter
    def auth(self, value: pulumi.Input['VaultConfigurationConfigAuthArgs']):
        pulumi.set(self, "auth", value)

    @property
    @pulumi.getter
    def mounts(self) -> pulumi.Input[Sequence[pulumi.Input['VaultConfigurationConfigMountArgs']]]:
        return pulumi.get(self, "mounts")

    @mounts.setter
    def mounts(self, value: pulumi.Input[Sequence[pulumi.Input['VaultConfigurationConfigMountArgs']]]):
        pulumi.set(self, "mounts", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        The base URL of the Vault server.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class VaultConfigurationConfigAuthArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 certificate: Optional[pulumi.Input[str]] = None,
                 certificate_key: Optional[pulumi.Input[str]] = None,
                 role_id: Optional[pulumi.Input[str]] = None,
                 secret_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] certificate: Client certificate (in PEM format) for `Certificate` type.
        :param pulumi.Input[str] certificate_key: Private key (in PEM format) for `Certificate` type.
        :param pulumi.Input[str] role_id: Role ID for `AppRole` type
        :param pulumi.Input[str] secret_id: Secret ID for `AppRole` type
        """
        pulumi.set(__self__, "type", type)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if certificate_key is not None:
            pulumi.set(__self__, "certificate_key", certificate_key)
        if role_id is not None:
            pulumi.set(__self__, "role_id", role_id)
        if secret_id is not None:
            pulumi.set(__self__, "secret_id", secret_id)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input[str]]:
        """
        Client certificate (in PEM format) for `Certificate` type.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter(name="certificateKey")
    def certificate_key(self) -> Optional[pulumi.Input[str]]:
        """
        Private key (in PEM format) for `Certificate` type.
        """
        return pulumi.get(self, "certificate_key")

    @certificate_key.setter
    def certificate_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate_key", value)

    @property
    @pulumi.getter(name="roleId")
    def role_id(self) -> Optional[pulumi.Input[str]]:
        """
        Role ID for `AppRole` type
        """
        return pulumi.get(self, "role_id")

    @role_id.setter
    def role_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role_id", value)

    @property
    @pulumi.getter(name="secretId")
    def secret_id(self) -> Optional[pulumi.Input[str]]:
        """
        Secret ID for `AppRole` type
        """
        return pulumi.get(self, "secret_id")

    @secret_id.setter
    def secret_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_id", value)


@pulumi.input_type
class VaultConfigurationConfigMountArgs:
    def __init__(__self__, *,
                 path: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] path: Vault secret engine path
        :param pulumi.Input[str] type: Vault supports several secret engines, each one has different capabilities. The supported secret engine types are: `KV1` and `KV2`.
        """
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        Vault secret engine path
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Vault supports several secret engines, each one has different capabilities. The supported secret engine types are: `KV1` and `KV2`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class GetFederatedAlpineRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str,
                 access_token: Optional[str] = None):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        :param str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[str]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class GetFederatedAnsibleRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str,
                 access_token: Optional[str] = None):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        :param str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[str]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class GetFederatedBowerRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str,
                 access_token: Optional[str] = None):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        :param str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[str]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class GetFederatedCargoRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str,
                 access_token: Optional[str] = None):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        :param str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[str]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class GetFederatedChefRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str,
                 access_token: Optional[str] = None):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        :param str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[str]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class GetFederatedCocoapodsRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str,
                 access_token: Optional[str] = None):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        :param str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[str]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class GetFederatedComposerRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str,
                 access_token: Optional[str] = None):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        :param str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[str]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class GetFederatedConanRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str,
                 access_token: Optional[str] = None):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        :param str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[str]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class GetFederatedCondaRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str,
                 access_token: Optional[str] = None):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        :param str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[str]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class GetFederatedCranRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str,
                 access_token: Optional[str] = None):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        :param str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[str]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class GetFederatedDebianRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str,
                 access_token: Optional[str] = None):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        :param str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[str]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class GetFederatedDockerRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str,
                 access_token: Optional[str] = None):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repositoryName
        :param str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repositoryName
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[str]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class GetFederatedDockerV1RepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str,
                 access_token: Optional[str] = None):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        :param str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[str]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class GetFederatedDockerV2RepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str,
                 access_token: Optional[str] = None):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        :param str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[str]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class GetFederatedGemsRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str,
                 access_token: Optional[str] = None):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        :param str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[str]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class GetFederatedGenericRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str,
                 access_token: Optional[str] = None):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        :param str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[str]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class GetFederatedGitlfsRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str,
                 access_token: Optional[str] = None):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        :param str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[str]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class GetFederatedGoRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str,
                 access_token: Optional[str] = None):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        :param str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[str]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class GetFederatedGradleRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str,
                 access_token: Optional[str] = None):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        :param str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[str]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class GetFederatedHelmRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str,
                 access_token: Optional[str] = None):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        :param str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[str]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class GetFederatedHelmociRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str,
                 access_token: Optional[str] = None):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        :param str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[str]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class GetFederatedIvyRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str,
                 access_token: Optional[str] = None):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        :param str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[str]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class GetFederatedMavenRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str,
                 access_token: Optional[str] = None):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        :param str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[str]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class GetFederatedNpmRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str,
                 access_token: Optional[str] = None):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        :param str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[str]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class GetFederatedNugetRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str,
                 access_token: Optional[str] = None):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        :param str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[str]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class GetFederatedOciRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str,
                 access_token: Optional[str] = None):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        :param str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[str]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class GetFederatedOpkgRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str,
                 access_token: Optional[str] = None):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        :param str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[str]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class GetFederatedPuppetRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str,
                 access_token: Optional[str] = None):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        :param str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[str]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class GetFederatedPypiRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str,
                 access_token: Optional[str] = None):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        :param str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[str]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class GetFederatedRpmRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str,
                 access_token: Optional[str] = None):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        :param str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[str]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class GetFederatedSbtRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str,
                 access_token: Optional[str] = None):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        :param str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[str]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class GetFederatedSwiftRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str,
                 access_token: Optional[str] = None):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        :param str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[str]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class GetFederatedTerraformModuleRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str,
                 access_token: Optional[str] = None):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        :param str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[str]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class GetFederatedTerraformProviderRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str,
                 access_token: Optional[str] = None):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        :param str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[str]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class GetFederatedVagrantRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str,
                 access_token: Optional[str] = None):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        :param str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[str]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class GetPermissionTargetBuildArgs:
    def __init__(__self__, *,
                 repositories: Sequence[str],
                 actions: Optional['GetPermissionTargetBuildActionsArgs'] = None,
                 excludes_patterns: Optional[Sequence[str]] = None,
                 includes_patterns: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] repositories: List of repositories this permission target is applicable for. You can specify the
               name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote
               repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        :param Sequence[str] excludes_patterns: Pattern of artifacts to exclude.
        :param Sequence[str] includes_patterns: Pattern of artifacts to include.
        """
        pulumi.set(__self__, "repositories", repositories)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if excludes_patterns is not None:
            pulumi.set(__self__, "excludes_patterns", excludes_patterns)
        if includes_patterns is not None:
            pulumi.set(__self__, "includes_patterns", includes_patterns)

    @property
    @pulumi.getter
    def repositories(self) -> Sequence[str]:
        """
        List of repositories this permission target is applicable for. You can specify the
        name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote
        repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        """
        return pulumi.get(self, "repositories")

    @repositories.setter
    def repositories(self, value: Sequence[str]):
        pulumi.set(self, "repositories", value)

    @property
    @pulumi.getter
    def actions(self) -> Optional['GetPermissionTargetBuildActionsArgs']:
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional['GetPermissionTargetBuildActionsArgs']):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter(name="excludesPatterns")
    def excludes_patterns(self) -> Optional[Sequence[str]]:
        """
        Pattern of artifacts to exclude.
        """
        return pulumi.get(self, "excludes_patterns")

    @excludes_patterns.setter
    def excludes_patterns(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "excludes_patterns", value)

    @property
    @pulumi.getter(name="includesPatterns")
    def includes_patterns(self) -> Optional[Sequence[str]]:
        """
        Pattern of artifacts to include.
        """
        return pulumi.get(self, "includes_patterns")

    @includes_patterns.setter
    def includes_patterns(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "includes_patterns", value)


@pulumi.input_type
class GetPermissionTargetBuildActionsArgs:
    def __init__(__self__, *,
                 groups: Optional[Sequence['GetPermissionTargetBuildActionsGroupArgs']] = None,
                 users: Optional[Sequence['GetPermissionTargetBuildActionsUserArgs']] = None):
        """
        :param Sequence['GetPermissionTargetBuildActionsGroupArgs'] groups: Groups this permission applies for.
        :param Sequence['GetPermissionTargetBuildActionsUserArgs'] users: Users this permission target applies for.
        """
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence['GetPermissionTargetBuildActionsGroupArgs']]:
        """
        Groups this permission applies for.
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[Sequence['GetPermissionTargetBuildActionsGroupArgs']]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter
    def users(self) -> Optional[Sequence['GetPermissionTargetBuildActionsUserArgs']]:
        """
        Users this permission target applies for.
        """
        return pulumi.get(self, "users")

    @users.setter
    def users(self, value: Optional[Sequence['GetPermissionTargetBuildActionsUserArgs']]):
        pulumi.set(self, "users", value)


@pulumi.input_type
class GetPermissionTargetBuildActionsGroupArgs:
    def __init__(__self__, *,
                 name: str,
                 permissions: Sequence[str]):
        """
        :param str name: Name of the permission target.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the permission target.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def permissions(self) -> Sequence[str]:
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: Sequence[str]):
        pulumi.set(self, "permissions", value)


@pulumi.input_type
class GetPermissionTargetBuildActionsUserArgs:
    def __init__(__self__, *,
                 name: str,
                 permissions: Sequence[str]):
        """
        :param str name: Name of the permission target.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the permission target.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def permissions(self) -> Sequence[str]:
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: Sequence[str]):
        pulumi.set(self, "permissions", value)


@pulumi.input_type
class GetPermissionTargetReleaseBundleArgs:
    def __init__(__self__, *,
                 repositories: Sequence[str],
                 actions: Optional['GetPermissionTargetReleaseBundleActionsArgs'] = None,
                 excludes_patterns: Optional[Sequence[str]] = None,
                 includes_patterns: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] repositories: List of repositories this permission target is applicable for. You can specify the
               name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote
               repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        :param Sequence[str] excludes_patterns: Pattern of artifacts to exclude.
        :param Sequence[str] includes_patterns: Pattern of artifacts to include.
        """
        pulumi.set(__self__, "repositories", repositories)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if excludes_patterns is not None:
            pulumi.set(__self__, "excludes_patterns", excludes_patterns)
        if includes_patterns is not None:
            pulumi.set(__self__, "includes_patterns", includes_patterns)

    @property
    @pulumi.getter
    def repositories(self) -> Sequence[str]:
        """
        List of repositories this permission target is applicable for. You can specify the
        name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote
        repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        """
        return pulumi.get(self, "repositories")

    @repositories.setter
    def repositories(self, value: Sequence[str]):
        pulumi.set(self, "repositories", value)

    @property
    @pulumi.getter
    def actions(self) -> Optional['GetPermissionTargetReleaseBundleActionsArgs']:
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional['GetPermissionTargetReleaseBundleActionsArgs']):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter(name="excludesPatterns")
    def excludes_patterns(self) -> Optional[Sequence[str]]:
        """
        Pattern of artifacts to exclude.
        """
        return pulumi.get(self, "excludes_patterns")

    @excludes_patterns.setter
    def excludes_patterns(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "excludes_patterns", value)

    @property
    @pulumi.getter(name="includesPatterns")
    def includes_patterns(self) -> Optional[Sequence[str]]:
        """
        Pattern of artifacts to include.
        """
        return pulumi.get(self, "includes_patterns")

    @includes_patterns.setter
    def includes_patterns(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "includes_patterns", value)


@pulumi.input_type
class GetPermissionTargetReleaseBundleActionsArgs:
    def __init__(__self__, *,
                 groups: Optional[Sequence['GetPermissionTargetReleaseBundleActionsGroupArgs']] = None,
                 users: Optional[Sequence['GetPermissionTargetReleaseBundleActionsUserArgs']] = None):
        """
        :param Sequence['GetPermissionTargetReleaseBundleActionsGroupArgs'] groups: Groups this permission applies for.
        :param Sequence['GetPermissionTargetReleaseBundleActionsUserArgs'] users: Users this permission target applies for.
        """
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence['GetPermissionTargetReleaseBundleActionsGroupArgs']]:
        """
        Groups this permission applies for.
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[Sequence['GetPermissionTargetReleaseBundleActionsGroupArgs']]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter
    def users(self) -> Optional[Sequence['GetPermissionTargetReleaseBundleActionsUserArgs']]:
        """
        Users this permission target applies for.
        """
        return pulumi.get(self, "users")

    @users.setter
    def users(self, value: Optional[Sequence['GetPermissionTargetReleaseBundleActionsUserArgs']]):
        pulumi.set(self, "users", value)


@pulumi.input_type
class GetPermissionTargetReleaseBundleActionsGroupArgs:
    def __init__(__self__, *,
                 name: str,
                 permissions: Sequence[str]):
        """
        :param str name: Name of the permission target.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the permission target.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def permissions(self) -> Sequence[str]:
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: Sequence[str]):
        pulumi.set(self, "permissions", value)


@pulumi.input_type
class GetPermissionTargetReleaseBundleActionsUserArgs:
    def __init__(__self__, *,
                 name: str,
                 permissions: Sequence[str]):
        """
        :param str name: Name of the permission target.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the permission target.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def permissions(self) -> Sequence[str]:
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: Sequence[str]):
        pulumi.set(self, "permissions", value)


@pulumi.input_type
class GetPermissionTargetRepoArgs:
    def __init__(__self__, *,
                 repositories: Sequence[str],
                 actions: Optional['GetPermissionTargetRepoActionsArgs'] = None,
                 excludes_patterns: Optional[Sequence[str]] = None,
                 includes_patterns: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] repositories: List of repositories this permission target is applicable for. You can specify the
               name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote
               repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        :param Sequence[str] excludes_patterns: Pattern of artifacts to exclude.
        :param Sequence[str] includes_patterns: Pattern of artifacts to include.
        """
        pulumi.set(__self__, "repositories", repositories)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if excludes_patterns is not None:
            pulumi.set(__self__, "excludes_patterns", excludes_patterns)
        if includes_patterns is not None:
            pulumi.set(__self__, "includes_patterns", includes_patterns)

    @property
    @pulumi.getter
    def repositories(self) -> Sequence[str]:
        """
        List of repositories this permission target is applicable for. You can specify the
        name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote
        repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        """
        return pulumi.get(self, "repositories")

    @repositories.setter
    def repositories(self, value: Sequence[str]):
        pulumi.set(self, "repositories", value)

    @property
    @pulumi.getter
    def actions(self) -> Optional['GetPermissionTargetRepoActionsArgs']:
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional['GetPermissionTargetRepoActionsArgs']):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter(name="excludesPatterns")
    def excludes_patterns(self) -> Optional[Sequence[str]]:
        """
        Pattern of artifacts to exclude.
        """
        return pulumi.get(self, "excludes_patterns")

    @excludes_patterns.setter
    def excludes_patterns(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "excludes_patterns", value)

    @property
    @pulumi.getter(name="includesPatterns")
    def includes_patterns(self) -> Optional[Sequence[str]]:
        """
        Pattern of artifacts to include.
        """
        return pulumi.get(self, "includes_patterns")

    @includes_patterns.setter
    def includes_patterns(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "includes_patterns", value)


@pulumi.input_type
class GetPermissionTargetRepoActionsArgs:
    def __init__(__self__, *,
                 groups: Optional[Sequence['GetPermissionTargetRepoActionsGroupArgs']] = None,
                 users: Optional[Sequence['GetPermissionTargetRepoActionsUserArgs']] = None):
        """
        :param Sequence['GetPermissionTargetRepoActionsGroupArgs'] groups: Groups this permission applies for.
        :param Sequence['GetPermissionTargetRepoActionsUserArgs'] users: Users this permission target applies for.
        """
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence['GetPermissionTargetRepoActionsGroupArgs']]:
        """
        Groups this permission applies for.
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[Sequence['GetPermissionTargetRepoActionsGroupArgs']]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter
    def users(self) -> Optional[Sequence['GetPermissionTargetRepoActionsUserArgs']]:
        """
        Users this permission target applies for.
        """
        return pulumi.get(self, "users")

    @users.setter
    def users(self, value: Optional[Sequence['GetPermissionTargetRepoActionsUserArgs']]):
        pulumi.set(self, "users", value)


@pulumi.input_type
class GetPermissionTargetRepoActionsGroupArgs:
    def __init__(__self__, *,
                 name: str,
                 permissions: Sequence[str]):
        """
        :param str name: Name of the permission target.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the permission target.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def permissions(self) -> Sequence[str]:
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: Sequence[str]):
        pulumi.set(self, "permissions", value)


@pulumi.input_type
class GetPermissionTargetRepoActionsUserArgs:
    def __init__(__self__, *,
                 name: str,
                 permissions: Sequence[str]):
        """
        :param str name: Name of the permission target.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the permission target.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def permissions(self) -> Sequence[str]:
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: Sequence[str]):
        pulumi.set(self, "permissions", value)


@pulumi.input_type
class GetRemoteAlpineRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class GetRemoteAnsibleRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class GetRemoteBowerRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class GetRemoteCargoRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class GetRemoteChefRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class GetRemoteCocoapodsRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class GetRemoteComposerRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class GetRemoteConanRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class GetRemoteCondaRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class GetRemoteCranRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class GetRemoteDebianRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class GetRemoteDockerRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class GetRemoteGemsRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class GetRemoteGenericRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class GetRemoteGitlfsRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class GetRemoteGoRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class GetRemoteGradleRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class GetRemoteHelmRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class GetRemoteHelmociRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class GetRemoteIvyRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class GetRemoteMavenRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class GetRemoteNpmRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class GetRemoteNugetRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class GetRemoteOciRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class GetRemoteOpkgRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class GetRemoteP2RepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class GetRemotePubRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class GetRemotePuppetRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class GetRemotePypiRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class GetRemoteRpmRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class GetRemoteSbtRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class GetRemoteSwiftRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class GetRemoteTerraformRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class GetRemoteVcsRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


