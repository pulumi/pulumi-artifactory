# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities

__all__ = [
    'AccessTokenAdminTokenArgs',
    'ArtifactCustomWebhookCriteriaArgs',
    'ArtifactCustomWebhookHandlerArgs',
    'ArtifactPropertyCustomWebhookCriteriaArgs',
    'ArtifactPropertyCustomWebhookHandlerArgs',
    'ArtifactPropertyWebhookCriteriaArgs',
    'ArtifactPropertyWebhookHandlerArgs',
    'ArtifactWebhookCriteriaArgs',
    'ArtifactWebhookHandlerArgs',
    'ArtifactoryReleaseBundleCustomWebhookCriteriaArgs',
    'ArtifactoryReleaseBundleCustomWebhookHandlerArgs',
    'ArtifactoryReleaseBundleWebhookCriteriaArgs',
    'ArtifactoryReleaseBundleWebhookHandlerArgs',
    'BuildCustomWebhookCriteriaArgs',
    'BuildCustomWebhookHandlerArgs',
    'BuildWebhookCriteriaArgs',
    'BuildWebhookHandlerArgs',
    'DistributionCustomWebhookCriteriaArgs',
    'DistributionCustomWebhookHandlerArgs',
    'DistributionWebhookCriteriaArgs',
    'DistributionWebhookHandlerArgs',
    'DockerCustomWebhookCriteriaArgs',
    'DockerCustomWebhookHandlerArgs',
    'DockerWebhookCriteriaArgs',
    'DockerWebhookHandlerArgs',
    'FederatedAlpineRepositoryMemberArgs',
    'FederatedBowerRepositoryMemberArgs',
    'FederatedCargoRepositoryMemberArgs',
    'FederatedChefRepositoryMemberArgs',
    'FederatedCocoapodsRepositoryMemberArgs',
    'FederatedComposerRepositoryMemberArgs',
    'FederatedConanRepositoryMemberArgs',
    'FederatedCondaRepositoryMemberArgs',
    'FederatedCranRepositoryMemberArgs',
    'FederatedDebianRepositoryMemberArgs',
    'FederatedDockerRepositoryMemberArgs',
    'FederatedDockerV1RepositoryMemberArgs',
    'FederatedDockerV2RepositoryMemberArgs',
    'FederatedGemsRepositoryMemberArgs',
    'FederatedGenericRepositoryMemberArgs',
    'FederatedGitltfsRepositoryMemberArgs',
    'FederatedGoRepositoryMemberArgs',
    'FederatedGradleRepositoryMemberArgs',
    'FederatedHelmRepositoryMemberArgs',
    'FederatedHelmociRepositoryMemberArgs',
    'FederatedIvyRepositoryMemberArgs',
    'FederatedMavenRepositoryMemberArgs',
    'FederatedNpmRepositoryMemberArgs',
    'FederatedNugetRepositoryMemberArgs',
    'FederatedOciRepositoryMemberArgs',
    'FederatedOpkgRepositoryMemberArgs',
    'FederatedPuppetRepositoryMemberArgs',
    'FederatedPypiRepositoryMemberArgs',
    'FederatedRpmRepositoryMemberArgs',
    'FederatedSbtRepositoryMemberArgs',
    'FederatedSwiftRepositoryMemberArgs',
    'FederatedTerraformModuleRepositoryMemberArgs',
    'FederatedTerraformProviderRepositoryMemberArgs',
    'FederatedVagrantRepositoryMemberArgs',
    'LocalRepositoryMultiReplicationReplicationArgs',
    'OauthSettingsOauthProviderArgs',
    'PermissionTargetBuildArgs',
    'PermissionTargetBuildActionsArgs',
    'PermissionTargetBuildActionsGroupArgs',
    'PermissionTargetBuildActionsUserArgs',
    'PermissionTargetReleaseBundleArgs',
    'PermissionTargetReleaseBundleActionsArgs',
    'PermissionTargetReleaseBundleActionsGroupArgs',
    'PermissionTargetReleaseBundleActionsUserArgs',
    'PermissionTargetRepoArgs',
    'PermissionTargetRepoActionsArgs',
    'PermissionTargetRepoActionsGroupArgs',
    'PermissionTargetRepoActionsUserArgs',
    'PropertySetPropertyArgs',
    'PropertySetPropertyPredefinedValueArgs',
    'PushReplicationReplicationArgs',
    'ReleaseBundleCustomWebhookCriteriaArgs',
    'ReleaseBundleCustomWebhookHandlerArgs',
    'ReleaseBundleWebhookCriteriaArgs',
    'ReleaseBundleWebhookHandlerArgs',
    'RemoteAlpineRepositoryContentSynchronisationArgs',
    'RemoteBowerRepositoryContentSynchronisationArgs',
    'RemoteCargoRepositoryContentSynchronisationArgs',
    'RemoteChefRepositoryContentSynchronisationArgs',
    'RemoteCocoapodsRepositoryContentSynchronisationArgs',
    'RemoteComposerRepositoryContentSynchronisationArgs',
    'RemoteConanRepositoryContentSynchronisationArgs',
    'RemoteCondaRepositoryContentSynchronisationArgs',
    'RemoteCranRepositoryContentSynchronisationArgs',
    'RemoteDebianRepositoryContentSynchronisationArgs',
    'RemoteDockerRepositoryContentSynchronisationArgs',
    'RemoteGemsRepositoryContentSynchronisationArgs',
    'RemoteGenericRepositoryContentSynchronisationArgs',
    'RemoteGitlfsRepositoryContentSynchronisationArgs',
    'RemoteGoRepositoryContentSynchronisationArgs',
    'RemoteGradleRepositoryContentSynchronisationArgs',
    'RemoteHelmRepositoryContentSynchronisationArgs',
    'RemoteHelmociRepositoryContentSynchronisationArgs',
    'RemoteHuggingfacemlRepositoryContentSynchronisationArgs',
    'RemoteIvyRepositoryContentSynchronisationArgs',
    'RemoteMavenRepositoryContentSynchronisationArgs',
    'RemoteNpmRepositoryContentSynchronisationArgs',
    'RemoteNugetRepositoryContentSynchronisationArgs',
    'RemoteOciRepositoryContentSynchronisationArgs',
    'RemoteOpkgRepositoryContentSynchronisationArgs',
    'RemoteP2RepositoryContentSynchronisationArgs',
    'RemotePubRepositoryContentSynchronisationArgs',
    'RemotePuppetRepositoryContentSynchronisationArgs',
    'RemotePypiRepositoryContentSynchronisationArgs',
    'RemoteRpmRepositoryContentSynchronisationArgs',
    'RemoteSbtRepositoryContentSynchronisationArgs',
    'RemoteSwiftRepositoryContentSynchronisationArgs',
    'RemoteTerraformRepositoryContentSynchronisationArgs',
    'RemoteVcsRepositoryContentSynchronisationArgs',
    'ReplicationConfigReplicationArgs',
    'GetFederatedAlpineRepositoryMemberArgs',
    'GetFederatedBowerRepositoryMemberArgs',
    'GetFederatedCargoRepositoryMemberArgs',
    'GetFederatedChefRepositoryMemberArgs',
    'GetFederatedCocoapodsRepositoryMemberArgs',
    'GetFederatedComposerRepositoryMemberArgs',
    'GetFederatedConanRepositoryMemberArgs',
    'GetFederatedCondaRepositoryMemberArgs',
    'GetFederatedCranRepositoryMemberArgs',
    'GetFederatedDebianRepositoryMemberArgs',
    'GetFederatedDockerRepositoryMemberArgs',
    'GetFederatedDockerV1RepositoryMemberArgs',
    'GetFederatedDockerV2RepositoryMemberArgs',
    'GetFederatedGemsRepositoryMemberArgs',
    'GetFederatedGenericRepositoryMemberArgs',
    'GetFederatedGitlfsRepositoryMemberArgs',
    'GetFederatedGoRepositoryMemberArgs',
    'GetFederatedGradleRepositoryMemberArgs',
    'GetFederatedHelmRepositoryMemberArgs',
    'GetFederatedHelmociRepositoryMemberArgs',
    'GetFederatedIvyRepositoryMemberArgs',
    'GetFederatedMavenRepositoryMemberArgs',
    'GetFederatedNpmRepositoryMemberArgs',
    'GetFederatedNugetRepositoryMemberArgs',
    'GetFederatedOciRepositoryMemberArgs',
    'GetFederatedOpkgRepositoryMemberArgs',
    'GetFederatedPuppetRepositoryMemberArgs',
    'GetFederatedPypiRepositoryMemberArgs',
    'GetFederatedRpmRepositoryMemberArgs',
    'GetFederatedSbtRepositoryMemberArgs',
    'GetFederatedSwiftRepositoryMemberArgs',
    'GetFederatedTerraformModuleRepositoryMemberArgs',
    'GetFederatedTerraformProviderRepositoryMemberArgs',
    'GetFederatedVagrantRepositoryMemberArgs',
    'GetPermissionTargetBuildArgs',
    'GetPermissionTargetBuildActionsArgs',
    'GetPermissionTargetBuildActionsGroupArgs',
    'GetPermissionTargetBuildActionsUserArgs',
    'GetPermissionTargetReleaseBundleArgs',
    'GetPermissionTargetReleaseBundleActionsArgs',
    'GetPermissionTargetReleaseBundleActionsGroupArgs',
    'GetPermissionTargetReleaseBundleActionsUserArgs',
    'GetPermissionTargetRepoArgs',
    'GetPermissionTargetRepoActionsArgs',
    'GetPermissionTargetRepoActionsGroupArgs',
    'GetPermissionTargetRepoActionsUserArgs',
    'GetRemoteAlpineRepositoryContentSynchronisationArgs',
    'GetRemoteBowerRepositoryContentSynchronisationArgs',
    'GetRemoteCargoRepositoryContentSynchronisationArgs',
    'GetRemoteChefRepositoryContentSynchronisationArgs',
    'GetRemoteCocoapodsRepositoryContentSynchronisationArgs',
    'GetRemoteComposerRepositoryContentSynchronisationArgs',
    'GetRemoteConanRepositoryContentSynchronisationArgs',
    'GetRemoteCondaRepositoryContentSynchronisationArgs',
    'GetRemoteCranRepositoryContentSynchronisationArgs',
    'GetRemoteDebianRepositoryContentSynchronisationArgs',
    'GetRemoteDockerRepositoryContentSynchronisationArgs',
    'GetRemoteGemsRepositoryContentSynchronisationArgs',
    'GetRemoteGenericRepositoryContentSynchronisationArgs',
    'GetRemoteGitlfsRepositoryContentSynchronisationArgs',
    'GetRemoteGoRepositoryContentSynchronisationArgs',
    'GetRemoteGradleRepositoryContentSynchronisationArgs',
    'GetRemoteHelmRepositoryContentSynchronisationArgs',
    'GetRemoteHelmociRepositoryContentSynchronisationArgs',
    'GetRemoteIvyRepositoryContentSynchronisationArgs',
    'GetRemoteMavenRepositoryContentSynchronisationArgs',
    'GetRemoteNpmRepositoryContentSynchronisationArgs',
    'GetRemoteNugetRepositoryContentSynchronisationArgs',
    'GetRemoteOciRepositoryContentSynchronisationArgs',
    'GetRemoteOpkgRepositoryContentSynchronisationArgs',
    'GetRemoteP2RepositoryContentSynchronisationArgs',
    'GetRemotePubRepositoryContentSynchronisationArgs',
    'GetRemotePuppetRepositoryContentSynchronisationArgs',
    'GetRemotePypiRepositoryContentSynchronisationArgs',
    'GetRemoteRpmRepositoryContentSynchronisationArgs',
    'GetRemoteSbtRepositoryContentSynchronisationArgs',
    'GetRemoteSwiftRepositoryContentSynchronisationArgs',
    'GetRemoteTerraformRepositoryContentSynchronisationArgs',
    'GetRemoteVcsRepositoryContentSynchronisationArgs',
]

@pulumi.input_type
class AccessTokenAdminTokenArgs:
    def __init__(__self__, *,
                 instance_id: pulumi.Input[str]):
        pulumi.set(__self__, "instance_id", instance_id)

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "instance_id", value)


@pulumi.input_type
class ArtifactCustomWebhookCriteriaArgs:
    def __init__(__self__, *,
                 any_local: pulumi.Input[bool],
                 any_remote: pulumi.Input[bool],
                 repo_keys: pulumi.Input[Sequence[pulumi.Input[str]]],
                 exclude_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 include_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] any_local: Trigger on any local repo.
        :param pulumi.Input[bool] any_remote: Trigger on any remote repo.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] repo_keys: Trigger on this list of repo keys.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        pulumi.set(__self__, "any_local", any_local)
        pulumi.set(__self__, "any_remote", any_remote)
        pulumi.set(__self__, "repo_keys", repo_keys)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @property
    @pulumi.getter(name="anyLocal")
    def any_local(self) -> pulumi.Input[bool]:
        """
        Trigger on any local repo.
        """
        return pulumi.get(self, "any_local")

    @any_local.setter
    def any_local(self, value: pulumi.Input[bool]):
        pulumi.set(self, "any_local", value)

    @property
    @pulumi.getter(name="anyRemote")
    def any_remote(self) -> pulumi.Input[bool]:
        """
        Trigger on any remote repo.
        """
        return pulumi.get(self, "any_remote")

    @any_remote.setter
    def any_remote(self, value: pulumi.Input[bool]):
        pulumi.set(self, "any_remote", value)

    @property
    @pulumi.getter(name="repoKeys")
    def repo_keys(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Trigger on this list of repo keys.
        """
        return pulumi.get(self, "repo_keys")

    @repo_keys.setter
    def repo_keys(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "repo_keys", value)

    @property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "exclude_patterns")

    @exclude_patterns.setter
    def exclude_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_patterns", value)

    @property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "include_patterns")

    @include_patterns.setter
    def include_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "include_patterns", value)


@pulumi.input_type
class ArtifactCustomWebhookHandlerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 payload: Optional[pulumi.Input[str]] = None,
                 proxy: Optional[pulumi.Input[str]] = None,
                 secrets: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] http_headers: HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        :param pulumi.Input[str] payload: This attribute is used to build the request body. Used in custom webhooks
        :param pulumi.Input[str] proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] secrets: Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example: 
               
               <!--Start PulumiCodeChooser -->
               ```python
               import pulumi
               ```
               <!--End PulumiCodeChooser -->
        """
        pulumi.set(__self__, "url", url)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        """
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "http_headers", value)

    @property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[str]]:
        """
        This attribute is used to build the request body. Used in custom webhooks
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "payload", value)

    @property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[str]]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy", value)

    @property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example: 

        <!--Start PulumiCodeChooser -->
        ```python
        import pulumi
        ```
        <!--End PulumiCodeChooser -->
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "secrets", value)


@pulumi.input_type
class ArtifactPropertyCustomWebhookCriteriaArgs:
    def __init__(__self__, *,
                 any_local: pulumi.Input[bool],
                 any_remote: pulumi.Input[bool],
                 repo_keys: pulumi.Input[Sequence[pulumi.Input[str]]],
                 exclude_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 include_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] any_local: Trigger on any local repo.
        :param pulumi.Input[bool] any_remote: Trigger on any remote repo.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] repo_keys: Trigger on this list of repo keys.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        pulumi.set(__self__, "any_local", any_local)
        pulumi.set(__self__, "any_remote", any_remote)
        pulumi.set(__self__, "repo_keys", repo_keys)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @property
    @pulumi.getter(name="anyLocal")
    def any_local(self) -> pulumi.Input[bool]:
        """
        Trigger on any local repo.
        """
        return pulumi.get(self, "any_local")

    @any_local.setter
    def any_local(self, value: pulumi.Input[bool]):
        pulumi.set(self, "any_local", value)

    @property
    @pulumi.getter(name="anyRemote")
    def any_remote(self) -> pulumi.Input[bool]:
        """
        Trigger on any remote repo.
        """
        return pulumi.get(self, "any_remote")

    @any_remote.setter
    def any_remote(self, value: pulumi.Input[bool]):
        pulumi.set(self, "any_remote", value)

    @property
    @pulumi.getter(name="repoKeys")
    def repo_keys(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Trigger on this list of repo keys.
        """
        return pulumi.get(self, "repo_keys")

    @repo_keys.setter
    def repo_keys(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "repo_keys", value)

    @property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "exclude_patterns")

    @exclude_patterns.setter
    def exclude_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_patterns", value)

    @property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "include_patterns")

    @include_patterns.setter
    def include_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "include_patterns", value)


@pulumi.input_type
class ArtifactPropertyCustomWebhookHandlerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 payload: Optional[pulumi.Input[str]] = None,
                 proxy: Optional[pulumi.Input[str]] = None,
                 secrets: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] http_headers: HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        :param pulumi.Input[str] payload: This attribute is used to build the request body. Used in custom webhooks
        :param pulumi.Input[str] proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] secrets: Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
               
               <!--Start PulumiCodeChooser -->
               ```python
               import pulumi
               ```
               <!--End PulumiCodeChooser -->
        """
        pulumi.set(__self__, "url", url)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        """
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "http_headers", value)

    @property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[str]]:
        """
        This attribute is used to build the request body. Used in custom webhooks
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "payload", value)

    @property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[str]]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy", value)

    @property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:

        <!--Start PulumiCodeChooser -->
        ```python
        import pulumi
        ```
        <!--End PulumiCodeChooser -->
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "secrets", value)


@pulumi.input_type
class ArtifactPropertyWebhookCriteriaArgs:
    def __init__(__self__, *,
                 any_local: pulumi.Input[bool],
                 any_remote: pulumi.Input[bool],
                 repo_keys: pulumi.Input[Sequence[pulumi.Input[str]]],
                 exclude_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 include_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] any_local: Trigger on any local repo.
        :param pulumi.Input[bool] any_remote: Trigger on any remote repo.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] repo_keys: Trigger on this list of repo keys.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        pulumi.set(__self__, "any_local", any_local)
        pulumi.set(__self__, "any_remote", any_remote)
        pulumi.set(__self__, "repo_keys", repo_keys)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @property
    @pulumi.getter(name="anyLocal")
    def any_local(self) -> pulumi.Input[bool]:
        """
        Trigger on any local repo.
        """
        return pulumi.get(self, "any_local")

    @any_local.setter
    def any_local(self, value: pulumi.Input[bool]):
        pulumi.set(self, "any_local", value)

    @property
    @pulumi.getter(name="anyRemote")
    def any_remote(self) -> pulumi.Input[bool]:
        """
        Trigger on any remote repo.
        """
        return pulumi.get(self, "any_remote")

    @any_remote.setter
    def any_remote(self, value: pulumi.Input[bool]):
        pulumi.set(self, "any_remote", value)

    @property
    @pulumi.getter(name="repoKeys")
    def repo_keys(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Trigger on this list of repo keys.
        """
        return pulumi.get(self, "repo_keys")

    @repo_keys.setter
    def repo_keys(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "repo_keys", value)

    @property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "exclude_patterns")

    @exclude_patterns.setter
    def exclude_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_patterns", value)

    @property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "include_patterns")

    @include_patterns.setter
    def include_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "include_patterns", value)


@pulumi.input_type
class ArtifactPropertyWebhookHandlerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 custom_http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 proxy: Optional[pulumi.Input[str]] = None,
                 secret: Optional[pulumi.Input[str]] = None,
                 use_secret_for_signing: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] custom_http_headers: Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        :param pulumi.Input[str] proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param pulumi.Input[str] secret: Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        :param pulumi.Input[bool] use_secret_for_signing: When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        pulumi.set(__self__, "url", url)
        if custom_http_headers is not None:
            pulumi.set(__self__, "custom_http_headers", custom_http_headers)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if use_secret_for_signing is not None:
            pulumi.set(__self__, "use_secret_for_signing", use_secret_for_signing)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="customHttpHeaders")
    def custom_http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        return pulumi.get(self, "custom_http_headers")

    @custom_http_headers.setter
    def custom_http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "custom_http_headers", value)

    @property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[str]]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy", value)

    @property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[str]]:
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret", value)

    @property
    @pulumi.getter(name="useSecretForSigning")
    def use_secret_for_signing(self) -> Optional[pulumi.Input[bool]]:
        """
        When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        return pulumi.get(self, "use_secret_for_signing")

    @use_secret_for_signing.setter
    def use_secret_for_signing(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_secret_for_signing", value)


@pulumi.input_type
class ArtifactWebhookCriteriaArgs:
    def __init__(__self__, *,
                 any_local: pulumi.Input[bool],
                 any_remote: pulumi.Input[bool],
                 repo_keys: pulumi.Input[Sequence[pulumi.Input[str]]],
                 exclude_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 include_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] any_local: Trigger on any local repo.
        :param pulumi.Input[bool] any_remote: Trigger on any remote repo.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] repo_keys: Trigger on this list of repo keys.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        pulumi.set(__self__, "any_local", any_local)
        pulumi.set(__self__, "any_remote", any_remote)
        pulumi.set(__self__, "repo_keys", repo_keys)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @property
    @pulumi.getter(name="anyLocal")
    def any_local(self) -> pulumi.Input[bool]:
        """
        Trigger on any local repo.
        """
        return pulumi.get(self, "any_local")

    @any_local.setter
    def any_local(self, value: pulumi.Input[bool]):
        pulumi.set(self, "any_local", value)

    @property
    @pulumi.getter(name="anyRemote")
    def any_remote(self) -> pulumi.Input[bool]:
        """
        Trigger on any remote repo.
        """
        return pulumi.get(self, "any_remote")

    @any_remote.setter
    def any_remote(self, value: pulumi.Input[bool]):
        pulumi.set(self, "any_remote", value)

    @property
    @pulumi.getter(name="repoKeys")
    def repo_keys(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Trigger on this list of repo keys.
        """
        return pulumi.get(self, "repo_keys")

    @repo_keys.setter
    def repo_keys(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "repo_keys", value)

    @property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "exclude_patterns")

    @exclude_patterns.setter
    def exclude_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_patterns", value)

    @property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "include_patterns")

    @include_patterns.setter
    def include_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "include_patterns", value)


@pulumi.input_type
class ArtifactWebhookHandlerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 custom_http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 proxy: Optional[pulumi.Input[str]] = None,
                 secret: Optional[pulumi.Input[str]] = None,
                 use_secret_for_signing: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] custom_http_headers: Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        :param pulumi.Input[str] proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param pulumi.Input[str] secret: Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        :param pulumi.Input[bool] use_secret_for_signing: When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        pulumi.set(__self__, "url", url)
        if custom_http_headers is not None:
            pulumi.set(__self__, "custom_http_headers", custom_http_headers)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if use_secret_for_signing is not None:
            pulumi.set(__self__, "use_secret_for_signing", use_secret_for_signing)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="customHttpHeaders")
    def custom_http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        return pulumi.get(self, "custom_http_headers")

    @custom_http_headers.setter
    def custom_http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "custom_http_headers", value)

    @property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[str]]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy", value)

    @property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[str]]:
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret", value)

    @property
    @pulumi.getter(name="useSecretForSigning")
    def use_secret_for_signing(self) -> Optional[pulumi.Input[bool]]:
        """
        When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        return pulumi.get(self, "use_secret_for_signing")

    @use_secret_for_signing.setter
    def use_secret_for_signing(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_secret_for_signing", value)


@pulumi.input_type
class ArtifactoryReleaseBundleCustomWebhookCriteriaArgs:
    def __init__(__self__, *,
                 any_release_bundle: pulumi.Input[bool],
                 registered_release_bundle_names: pulumi.Input[Sequence[pulumi.Input[str]]],
                 exclude_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 include_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] any_release_bundle: Trigger on any release bundle
        :param pulumi.Input[Sequence[pulumi.Input[str]]] registered_release_bundle_names: Trigger on this list of release bundle names
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`
        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`
        """
        pulumi.set(__self__, "any_release_bundle", any_release_bundle)
        pulumi.set(__self__, "registered_release_bundle_names", registered_release_bundle_names)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @property
    @pulumi.getter(name="anyReleaseBundle")
    def any_release_bundle(self) -> pulumi.Input[bool]:
        """
        Trigger on any release bundle
        """
        return pulumi.get(self, "any_release_bundle")

    @any_release_bundle.setter
    def any_release_bundle(self, value: pulumi.Input[bool]):
        pulumi.set(self, "any_release_bundle", value)

    @property
    @pulumi.getter(name="registeredReleaseBundleNames")
    def registered_release_bundle_names(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Trigger on this list of release bundle names
        """
        return pulumi.get(self, "registered_release_bundle_names")

    @registered_release_bundle_names.setter
    def registered_release_bundle_names(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "registered_release_bundle_names", value)

    @property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`
        """
        return pulumi.get(self, "exclude_patterns")

    @exclude_patterns.setter
    def exclude_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_patterns", value)

    @property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`
        """
        return pulumi.get(self, "include_patterns")

    @include_patterns.setter
    def include_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "include_patterns", value)


@pulumi.input_type
class ArtifactoryReleaseBundleCustomWebhookHandlerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 payload: Optional[pulumi.Input[str]] = None,
                 proxy: Optional[pulumi.Input[str]] = None,
                 secrets: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] http_headers: HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        :param pulumi.Input[str] payload: This attribute is used to build the request body. Used in custom webhooks
        :param pulumi.Input[str] proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] secrets: Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
               
               <!--Start PulumiCodeChooser -->
               ```python
               import pulumi
               ```
               <!--End PulumiCodeChooser -->
        """
        pulumi.set(__self__, "url", url)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        """
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "http_headers", value)

    @property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[str]]:
        """
        This attribute is used to build the request body. Used in custom webhooks
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "payload", value)

    @property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[str]]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy", value)

    @property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:

        <!--Start PulumiCodeChooser -->
        ```python
        import pulumi
        ```
        <!--End PulumiCodeChooser -->
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "secrets", value)


@pulumi.input_type
class ArtifactoryReleaseBundleWebhookCriteriaArgs:
    def __init__(__self__, *,
                 any_release_bundle: pulumi.Input[bool],
                 registered_release_bundle_names: pulumi.Input[Sequence[pulumi.Input[str]]],
                 exclude_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 include_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] any_release_bundle: Trigger on any release bundle
        :param pulumi.Input[Sequence[pulumi.Input[str]]] registered_release_bundle_names: Trigger on this list of release bundle names
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`
        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`
        """
        pulumi.set(__self__, "any_release_bundle", any_release_bundle)
        pulumi.set(__self__, "registered_release_bundle_names", registered_release_bundle_names)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @property
    @pulumi.getter(name="anyReleaseBundle")
    def any_release_bundle(self) -> pulumi.Input[bool]:
        """
        Trigger on any release bundle
        """
        return pulumi.get(self, "any_release_bundle")

    @any_release_bundle.setter
    def any_release_bundle(self, value: pulumi.Input[bool]):
        pulumi.set(self, "any_release_bundle", value)

    @property
    @pulumi.getter(name="registeredReleaseBundleNames")
    def registered_release_bundle_names(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Trigger on this list of release bundle names
        """
        return pulumi.get(self, "registered_release_bundle_names")

    @registered_release_bundle_names.setter
    def registered_release_bundle_names(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "registered_release_bundle_names", value)

    @property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`
        """
        return pulumi.get(self, "exclude_patterns")

    @exclude_patterns.setter
    def exclude_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_patterns", value)

    @property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`
        """
        return pulumi.get(self, "include_patterns")

    @include_patterns.setter
    def include_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "include_patterns", value)


@pulumi.input_type
class ArtifactoryReleaseBundleWebhookHandlerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 custom_http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 proxy: Optional[pulumi.Input[str]] = None,
                 secret: Optional[pulumi.Input[str]] = None,
                 use_secret_for_signing: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] custom_http_headers: Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        :param pulumi.Input[str] proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param pulumi.Input[str] secret: Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        :param pulumi.Input[bool] use_secret_for_signing: When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        pulumi.set(__self__, "url", url)
        if custom_http_headers is not None:
            pulumi.set(__self__, "custom_http_headers", custom_http_headers)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if use_secret_for_signing is not None:
            pulumi.set(__self__, "use_secret_for_signing", use_secret_for_signing)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="customHttpHeaders")
    def custom_http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        return pulumi.get(self, "custom_http_headers")

    @custom_http_headers.setter
    def custom_http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "custom_http_headers", value)

    @property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[str]]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy", value)

    @property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[str]]:
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret", value)

    @property
    @pulumi.getter(name="useSecretForSigning")
    def use_secret_for_signing(self) -> Optional[pulumi.Input[bool]]:
        """
        When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        return pulumi.get(self, "use_secret_for_signing")

    @use_secret_for_signing.setter
    def use_secret_for_signing(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_secret_for_signing", value)


@pulumi.input_type
class BuildCustomWebhookCriteriaArgs:
    def __init__(__self__, *,
                 any_build: pulumi.Input[bool],
                 selected_builds: pulumi.Input[Sequence[pulumi.Input[str]]],
                 exclude_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 include_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] any_build: Trigger on any build.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] selected_builds: Trigger on this list of build names.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        pulumi.set(__self__, "any_build", any_build)
        pulumi.set(__self__, "selected_builds", selected_builds)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @property
    @pulumi.getter(name="anyBuild")
    def any_build(self) -> pulumi.Input[bool]:
        """
        Trigger on any build.
        """
        return pulumi.get(self, "any_build")

    @any_build.setter
    def any_build(self, value: pulumi.Input[bool]):
        pulumi.set(self, "any_build", value)

    @property
    @pulumi.getter(name="selectedBuilds")
    def selected_builds(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Trigger on this list of build names.
        """
        return pulumi.get(self, "selected_builds")

    @selected_builds.setter
    def selected_builds(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "selected_builds", value)

    @property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "exclude_patterns")

    @exclude_patterns.setter
    def exclude_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_patterns", value)

    @property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "include_patterns")

    @include_patterns.setter
    def include_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "include_patterns", value)


@pulumi.input_type
class BuildCustomWebhookHandlerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 payload: Optional[pulumi.Input[str]] = None,
                 proxy: Optional[pulumi.Input[str]] = None,
                 secrets: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] http_headers: HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        :param pulumi.Input[str] payload: This attribute is used to build the request body. Used in custom webhooks
        :param pulumi.Input[str] proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] secrets: Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
               
               <!--Start PulumiCodeChooser -->
               ```python
               import pulumi
               ```
               <!--End PulumiCodeChooser -->
        """
        pulumi.set(__self__, "url", url)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        """
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "http_headers", value)

    @property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[str]]:
        """
        This attribute is used to build the request body. Used in custom webhooks
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "payload", value)

    @property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[str]]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy", value)

    @property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:

        <!--Start PulumiCodeChooser -->
        ```python
        import pulumi
        ```
        <!--End PulumiCodeChooser -->
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "secrets", value)


@pulumi.input_type
class BuildWebhookCriteriaArgs:
    def __init__(__self__, *,
                 any_build: pulumi.Input[bool],
                 selected_builds: pulumi.Input[Sequence[pulumi.Input[str]]],
                 exclude_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 include_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] any_build: Trigger on any build.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] selected_builds: Trigger on this list of build names.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        pulumi.set(__self__, "any_build", any_build)
        pulumi.set(__self__, "selected_builds", selected_builds)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @property
    @pulumi.getter(name="anyBuild")
    def any_build(self) -> pulumi.Input[bool]:
        """
        Trigger on any build.
        """
        return pulumi.get(self, "any_build")

    @any_build.setter
    def any_build(self, value: pulumi.Input[bool]):
        pulumi.set(self, "any_build", value)

    @property
    @pulumi.getter(name="selectedBuilds")
    def selected_builds(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Trigger on this list of build names.
        """
        return pulumi.get(self, "selected_builds")

    @selected_builds.setter
    def selected_builds(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "selected_builds", value)

    @property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "exclude_patterns")

    @exclude_patterns.setter
    def exclude_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_patterns", value)

    @property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "include_patterns")

    @include_patterns.setter
    def include_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "include_patterns", value)


@pulumi.input_type
class BuildWebhookHandlerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 custom_http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 proxy: Optional[pulumi.Input[str]] = None,
                 secret: Optional[pulumi.Input[str]] = None,
                 use_secret_for_signing: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] custom_http_headers: Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        :param pulumi.Input[str] proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param pulumi.Input[str] secret: Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        :param pulumi.Input[bool] use_secret_for_signing: When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        pulumi.set(__self__, "url", url)
        if custom_http_headers is not None:
            pulumi.set(__self__, "custom_http_headers", custom_http_headers)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if use_secret_for_signing is not None:
            pulumi.set(__self__, "use_secret_for_signing", use_secret_for_signing)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="customHttpHeaders")
    def custom_http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        return pulumi.get(self, "custom_http_headers")

    @custom_http_headers.setter
    def custom_http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "custom_http_headers", value)

    @property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[str]]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy", value)

    @property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[str]]:
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret", value)

    @property
    @pulumi.getter(name="useSecretForSigning")
    def use_secret_for_signing(self) -> Optional[pulumi.Input[bool]]:
        """
        When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        return pulumi.get(self, "use_secret_for_signing")

    @use_secret_for_signing.setter
    def use_secret_for_signing(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_secret_for_signing", value)


@pulumi.input_type
class DistributionCustomWebhookCriteriaArgs:
    def __init__(__self__, *,
                 any_release_bundle: pulumi.Input[bool],
                 registered_release_bundle_names: pulumi.Input[Sequence[pulumi.Input[str]]],
                 exclude_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 include_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] any_release_bundle: Trigger on any release bundle.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] registered_release_bundle_names: Trigger on this list of release bundle names.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        pulumi.set(__self__, "any_release_bundle", any_release_bundle)
        pulumi.set(__self__, "registered_release_bundle_names", registered_release_bundle_names)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @property
    @pulumi.getter(name="anyReleaseBundle")
    def any_release_bundle(self) -> pulumi.Input[bool]:
        """
        Trigger on any release bundle.
        """
        return pulumi.get(self, "any_release_bundle")

    @any_release_bundle.setter
    def any_release_bundle(self, value: pulumi.Input[bool]):
        pulumi.set(self, "any_release_bundle", value)

    @property
    @pulumi.getter(name="registeredReleaseBundleNames")
    def registered_release_bundle_names(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Trigger on this list of release bundle names.
        """
        return pulumi.get(self, "registered_release_bundle_names")

    @registered_release_bundle_names.setter
    def registered_release_bundle_names(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "registered_release_bundle_names", value)

    @property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "exclude_patterns")

    @exclude_patterns.setter
    def exclude_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_patterns", value)

    @property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "include_patterns")

    @include_patterns.setter
    def include_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "include_patterns", value)


@pulumi.input_type
class DistributionCustomWebhookHandlerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 payload: Optional[pulumi.Input[str]] = None,
                 proxy: Optional[pulumi.Input[str]] = None,
                 secrets: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] http_headers: HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        :param pulumi.Input[str] payload: This attribute is used to build the request body. Used in custom webhooks
        :param pulumi.Input[str] proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] secrets: Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
               
               <!--Start PulumiCodeChooser -->
               ```python
               import pulumi
               ```
               <!--End PulumiCodeChooser -->
        """
        pulumi.set(__self__, "url", url)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        """
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "http_headers", value)

    @property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[str]]:
        """
        This attribute is used to build the request body. Used in custom webhooks
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "payload", value)

    @property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[str]]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy", value)

    @property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:

        <!--Start PulumiCodeChooser -->
        ```python
        import pulumi
        ```
        <!--End PulumiCodeChooser -->
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "secrets", value)


@pulumi.input_type
class DistributionWebhookCriteriaArgs:
    def __init__(__self__, *,
                 any_release_bundle: pulumi.Input[bool],
                 registered_release_bundle_names: pulumi.Input[Sequence[pulumi.Input[str]]],
                 exclude_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 include_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] any_release_bundle: Trigger on any release bundle.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] registered_release_bundle_names: Trigger on this list of release bundle names.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        pulumi.set(__self__, "any_release_bundle", any_release_bundle)
        pulumi.set(__self__, "registered_release_bundle_names", registered_release_bundle_names)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @property
    @pulumi.getter(name="anyReleaseBundle")
    def any_release_bundle(self) -> pulumi.Input[bool]:
        """
        Trigger on any release bundle.
        """
        return pulumi.get(self, "any_release_bundle")

    @any_release_bundle.setter
    def any_release_bundle(self, value: pulumi.Input[bool]):
        pulumi.set(self, "any_release_bundle", value)

    @property
    @pulumi.getter(name="registeredReleaseBundleNames")
    def registered_release_bundle_names(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Trigger on this list of release bundle names.
        """
        return pulumi.get(self, "registered_release_bundle_names")

    @registered_release_bundle_names.setter
    def registered_release_bundle_names(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "registered_release_bundle_names", value)

    @property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "exclude_patterns")

    @exclude_patterns.setter
    def exclude_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_patterns", value)

    @property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "include_patterns")

    @include_patterns.setter
    def include_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "include_patterns", value)


@pulumi.input_type
class DistributionWebhookHandlerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 custom_http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 proxy: Optional[pulumi.Input[str]] = None,
                 secret: Optional[pulumi.Input[str]] = None,
                 use_secret_for_signing: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] custom_http_headers: Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        :param pulumi.Input[str] proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param pulumi.Input[str] secret: Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        :param pulumi.Input[bool] use_secret_for_signing: When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        pulumi.set(__self__, "url", url)
        if custom_http_headers is not None:
            pulumi.set(__self__, "custom_http_headers", custom_http_headers)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if use_secret_for_signing is not None:
            pulumi.set(__self__, "use_secret_for_signing", use_secret_for_signing)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="customHttpHeaders")
    def custom_http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        return pulumi.get(self, "custom_http_headers")

    @custom_http_headers.setter
    def custom_http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "custom_http_headers", value)

    @property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[str]]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy", value)

    @property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[str]]:
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret", value)

    @property
    @pulumi.getter(name="useSecretForSigning")
    def use_secret_for_signing(self) -> Optional[pulumi.Input[bool]]:
        """
        When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        return pulumi.get(self, "use_secret_for_signing")

    @use_secret_for_signing.setter
    def use_secret_for_signing(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_secret_for_signing", value)


@pulumi.input_type
class DockerCustomWebhookCriteriaArgs:
    def __init__(__self__, *,
                 any_local: pulumi.Input[bool],
                 any_remote: pulumi.Input[bool],
                 repo_keys: pulumi.Input[Sequence[pulumi.Input[str]]],
                 exclude_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 include_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] any_local: Trigger on any local repo.
        :param pulumi.Input[bool] any_remote: Trigger on any remote repo.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] repo_keys: Trigger on this list of repo keys.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        pulumi.set(__self__, "any_local", any_local)
        pulumi.set(__self__, "any_remote", any_remote)
        pulumi.set(__self__, "repo_keys", repo_keys)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @property
    @pulumi.getter(name="anyLocal")
    def any_local(self) -> pulumi.Input[bool]:
        """
        Trigger on any local repo.
        """
        return pulumi.get(self, "any_local")

    @any_local.setter
    def any_local(self, value: pulumi.Input[bool]):
        pulumi.set(self, "any_local", value)

    @property
    @pulumi.getter(name="anyRemote")
    def any_remote(self) -> pulumi.Input[bool]:
        """
        Trigger on any remote repo.
        """
        return pulumi.get(self, "any_remote")

    @any_remote.setter
    def any_remote(self, value: pulumi.Input[bool]):
        pulumi.set(self, "any_remote", value)

    @property
    @pulumi.getter(name="repoKeys")
    def repo_keys(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Trigger on this list of repo keys.
        """
        return pulumi.get(self, "repo_keys")

    @repo_keys.setter
    def repo_keys(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "repo_keys", value)

    @property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "exclude_patterns")

    @exclude_patterns.setter
    def exclude_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_patterns", value)

    @property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "include_patterns")

    @include_patterns.setter
    def include_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "include_patterns", value)


@pulumi.input_type
class DockerCustomWebhookHandlerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 payload: Optional[pulumi.Input[str]] = None,
                 proxy: Optional[pulumi.Input[str]] = None,
                 secrets: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] http_headers: HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        :param pulumi.Input[str] payload: This attribute is used to build the request body. Used in custom webhooks
        :param pulumi.Input[str] proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] secrets: Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
               
               <!--Start PulumiCodeChooser -->
               ```python
               import pulumi
               ```
               <!--End PulumiCodeChooser -->
        """
        pulumi.set(__self__, "url", url)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        """
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "http_headers", value)

    @property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[str]]:
        """
        This attribute is used to build the request body. Used in custom webhooks
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "payload", value)

    @property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[str]]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy", value)

    @property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:

        <!--Start PulumiCodeChooser -->
        ```python
        import pulumi
        ```
        <!--End PulumiCodeChooser -->
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "secrets", value)


@pulumi.input_type
class DockerWebhookCriteriaArgs:
    def __init__(__self__, *,
                 any_local: pulumi.Input[bool],
                 any_remote: pulumi.Input[bool],
                 repo_keys: pulumi.Input[Sequence[pulumi.Input[str]]],
                 exclude_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 include_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] any_local: Trigger on any local repo.
        :param pulumi.Input[bool] any_remote: Trigger on any remote repo.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] repo_keys: Trigger on this list of repo keys.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        pulumi.set(__self__, "any_local", any_local)
        pulumi.set(__self__, "any_remote", any_remote)
        pulumi.set(__self__, "repo_keys", repo_keys)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @property
    @pulumi.getter(name="anyLocal")
    def any_local(self) -> pulumi.Input[bool]:
        """
        Trigger on any local repo.
        """
        return pulumi.get(self, "any_local")

    @any_local.setter
    def any_local(self, value: pulumi.Input[bool]):
        pulumi.set(self, "any_local", value)

    @property
    @pulumi.getter(name="anyRemote")
    def any_remote(self) -> pulumi.Input[bool]:
        """
        Trigger on any remote repo.
        """
        return pulumi.get(self, "any_remote")

    @any_remote.setter
    def any_remote(self, value: pulumi.Input[bool]):
        pulumi.set(self, "any_remote", value)

    @property
    @pulumi.getter(name="repoKeys")
    def repo_keys(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Trigger on this list of repo keys.
        """
        return pulumi.get(self, "repo_keys")

    @repo_keys.setter
    def repo_keys(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "repo_keys", value)

    @property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "exclude_patterns")

    @exclude_patterns.setter
    def exclude_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_patterns", value)

    @property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "include_patterns")

    @include_patterns.setter
    def include_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "include_patterns", value)


@pulumi.input_type
class DockerWebhookHandlerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 custom_http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 proxy: Optional[pulumi.Input[str]] = None,
                 secret: Optional[pulumi.Input[str]] = None,
                 use_secret_for_signing: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] custom_http_headers: Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        :param pulumi.Input[str] proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param pulumi.Input[str] secret: Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        :param pulumi.Input[bool] use_secret_for_signing: When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        pulumi.set(__self__, "url", url)
        if custom_http_headers is not None:
            pulumi.set(__self__, "custom_http_headers", custom_http_headers)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if use_secret_for_signing is not None:
            pulumi.set(__self__, "use_secret_for_signing", use_secret_for_signing)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="customHttpHeaders")
    def custom_http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        return pulumi.get(self, "custom_http_headers")

    @custom_http_headers.setter
    def custom_http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "custom_http_headers", value)

    @property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[str]]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy", value)

    @property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[str]]:
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret", value)

    @property
    @pulumi.getter(name="useSecretForSigning")
    def use_secret_for_signing(self) -> Optional[pulumi.Input[bool]]:
        """
        When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        return pulumi.get(self, "use_secret_for_signing")

    @use_secret_for_signing.setter
    def use_secret_for_signing(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_secret_for_signing", value)


@pulumi.input_type
class FederatedAlpineRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str]):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class FederatedBowerRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str]):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class FederatedCargoRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str]):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class FederatedChefRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str]):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class FederatedCocoapodsRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str]):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class FederatedComposerRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str]):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class FederatedConanRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str]):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class FederatedCondaRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str]):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class FederatedCranRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str]):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class FederatedDebianRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str]):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class FederatedDockerRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str]):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class FederatedDockerV1RepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str]):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class FederatedDockerV2RepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str]):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class FederatedGemsRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str]):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class FederatedGenericRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str]):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class FederatedGitltfsRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str]):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class FederatedGoRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str]):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class FederatedGradleRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str]):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class FederatedHelmRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str]):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class FederatedHelmociRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str]):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class FederatedIvyRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str]):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class FederatedMavenRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str]):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class FederatedNpmRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str]):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class FederatedNugetRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str]):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class FederatedOciRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str]):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class FederatedOpkgRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str]):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class FederatedPuppetRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str]):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class FederatedPypiRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str]):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class FederatedRpmRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str]):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class FederatedSbtRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str]):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class FederatedSwiftRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str]):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class FederatedTerraformModuleRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str]):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class FederatedTerraformProviderRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str]):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class FederatedVagrantRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 url: pulumi.Input[str]):
        """
        :param pulumi.Input[bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[str] url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class LocalRepositoryMultiReplicationReplicationArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 username: pulumi.Input[str],
                 check_binary_existence_in_filestore: Optional[pulumi.Input[bool]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 exclude_path_prefix_pattern: Optional[pulumi.Input[str]] = None,
                 include_path_prefix_pattern: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 proxy: Optional[pulumi.Input[str]] = None,
                 replication_key: Optional[pulumi.Input[str]] = None,
                 socket_timeout_millis: Optional[pulumi.Input[int]] = None,
                 sync_deletes: Optional[pulumi.Input[bool]] = None,
                 sync_properties: Optional[pulumi.Input[bool]] = None,
                 sync_statistics: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] url: The URL of the target local repository on a remote Artifactory server. Use the format `https://<artifactory_url>/artifactory/<repository_name>`.
        :param pulumi.Input[str] username: Username on the remote Artifactory instance.
        :param pulumi.Input[bool] check_binary_existence_in_filestore: Enabling the `check_binary_existence_in_filestore` flag requires an Enterprise Plus license. When true, enables distributed checksum storage. For more information, see [Optimizing Repository Replication with Checksum-Based Storage](https://www.jfrog.com/confluence/display/JFROG/Repository+Replication#RepositoryReplication-OptimizingRepositoryReplicationUsingStorageLevelSynchronizationOptions).
        :param pulumi.Input[bool] enabled: When set, enables replication of this repository to the target specified in `url` attribute. Default value is `true`.
        :param pulumi.Input[str] exclude_path_prefix_pattern: List of artifact patterns to exclude when evaluating artifact requests, in the form of `x/y/**/z/*`. By default, no artifacts are excluded.
        :param pulumi.Input[str] include_path_prefix_pattern: List of artifact patterns to include when evaluating artifact requests in the form of `x/y/**/z/*`. When used, only artifacts matching one of the include patterns are served. By default, all artifacts are included `(**/*)`.
        :param pulumi.Input[str] password: Use either the HTTP authentication password or [identity token](https://www.jfrog.com/confluence/display/JFROG/User+Profile#UserProfile-IdentityTokenidentitytoken).
        :param pulumi.Input[str] proxy: Proxy key from Artifactory Proxies settings. The proxy configuration will be used when communicating with the remote instance.
        :param pulumi.Input[str] replication_key: Replication ID, the value is unknown until the resource is created. Can't be set or updated.
        :param pulumi.Input[int] socket_timeout_millis: The network timeout in milliseconds to use for remote operations. Default value is `15000`.
        :param pulumi.Input[bool] sync_deletes: When set, items that were deleted locally should also be deleted remotely (also applies to properties metadata). Note that enabling this option, will delete artifacts on the target that do not exist in the source repository. Default value is `false`.
        :param pulumi.Input[bool] sync_properties: When set, the task also synchronizes the properties of replicated artifacts. Default value is `true`.
        :param pulumi.Input[bool] sync_statistics: When set, the task also synchronizes artifact download statistics. Set to avoid inadvertent cleanup at the target instance when setting up replication for disaster recovery. Default value is `false`
        """
        pulumi.set(__self__, "url", url)
        pulumi.set(__self__, "username", username)
        if check_binary_existence_in_filestore is not None:
            pulumi.set(__self__, "check_binary_existence_in_filestore", check_binary_existence_in_filestore)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if exclude_path_prefix_pattern is not None:
            pulumi.set(__self__, "exclude_path_prefix_pattern", exclude_path_prefix_pattern)
        if include_path_prefix_pattern is not None:
            pulumi.set(__self__, "include_path_prefix_pattern", include_path_prefix_pattern)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if replication_key is not None:
            pulumi.set(__self__, "replication_key", replication_key)
        if socket_timeout_millis is not None:
            pulumi.set(__self__, "socket_timeout_millis", socket_timeout_millis)
        if sync_deletes is not None:
            pulumi.set(__self__, "sync_deletes", sync_deletes)
        if sync_properties is not None:
            pulumi.set(__self__, "sync_properties", sync_properties)
        if sync_statistics is not None:
            pulumi.set(__self__, "sync_statistics", sync_statistics)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        The URL of the target local repository on a remote Artifactory server. Use the format `https://<artifactory_url>/artifactory/<repository_name>`.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        Username on the remote Artifactory instance.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="checkBinaryExistenceInFilestore")
    def check_binary_existence_in_filestore(self) -> Optional[pulumi.Input[bool]]:
        """
        Enabling the `check_binary_existence_in_filestore` flag requires an Enterprise Plus license. When true, enables distributed checksum storage. For more information, see [Optimizing Repository Replication with Checksum-Based Storage](https://www.jfrog.com/confluence/display/JFROG/Repository+Replication#RepositoryReplication-OptimizingRepositoryReplicationUsingStorageLevelSynchronizationOptions).
        """
        return pulumi.get(self, "check_binary_existence_in_filestore")

    @check_binary_existence_in_filestore.setter
    def check_binary_existence_in_filestore(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "check_binary_existence_in_filestore", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        When set, enables replication of this repository to the target specified in `url` attribute. Default value is `true`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="excludePathPrefixPattern")
    def exclude_path_prefix_pattern(self) -> Optional[pulumi.Input[str]]:
        """
        List of artifact patterns to exclude when evaluating artifact requests, in the form of `x/y/**/z/*`. By default, no artifacts are excluded.
        """
        return pulumi.get(self, "exclude_path_prefix_pattern")

    @exclude_path_prefix_pattern.setter
    def exclude_path_prefix_pattern(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exclude_path_prefix_pattern", value)

    @property
    @pulumi.getter(name="includePathPrefixPattern")
    def include_path_prefix_pattern(self) -> Optional[pulumi.Input[str]]:
        """
        List of artifact patterns to include when evaluating artifact requests in the form of `x/y/**/z/*`. When used, only artifacts matching one of the include patterns are served. By default, all artifacts are included `(**/*)`.
        """
        return pulumi.get(self, "include_path_prefix_pattern")

    @include_path_prefix_pattern.setter
    def include_path_prefix_pattern(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "include_path_prefix_pattern", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        Use either the HTTP authentication password or [identity token](https://www.jfrog.com/confluence/display/JFROG/User+Profile#UserProfile-IdentityTokenidentitytoken).
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[str]]:
        """
        Proxy key from Artifactory Proxies settings. The proxy configuration will be used when communicating with the remote instance.
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy", value)

    @property
    @pulumi.getter(name="replicationKey")
    def replication_key(self) -> Optional[pulumi.Input[str]]:
        """
        Replication ID, the value is unknown until the resource is created. Can't be set or updated.
        """
        return pulumi.get(self, "replication_key")

    @replication_key.setter
    def replication_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replication_key", value)

    @property
    @pulumi.getter(name="socketTimeoutMillis")
    def socket_timeout_millis(self) -> Optional[pulumi.Input[int]]:
        """
        The network timeout in milliseconds to use for remote operations. Default value is `15000`.
        """
        return pulumi.get(self, "socket_timeout_millis")

    @socket_timeout_millis.setter
    def socket_timeout_millis(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "socket_timeout_millis", value)

    @property
    @pulumi.getter(name="syncDeletes")
    def sync_deletes(self) -> Optional[pulumi.Input[bool]]:
        """
        When set, items that were deleted locally should also be deleted remotely (also applies to properties metadata). Note that enabling this option, will delete artifacts on the target that do not exist in the source repository. Default value is `false`.
        """
        return pulumi.get(self, "sync_deletes")

    @sync_deletes.setter
    def sync_deletes(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sync_deletes", value)

    @property
    @pulumi.getter(name="syncProperties")
    def sync_properties(self) -> Optional[pulumi.Input[bool]]:
        """
        When set, the task also synchronizes the properties of replicated artifacts. Default value is `true`.
        """
        return pulumi.get(self, "sync_properties")

    @sync_properties.setter
    def sync_properties(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sync_properties", value)

    @property
    @pulumi.getter(name="syncStatistics")
    def sync_statistics(self) -> Optional[pulumi.Input[bool]]:
        """
        When set, the task also synchronizes artifact download statistics. Set to avoid inadvertent cleanup at the target instance when setting up replication for disaster recovery. Default value is `false`
        """
        return pulumi.get(self, "sync_statistics")

    @sync_statistics.setter
    def sync_statistics(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sync_statistics", value)


@pulumi.input_type
class OauthSettingsOauthProviderArgs:
    def __init__(__self__, *,
                 api_url: pulumi.Input[str],
                 auth_url: pulumi.Input[str],
                 client_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str],
                 name: pulumi.Input[str],
                 token_url: pulumi.Input[str],
                 type: pulumi.Input[str],
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] api_url: OAuth user info endpoint for the IdP.
        :param pulumi.Input[str] auth_url: OAuth authorization endpoint for the IdP.
        :param pulumi.Input[str] client_id: OAuth client ID configured on the IdP.
        :param pulumi.Input[str] client_secret: OAuth client secret configured on the IdP.
        :param pulumi.Input[str] name: Name of the Artifactory OAuth provider.
        :param pulumi.Input[str] token_url: OAuth token endpoint for the IdP.
        :param pulumi.Input[str] type: Type of OAuth provider. (e.g., `github`, `google`, `cloudfoundry`, or `openId`)
        :param pulumi.Input[bool] enabled: Enable the Artifactory OAuth provider.  Default value is `true`.
        """
        pulumi.set(__self__, "api_url", api_url)
        pulumi.set(__self__, "auth_url", auth_url)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "token_url", token_url)
        pulumi.set(__self__, "type", type)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="apiUrl")
    def api_url(self) -> pulumi.Input[str]:
        """
        OAuth user info endpoint for the IdP.
        """
        return pulumi.get(self, "api_url")

    @api_url.setter
    def api_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_url", value)

    @property
    @pulumi.getter(name="authUrl")
    def auth_url(self) -> pulumi.Input[str]:
        """
        OAuth authorization endpoint for the IdP.
        """
        return pulumi.get(self, "auth_url")

    @auth_url.setter
    def auth_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "auth_url", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        OAuth client ID configured on the IdP.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        """
        OAuth client secret configured on the IdP.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the Artifactory OAuth provider.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="tokenUrl")
    def token_url(self) -> pulumi.Input[str]:
        """
        OAuth token endpoint for the IdP.
        """
        return pulumi.get(self, "token_url")

    @token_url.setter
    def token_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "token_url", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of OAuth provider. (e.g., `github`, `google`, `cloudfoundry`, or `openId`)
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable the Artifactory OAuth provider.  Default value is `true`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class PermissionTargetBuildArgs:
    def __init__(__self__, *,
                 repositories: pulumi.Input[Sequence[pulumi.Input[str]]],
                 actions: Optional[pulumi.Input['PermissionTargetBuildActionsArgs']] = None,
                 excludes_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 includes_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] repositories: List of repositories this permission target is applicable for. You can specify the name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excludes_patterns: Pattern of artifacts to exclude.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] includes_patterns: Pattern of artifacts to include.
        """
        pulumi.set(__self__, "repositories", repositories)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if excludes_patterns is not None:
            pulumi.set(__self__, "excludes_patterns", excludes_patterns)
        if includes_patterns is not None:
            pulumi.set(__self__, "includes_patterns", includes_patterns)

    @property
    @pulumi.getter
    def repositories(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of repositories this permission target is applicable for. You can specify the name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        """
        return pulumi.get(self, "repositories")

    @repositories.setter
    def repositories(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "repositories", value)

    @property
    @pulumi.getter
    def actions(self) -> Optional[pulumi.Input['PermissionTargetBuildActionsArgs']]:
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional[pulumi.Input['PermissionTargetBuildActionsArgs']]):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter(name="excludesPatterns")
    def excludes_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Pattern of artifacts to exclude.
        """
        return pulumi.get(self, "excludes_patterns")

    @excludes_patterns.setter
    def excludes_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excludes_patterns", value)

    @property
    @pulumi.getter(name="includesPatterns")
    def includes_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Pattern of artifacts to include.
        """
        return pulumi.get(self, "includes_patterns")

    @includes_patterns.setter
    def includes_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "includes_patterns", value)


@pulumi.input_type
class PermissionTargetBuildActionsArgs:
    def __init__(__self__, *,
                 groups: Optional[pulumi.Input[Sequence[pulumi.Input['PermissionTargetBuildActionsGroupArgs']]]] = None,
                 users: Optional[pulumi.Input[Sequence[pulumi.Input['PermissionTargetBuildActionsUserArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PermissionTargetBuildActionsGroupArgs']]] groups: Groups this permission applies for.
        :param pulumi.Input[Sequence[pulumi.Input['PermissionTargetBuildActionsUserArgs']]] users: Users this permission target applies for.
        """
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PermissionTargetBuildActionsGroupArgs']]]]:
        """
        Groups this permission applies for.
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PermissionTargetBuildActionsGroupArgs']]]]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter
    def users(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PermissionTargetBuildActionsUserArgs']]]]:
        """
        Users this permission target applies for.
        """
        return pulumi.get(self, "users")

    @users.setter
    def users(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PermissionTargetBuildActionsUserArgs']]]]):
        pulumi.set(self, "users", value)


@pulumi.input_type
class PermissionTargetBuildActionsGroupArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 permissions: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] name: Name of permission.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of permission.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def permissions(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "permissions", value)


@pulumi.input_type
class PermissionTargetBuildActionsUserArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 permissions: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] name: Name of permission.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of permission.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def permissions(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "permissions", value)


@pulumi.input_type
class PermissionTargetReleaseBundleArgs:
    def __init__(__self__, *,
                 repositories: pulumi.Input[Sequence[pulumi.Input[str]]],
                 actions: Optional[pulumi.Input['PermissionTargetReleaseBundleActionsArgs']] = None,
                 excludes_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 includes_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] repositories: List of repositories this permission target is applicable for. You can specify the name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excludes_patterns: Pattern of artifacts to exclude.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] includes_patterns: Pattern of artifacts to include.
        """
        pulumi.set(__self__, "repositories", repositories)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if excludes_patterns is not None:
            pulumi.set(__self__, "excludes_patterns", excludes_patterns)
        if includes_patterns is not None:
            pulumi.set(__self__, "includes_patterns", includes_patterns)

    @property
    @pulumi.getter
    def repositories(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of repositories this permission target is applicable for. You can specify the name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        """
        return pulumi.get(self, "repositories")

    @repositories.setter
    def repositories(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "repositories", value)

    @property
    @pulumi.getter
    def actions(self) -> Optional[pulumi.Input['PermissionTargetReleaseBundleActionsArgs']]:
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional[pulumi.Input['PermissionTargetReleaseBundleActionsArgs']]):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter(name="excludesPatterns")
    def excludes_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Pattern of artifacts to exclude.
        """
        return pulumi.get(self, "excludes_patterns")

    @excludes_patterns.setter
    def excludes_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excludes_patterns", value)

    @property
    @pulumi.getter(name="includesPatterns")
    def includes_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Pattern of artifacts to include.
        """
        return pulumi.get(self, "includes_patterns")

    @includes_patterns.setter
    def includes_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "includes_patterns", value)


@pulumi.input_type
class PermissionTargetReleaseBundleActionsArgs:
    def __init__(__self__, *,
                 groups: Optional[pulumi.Input[Sequence[pulumi.Input['PermissionTargetReleaseBundleActionsGroupArgs']]]] = None,
                 users: Optional[pulumi.Input[Sequence[pulumi.Input['PermissionTargetReleaseBundleActionsUserArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PermissionTargetReleaseBundleActionsGroupArgs']]] groups: Groups this permission applies for.
        :param pulumi.Input[Sequence[pulumi.Input['PermissionTargetReleaseBundleActionsUserArgs']]] users: Users this permission target applies for.
        """
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PermissionTargetReleaseBundleActionsGroupArgs']]]]:
        """
        Groups this permission applies for.
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PermissionTargetReleaseBundleActionsGroupArgs']]]]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter
    def users(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PermissionTargetReleaseBundleActionsUserArgs']]]]:
        """
        Users this permission target applies for.
        """
        return pulumi.get(self, "users")

    @users.setter
    def users(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PermissionTargetReleaseBundleActionsUserArgs']]]]):
        pulumi.set(self, "users", value)


@pulumi.input_type
class PermissionTargetReleaseBundleActionsGroupArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 permissions: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] name: Name of permission.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of permission.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def permissions(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "permissions", value)


@pulumi.input_type
class PermissionTargetReleaseBundleActionsUserArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 permissions: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] name: Name of permission.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of permission.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def permissions(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "permissions", value)


@pulumi.input_type
class PermissionTargetRepoArgs:
    def __init__(__self__, *,
                 repositories: pulumi.Input[Sequence[pulumi.Input[str]]],
                 actions: Optional[pulumi.Input['PermissionTargetRepoActionsArgs']] = None,
                 excludes_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 includes_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] repositories: List of repositories this permission target is applicable for. You can specify the name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excludes_patterns: Pattern of artifacts to exclude.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] includes_patterns: Pattern of artifacts to include.
        """
        pulumi.set(__self__, "repositories", repositories)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if excludes_patterns is not None:
            pulumi.set(__self__, "excludes_patterns", excludes_patterns)
        if includes_patterns is not None:
            pulumi.set(__self__, "includes_patterns", includes_patterns)

    @property
    @pulumi.getter
    def repositories(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of repositories this permission target is applicable for. You can specify the name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        """
        return pulumi.get(self, "repositories")

    @repositories.setter
    def repositories(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "repositories", value)

    @property
    @pulumi.getter
    def actions(self) -> Optional[pulumi.Input['PermissionTargetRepoActionsArgs']]:
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional[pulumi.Input['PermissionTargetRepoActionsArgs']]):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter(name="excludesPatterns")
    def excludes_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Pattern of artifacts to exclude.
        """
        return pulumi.get(self, "excludes_patterns")

    @excludes_patterns.setter
    def excludes_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excludes_patterns", value)

    @property
    @pulumi.getter(name="includesPatterns")
    def includes_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Pattern of artifacts to include.
        """
        return pulumi.get(self, "includes_patterns")

    @includes_patterns.setter
    def includes_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "includes_patterns", value)


@pulumi.input_type
class PermissionTargetRepoActionsArgs:
    def __init__(__self__, *,
                 groups: Optional[pulumi.Input[Sequence[pulumi.Input['PermissionTargetRepoActionsGroupArgs']]]] = None,
                 users: Optional[pulumi.Input[Sequence[pulumi.Input['PermissionTargetRepoActionsUserArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PermissionTargetRepoActionsGroupArgs']]] groups: Groups this permission applies for.
        :param pulumi.Input[Sequence[pulumi.Input['PermissionTargetRepoActionsUserArgs']]] users: Users this permission target applies for.
        """
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PermissionTargetRepoActionsGroupArgs']]]]:
        """
        Groups this permission applies for.
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PermissionTargetRepoActionsGroupArgs']]]]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter
    def users(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PermissionTargetRepoActionsUserArgs']]]]:
        """
        Users this permission target applies for.
        """
        return pulumi.get(self, "users")

    @users.setter
    def users(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PermissionTargetRepoActionsUserArgs']]]]):
        pulumi.set(self, "users", value)


@pulumi.input_type
class PermissionTargetRepoActionsGroupArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 permissions: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] name: Name of permission.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of permission.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def permissions(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "permissions", value)


@pulumi.input_type
class PermissionTargetRepoActionsUserArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 permissions: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] name: Name of permission.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of permission.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def permissions(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "permissions", value)


@pulumi.input_type
class PropertySetPropertyArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 predefined_values: pulumi.Input[Sequence[pulumi.Input['PropertySetPropertyPredefinedValueArgs']]],
                 closed_predefined_values: Optional[pulumi.Input[bool]] = None,
                 multiple_choice: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] name: Predefined property name.
        :param pulumi.Input[Sequence[pulumi.Input['PropertySetPropertyPredefinedValueArgs']]] predefined_values: Properties in the property set.
        :param pulumi.Input[bool] closed_predefined_values: Disables `multiple_choice` if set to `false` at the same time with multiple_choice set to `true`. Default value is `false`
        :param pulumi.Input[bool] multiple_choice: Defines if user can select multiple values. `closed_predefined_values` should be set to `true`. Default value is `false`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "predefined_values", predefined_values)
        if closed_predefined_values is not None:
            pulumi.set(__self__, "closed_predefined_values", closed_predefined_values)
        if multiple_choice is not None:
            pulumi.set(__self__, "multiple_choice", multiple_choice)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Predefined property name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="predefinedValues")
    def predefined_values(self) -> pulumi.Input[Sequence[pulumi.Input['PropertySetPropertyPredefinedValueArgs']]]:
        """
        Properties in the property set.
        """
        return pulumi.get(self, "predefined_values")

    @predefined_values.setter
    def predefined_values(self, value: pulumi.Input[Sequence[pulumi.Input['PropertySetPropertyPredefinedValueArgs']]]):
        pulumi.set(self, "predefined_values", value)

    @property
    @pulumi.getter(name="closedPredefinedValues")
    def closed_predefined_values(self) -> Optional[pulumi.Input[bool]]:
        """
        Disables `multiple_choice` if set to `false` at the same time with multiple_choice set to `true`. Default value is `false`
        """
        return pulumi.get(self, "closed_predefined_values")

    @closed_predefined_values.setter
    def closed_predefined_values(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "closed_predefined_values", value)

    @property
    @pulumi.getter(name="multipleChoice")
    def multiple_choice(self) -> Optional[pulumi.Input[bool]]:
        """
        Defines if user can select multiple values. `closed_predefined_values` should be set to `true`. Default value is `false`.
        """
        return pulumi.get(self, "multiple_choice")

    @multiple_choice.setter
    def multiple_choice(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "multiple_choice", value)


@pulumi.input_type
class PropertySetPropertyPredefinedValueArgs:
    def __init__(__self__, *,
                 default_value: pulumi.Input[bool],
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[bool] default_value: Whether the value is selected by default in the UI.
        :param pulumi.Input[str] name: Predefined property name.
        """
        pulumi.set(__self__, "default_value", default_value)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> pulumi.Input[bool]:
        """
        Whether the value is selected by default in the UI.
        """
        return pulumi.get(self, "default_value")

    @default_value.setter
    def default_value(self, value: pulumi.Input[bool]):
        pulumi.set(self, "default_value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Predefined property name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class PushReplicationReplicationArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 url: pulumi.Input[str],
                 username: pulumi.Input[str],
                 check_binary_existence_in_filestore: Optional[pulumi.Input[bool]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 path_prefix: Optional[pulumi.Input[str]] = None,
                 proxy: Optional[pulumi.Input[str]] = None,
                 socket_timeout_millis: Optional[pulumi.Input[int]] = None,
                 sync_deletes: Optional[pulumi.Input[bool]] = None,
                 sync_properties: Optional[pulumi.Input[bool]] = None,
                 sync_statistics: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] password: Required for local repository, but not needed for remote repository.
        :param pulumi.Input[str] url: The URL of the target local repository on a remote Artifactory server. Required for local repository, but not needed for remote repository.
        :param pulumi.Input[str] username: Required for local repository, but not needed for remote repository.
        :param pulumi.Input[bool] check_binary_existence_in_filestore: When true, enables distributed checksum storage. For more information, see
               [Optimizing Repository Replication with Checksum-Based Storage](https://www.jfrog.com/confluence/display/JFROG/Repository+Replication#RepositoryReplication-OptimizingRepositoryReplicationUsingStorageLevelSynchronizationOptions).
        :param pulumi.Input[bool] enabled: When set, this replication will be enabled when saved.
        :param pulumi.Input[str] path_prefix: Only artifacts that located in path that matches the subpath within the remote repository will be replicated.
        :param pulumi.Input[str] proxy: Proxy key from Artifactory Proxies settings. The proxy configuration will be used when communicating with the remote instance.
        :param pulumi.Input[int] socket_timeout_millis: The network timeout in milliseconds to use for remote operations.
        :param pulumi.Input[bool] sync_deletes: When set, items that were deleted locally should also be deleted remotely (also applies to properties metadata).
               Note that enabling this option, will delete artifacts on the target that do not exist in the source repository.
        :param pulumi.Input[bool] sync_properties: When set, the task also synchronizes the properties of replicated artifacts.
        :param pulumi.Input[bool] sync_statistics: When set, artifact download statistics will also be replicated. Set to avoid inadvertent cleanup at the target instance when setting up replication for disaster recovery.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "url", url)
        pulumi.set(__self__, "username", username)
        if check_binary_existence_in_filestore is not None:
            pulumi.set(__self__, "check_binary_existence_in_filestore", check_binary_existence_in_filestore)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if path_prefix is not None:
            pulumi.set(__self__, "path_prefix", path_prefix)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if socket_timeout_millis is not None:
            pulumi.set(__self__, "socket_timeout_millis", socket_timeout_millis)
        if sync_deletes is not None:
            pulumi.set(__self__, "sync_deletes", sync_deletes)
        if sync_properties is not None:
            pulumi.set(__self__, "sync_properties", sync_properties)
        if sync_statistics is not None:
            pulumi.set(__self__, "sync_statistics", sync_statistics)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        Required for local repository, but not needed for remote repository.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        The URL of the target local repository on a remote Artifactory server. Required for local repository, but not needed for remote repository.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        Required for local repository, but not needed for remote repository.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="checkBinaryExistenceInFilestore")
    def check_binary_existence_in_filestore(self) -> Optional[pulumi.Input[bool]]:
        """
        When true, enables distributed checksum storage. For more information, see
        [Optimizing Repository Replication with Checksum-Based Storage](https://www.jfrog.com/confluence/display/JFROG/Repository+Replication#RepositoryReplication-OptimizingRepositoryReplicationUsingStorageLevelSynchronizationOptions).
        """
        return pulumi.get(self, "check_binary_existence_in_filestore")

    @check_binary_existence_in_filestore.setter
    def check_binary_existence_in_filestore(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "check_binary_existence_in_filestore", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        When set, this replication will be enabled when saved.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="pathPrefix")
    def path_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Only artifacts that located in path that matches the subpath within the remote repository will be replicated.
        """
        return pulumi.get(self, "path_prefix")

    @path_prefix.setter
    def path_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path_prefix", value)

    @property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[str]]:
        """
        Proxy key from Artifactory Proxies settings. The proxy configuration will be used when communicating with the remote instance.
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy", value)

    @property
    @pulumi.getter(name="socketTimeoutMillis")
    def socket_timeout_millis(self) -> Optional[pulumi.Input[int]]:
        """
        The network timeout in milliseconds to use for remote operations.
        """
        return pulumi.get(self, "socket_timeout_millis")

    @socket_timeout_millis.setter
    def socket_timeout_millis(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "socket_timeout_millis", value)

    @property
    @pulumi.getter(name="syncDeletes")
    def sync_deletes(self) -> Optional[pulumi.Input[bool]]:
        """
        When set, items that were deleted locally should also be deleted remotely (also applies to properties metadata).
        Note that enabling this option, will delete artifacts on the target that do not exist in the source repository.
        """
        return pulumi.get(self, "sync_deletes")

    @sync_deletes.setter
    def sync_deletes(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sync_deletes", value)

    @property
    @pulumi.getter(name="syncProperties")
    def sync_properties(self) -> Optional[pulumi.Input[bool]]:
        """
        When set, the task also synchronizes the properties of replicated artifacts.
        """
        return pulumi.get(self, "sync_properties")

    @sync_properties.setter
    def sync_properties(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sync_properties", value)

    @property
    @pulumi.getter(name="syncStatistics")
    def sync_statistics(self) -> Optional[pulumi.Input[bool]]:
        """
        When set, artifact download statistics will also be replicated. Set to avoid inadvertent cleanup at the target instance when setting up replication for disaster recovery.
        """
        return pulumi.get(self, "sync_statistics")

    @sync_statistics.setter
    def sync_statistics(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sync_statistics", value)


@pulumi.input_type
class ReleaseBundleCustomWebhookCriteriaArgs:
    def __init__(__self__, *,
                 any_release_bundle: pulumi.Input[bool],
                 registered_release_bundle_names: pulumi.Input[Sequence[pulumi.Input[str]]],
                 exclude_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 include_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] any_release_bundle: Trigger on any release bundle.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] registered_release_bundle_names: Trigger on this list of release bundle names.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: "org/apache/**".
        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: "org/apache/**".
        """
        pulumi.set(__self__, "any_release_bundle", any_release_bundle)
        pulumi.set(__self__, "registered_release_bundle_names", registered_release_bundle_names)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @property
    @pulumi.getter(name="anyReleaseBundle")
    def any_release_bundle(self) -> pulumi.Input[bool]:
        """
        Trigger on any release bundle.
        """
        return pulumi.get(self, "any_release_bundle")

    @any_release_bundle.setter
    def any_release_bundle(self, value: pulumi.Input[bool]):
        pulumi.set(self, "any_release_bundle", value)

    @property
    @pulumi.getter(name="registeredReleaseBundleNames")
    def registered_release_bundle_names(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Trigger on this list of release bundle names.
        """
        return pulumi.get(self, "registered_release_bundle_names")

    @registered_release_bundle_names.setter
    def registered_release_bundle_names(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "registered_release_bundle_names", value)

    @property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: "org/apache/**".
        """
        return pulumi.get(self, "exclude_patterns")

    @exclude_patterns.setter
    def exclude_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_patterns", value)

    @property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: "org/apache/**".
        """
        return pulumi.get(self, "include_patterns")

    @include_patterns.setter
    def include_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "include_patterns", value)


@pulumi.input_type
class ReleaseBundleCustomWebhookHandlerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 payload: Optional[pulumi.Input[str]] = None,
                 proxy: Optional[pulumi.Input[str]] = None,
                 secrets: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] http_headers: HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        :param pulumi.Input[str] payload: This attribute is used to build the request body. Used in custom webhooks
        :param pulumi.Input[str] proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] secrets: Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
               
               <!--Start PulumiCodeChooser -->
               ```python
               import pulumi
               ```
               <!--End PulumiCodeChooser -->
        """
        pulumi.set(__self__, "url", url)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        """
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "http_headers", value)

    @property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[str]]:
        """
        This attribute is used to build the request body. Used in custom webhooks
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "payload", value)

    @property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[str]]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy", value)

    @property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets’ values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:

        <!--Start PulumiCodeChooser -->
        ```python
        import pulumi
        ```
        <!--End PulumiCodeChooser -->
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "secrets", value)


@pulumi.input_type
class ReleaseBundleWebhookCriteriaArgs:
    def __init__(__self__, *,
                 any_release_bundle: pulumi.Input[bool],
                 registered_release_bundle_names: pulumi.Input[Sequence[pulumi.Input[str]]],
                 exclude_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 include_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] any_release_bundle: Trigger on any release bundle.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] registered_release_bundle_names: Trigger on this list of release bundle names.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: "org/apache/**".
        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: "org/apache/**".
        """
        pulumi.set(__self__, "any_release_bundle", any_release_bundle)
        pulumi.set(__self__, "registered_release_bundle_names", registered_release_bundle_names)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @property
    @pulumi.getter(name="anyReleaseBundle")
    def any_release_bundle(self) -> pulumi.Input[bool]:
        """
        Trigger on any release bundle.
        """
        return pulumi.get(self, "any_release_bundle")

    @any_release_bundle.setter
    def any_release_bundle(self, value: pulumi.Input[bool]):
        pulumi.set(self, "any_release_bundle", value)

    @property
    @pulumi.getter(name="registeredReleaseBundleNames")
    def registered_release_bundle_names(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Trigger on this list of release bundle names.
        """
        return pulumi.get(self, "registered_release_bundle_names")

    @registered_release_bundle_names.setter
    def registered_release_bundle_names(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "registered_release_bundle_names", value)

    @property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: "org/apache/**".
        """
        return pulumi.get(self, "exclude_patterns")

    @exclude_patterns.setter
    def exclude_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_patterns", value)

    @property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: "org/apache/**".
        """
        return pulumi.get(self, "include_patterns")

    @include_patterns.setter
    def include_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "include_patterns", value)


@pulumi.input_type
class ReleaseBundleWebhookHandlerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 custom_http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 proxy: Optional[pulumi.Input[str]] = None,
                 secret: Optional[pulumi.Input[str]] = None,
                 use_secret_for_signing: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] custom_http_headers: Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        :param pulumi.Input[str] proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param pulumi.Input[str] secret: Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        :param pulumi.Input[bool] use_secret_for_signing: When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        pulumi.set(__self__, "url", url)
        if custom_http_headers is not None:
            pulumi.set(__self__, "custom_http_headers", custom_http_headers)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if use_secret_for_signing is not None:
            pulumi.set(__self__, "use_secret_for_signing", use_secret_for_signing)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="customHttpHeaders")
    def custom_http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        return pulumi.get(self, "custom_http_headers")

    @custom_http_headers.setter
    def custom_http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "custom_http_headers", value)

    @property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[str]]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy", value)

    @property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[str]]:
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret", value)

    @property
    @pulumi.getter(name="useSecretForSigning")
    def use_secret_for_signing(self) -> Optional[pulumi.Input[bool]]:
        """
        When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        return pulumi.get(self, "use_secret_for_signing")

    @use_secret_for_signing.setter
    def use_secret_for_signing(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_secret_for_signing", value)


@pulumi.input_type
class RemoteAlpineRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemoteBowerRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemoteCargoRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemoteChefRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemoteCocoapodsRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemoteComposerRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemoteConanRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemoteCondaRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemoteCranRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemoteDebianRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemoteDockerRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemoteGemsRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemoteGenericRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemoteGitlfsRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemoteGoRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemoteGradleRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemoteHelmRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemoteHelmociRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemoteHuggingfacemlRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemoteIvyRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemoteMavenRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemoteNpmRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemoteNugetRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemoteOciRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemoteOpkgRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemoteP2RepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemotePubRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemotePuppetRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemotePypiRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemoteRpmRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemoteSbtRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemoteSwiftRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemoteTerraformRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class RemoteVcsRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 properties_enabled: Optional[pulumi.Input[bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class ReplicationConfigReplicationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 path_prefix: Optional[pulumi.Input[str]] = None,
                 proxy: Optional[pulumi.Input[str]] = None,
                 socket_timeout_millis: Optional[pulumi.Input[int]] = None,
                 sync_deletes: Optional[pulumi.Input[bool]] = None,
                 sync_properties: Optional[pulumi.Input[bool]] = None,
                 sync_statistics: Optional[pulumi.Input[bool]] = None,
                 url: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] password: Requires password encryption to be turned off `POST /api/system/decrypt`.
        :param pulumi.Input[str] proxy: Proxy key from Artifactory Proxies setting
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if path_prefix is not None:
            pulumi.set(__self__, "path_prefix", path_prefix)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if socket_timeout_millis is not None:
            pulumi.set(__self__, "socket_timeout_millis", socket_timeout_millis)
        if sync_deletes is not None:
            pulumi.set(__self__, "sync_deletes", sync_deletes)
        if sync_properties is not None:
            pulumi.set(__self__, "sync_properties", sync_properties)
        if sync_statistics is not None:
            pulumi.set(__self__, "sync_statistics", sync_statistics)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        Requires password encryption to be turned off `POST /api/system/decrypt`.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="pathPrefix")
    def path_prefix(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "path_prefix")

    @path_prefix.setter
    def path_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path_prefix", value)

    @property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[str]]:
        """
        Proxy key from Artifactory Proxies setting
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy", value)

    @property
    @pulumi.getter(name="socketTimeoutMillis")
    def socket_timeout_millis(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "socket_timeout_millis")

    @socket_timeout_millis.setter
    def socket_timeout_millis(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "socket_timeout_millis", value)

    @property
    @pulumi.getter(name="syncDeletes")
    def sync_deletes(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "sync_deletes")

    @sync_deletes.setter
    def sync_deletes(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sync_deletes", value)

    @property
    @pulumi.getter(name="syncProperties")
    def sync_properties(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "sync_properties")

    @sync_properties.setter
    def sync_properties(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sync_properties", value)

    @property
    @pulumi.getter(name="syncStatistics")
    def sync_statistics(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "sync_statistics")

    @sync_statistics.setter
    def sync_statistics(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sync_statistics", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class GetFederatedAlpineRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)


@pulumi.input_type
class GetFederatedBowerRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)


@pulumi.input_type
class GetFederatedCargoRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)


@pulumi.input_type
class GetFederatedChefRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)


@pulumi.input_type
class GetFederatedCocoapodsRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)


@pulumi.input_type
class GetFederatedComposerRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)


@pulumi.input_type
class GetFederatedConanRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)


@pulumi.input_type
class GetFederatedCondaRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)


@pulumi.input_type
class GetFederatedCranRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)


@pulumi.input_type
class GetFederatedDebianRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)


@pulumi.input_type
class GetFederatedDockerRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repositoryName
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repositoryName
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)


@pulumi.input_type
class GetFederatedDockerV1RepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)


@pulumi.input_type
class GetFederatedDockerV2RepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)


@pulumi.input_type
class GetFederatedGemsRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)


@pulumi.input_type
class GetFederatedGenericRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)


@pulumi.input_type
class GetFederatedGitlfsRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)


@pulumi.input_type
class GetFederatedGoRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)


@pulumi.input_type
class GetFederatedGradleRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)


@pulumi.input_type
class GetFederatedHelmRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)


@pulumi.input_type
class GetFederatedHelmociRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)


@pulumi.input_type
class GetFederatedIvyRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)


@pulumi.input_type
class GetFederatedMavenRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)


@pulumi.input_type
class GetFederatedNpmRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)


@pulumi.input_type
class GetFederatedNugetRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)


@pulumi.input_type
class GetFederatedOciRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)


@pulumi.input_type
class GetFederatedOpkgRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)


@pulumi.input_type
class GetFederatedPuppetRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)


@pulumi.input_type
class GetFederatedPypiRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)


@pulumi.input_type
class GetFederatedRpmRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)


@pulumi.input_type
class GetFederatedSbtRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)


@pulumi.input_type
class GetFederatedSwiftRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)


@pulumi.input_type
class GetFederatedTerraformModuleRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)


@pulumi.input_type
class GetFederatedTerraformProviderRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)


@pulumi.input_type
class GetFederatedVagrantRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: bool,
                 url: str):
        """
        :param bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param str url: Full URL to ending with the repository name.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: bool):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: str):
        pulumi.set(self, "url", value)


@pulumi.input_type
class GetPermissionTargetBuildArgs:
    def __init__(__self__, *,
                 repositories: Sequence[str],
                 actions: Optional['GetPermissionTargetBuildActionsArgs'] = None,
                 excludes_patterns: Optional[Sequence[str]] = None,
                 includes_patterns: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] repositories: List of repositories this permission target is applicable for. You can specify the
               name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote
               repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        :param Sequence[str] excludes_patterns: Pattern of artifacts to exclude.
        :param Sequence[str] includes_patterns: Pattern of artifacts to include.
        """
        pulumi.set(__self__, "repositories", repositories)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if excludes_patterns is not None:
            pulumi.set(__self__, "excludes_patterns", excludes_patterns)
        if includes_patterns is not None:
            pulumi.set(__self__, "includes_patterns", includes_patterns)

    @property
    @pulumi.getter
    def repositories(self) -> Sequence[str]:
        """
        List of repositories this permission target is applicable for. You can specify the
        name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote
        repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        """
        return pulumi.get(self, "repositories")

    @repositories.setter
    def repositories(self, value: Sequence[str]):
        pulumi.set(self, "repositories", value)

    @property
    @pulumi.getter
    def actions(self) -> Optional['GetPermissionTargetBuildActionsArgs']:
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional['GetPermissionTargetBuildActionsArgs']):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter(name="excludesPatterns")
    def excludes_patterns(self) -> Optional[Sequence[str]]:
        """
        Pattern of artifacts to exclude.
        """
        return pulumi.get(self, "excludes_patterns")

    @excludes_patterns.setter
    def excludes_patterns(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "excludes_patterns", value)

    @property
    @pulumi.getter(name="includesPatterns")
    def includes_patterns(self) -> Optional[Sequence[str]]:
        """
        Pattern of artifacts to include.
        """
        return pulumi.get(self, "includes_patterns")

    @includes_patterns.setter
    def includes_patterns(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "includes_patterns", value)


@pulumi.input_type
class GetPermissionTargetBuildActionsArgs:
    def __init__(__self__, *,
                 groups: Optional[Sequence['GetPermissionTargetBuildActionsGroupArgs']] = None,
                 users: Optional[Sequence['GetPermissionTargetBuildActionsUserArgs']] = None):
        """
        :param Sequence['GetPermissionTargetBuildActionsGroupArgs'] groups: Groups this permission applies for.
        :param Sequence['GetPermissionTargetBuildActionsUserArgs'] users: Users this permission target applies for.
        """
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence['GetPermissionTargetBuildActionsGroupArgs']]:
        """
        Groups this permission applies for.
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[Sequence['GetPermissionTargetBuildActionsGroupArgs']]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter
    def users(self) -> Optional[Sequence['GetPermissionTargetBuildActionsUserArgs']]:
        """
        Users this permission target applies for.
        """
        return pulumi.get(self, "users")

    @users.setter
    def users(self, value: Optional[Sequence['GetPermissionTargetBuildActionsUserArgs']]):
        pulumi.set(self, "users", value)


@pulumi.input_type
class GetPermissionTargetBuildActionsGroupArgs:
    def __init__(__self__, *,
                 name: str,
                 permissions: Sequence[str]):
        """
        :param str name: Name of the permission target.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the permission target.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def permissions(self) -> Sequence[str]:
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: Sequence[str]):
        pulumi.set(self, "permissions", value)


@pulumi.input_type
class GetPermissionTargetBuildActionsUserArgs:
    def __init__(__self__, *,
                 name: str,
                 permissions: Sequence[str]):
        """
        :param str name: Name of the permission target.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the permission target.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def permissions(self) -> Sequence[str]:
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: Sequence[str]):
        pulumi.set(self, "permissions", value)


@pulumi.input_type
class GetPermissionTargetReleaseBundleArgs:
    def __init__(__self__, *,
                 repositories: Sequence[str],
                 actions: Optional['GetPermissionTargetReleaseBundleActionsArgs'] = None,
                 excludes_patterns: Optional[Sequence[str]] = None,
                 includes_patterns: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] repositories: List of repositories this permission target is applicable for. You can specify the
               name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote
               repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        :param Sequence[str] excludes_patterns: Pattern of artifacts to exclude.
        :param Sequence[str] includes_patterns: Pattern of artifacts to include.
        """
        pulumi.set(__self__, "repositories", repositories)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if excludes_patterns is not None:
            pulumi.set(__self__, "excludes_patterns", excludes_patterns)
        if includes_patterns is not None:
            pulumi.set(__self__, "includes_patterns", includes_patterns)

    @property
    @pulumi.getter
    def repositories(self) -> Sequence[str]:
        """
        List of repositories this permission target is applicable for. You can specify the
        name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote
        repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        """
        return pulumi.get(self, "repositories")

    @repositories.setter
    def repositories(self, value: Sequence[str]):
        pulumi.set(self, "repositories", value)

    @property
    @pulumi.getter
    def actions(self) -> Optional['GetPermissionTargetReleaseBundleActionsArgs']:
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional['GetPermissionTargetReleaseBundleActionsArgs']):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter(name="excludesPatterns")
    def excludes_patterns(self) -> Optional[Sequence[str]]:
        """
        Pattern of artifacts to exclude.
        """
        return pulumi.get(self, "excludes_patterns")

    @excludes_patterns.setter
    def excludes_patterns(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "excludes_patterns", value)

    @property
    @pulumi.getter(name="includesPatterns")
    def includes_patterns(self) -> Optional[Sequence[str]]:
        """
        Pattern of artifacts to include.
        """
        return pulumi.get(self, "includes_patterns")

    @includes_patterns.setter
    def includes_patterns(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "includes_patterns", value)


@pulumi.input_type
class GetPermissionTargetReleaseBundleActionsArgs:
    def __init__(__self__, *,
                 groups: Optional[Sequence['GetPermissionTargetReleaseBundleActionsGroupArgs']] = None,
                 users: Optional[Sequence['GetPermissionTargetReleaseBundleActionsUserArgs']] = None):
        """
        :param Sequence['GetPermissionTargetReleaseBundleActionsGroupArgs'] groups: Groups this permission applies for.
        :param Sequence['GetPermissionTargetReleaseBundleActionsUserArgs'] users: Users this permission target applies for.
        """
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence['GetPermissionTargetReleaseBundleActionsGroupArgs']]:
        """
        Groups this permission applies for.
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[Sequence['GetPermissionTargetReleaseBundleActionsGroupArgs']]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter
    def users(self) -> Optional[Sequence['GetPermissionTargetReleaseBundleActionsUserArgs']]:
        """
        Users this permission target applies for.
        """
        return pulumi.get(self, "users")

    @users.setter
    def users(self, value: Optional[Sequence['GetPermissionTargetReleaseBundleActionsUserArgs']]):
        pulumi.set(self, "users", value)


@pulumi.input_type
class GetPermissionTargetReleaseBundleActionsGroupArgs:
    def __init__(__self__, *,
                 name: str,
                 permissions: Sequence[str]):
        """
        :param str name: Name of the permission target.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the permission target.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def permissions(self) -> Sequence[str]:
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: Sequence[str]):
        pulumi.set(self, "permissions", value)


@pulumi.input_type
class GetPermissionTargetReleaseBundleActionsUserArgs:
    def __init__(__self__, *,
                 name: str,
                 permissions: Sequence[str]):
        """
        :param str name: Name of the permission target.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the permission target.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def permissions(self) -> Sequence[str]:
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: Sequence[str]):
        pulumi.set(self, "permissions", value)


@pulumi.input_type
class GetPermissionTargetRepoArgs:
    def __init__(__self__, *,
                 repositories: Sequence[str],
                 actions: Optional['GetPermissionTargetRepoActionsArgs'] = None,
                 excludes_patterns: Optional[Sequence[str]] = None,
                 includes_patterns: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] repositories: List of repositories this permission target is applicable for. You can specify the
               name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote
               repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        :param Sequence[str] excludes_patterns: Pattern of artifacts to exclude.
        :param Sequence[str] includes_patterns: Pattern of artifacts to include.
        """
        pulumi.set(__self__, "repositories", repositories)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if excludes_patterns is not None:
            pulumi.set(__self__, "excludes_patterns", excludes_patterns)
        if includes_patterns is not None:
            pulumi.set(__self__, "includes_patterns", includes_patterns)

    @property
    @pulumi.getter
    def repositories(self) -> Sequence[str]:
        """
        List of repositories this permission target is applicable for. You can specify the
        name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote
        repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        """
        return pulumi.get(self, "repositories")

    @repositories.setter
    def repositories(self, value: Sequence[str]):
        pulumi.set(self, "repositories", value)

    @property
    @pulumi.getter
    def actions(self) -> Optional['GetPermissionTargetRepoActionsArgs']:
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional['GetPermissionTargetRepoActionsArgs']):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter(name="excludesPatterns")
    def excludes_patterns(self) -> Optional[Sequence[str]]:
        """
        Pattern of artifacts to exclude.
        """
        return pulumi.get(self, "excludes_patterns")

    @excludes_patterns.setter
    def excludes_patterns(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "excludes_patterns", value)

    @property
    @pulumi.getter(name="includesPatterns")
    def includes_patterns(self) -> Optional[Sequence[str]]:
        """
        Pattern of artifacts to include.
        """
        return pulumi.get(self, "includes_patterns")

    @includes_patterns.setter
    def includes_patterns(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "includes_patterns", value)


@pulumi.input_type
class GetPermissionTargetRepoActionsArgs:
    def __init__(__self__, *,
                 groups: Optional[Sequence['GetPermissionTargetRepoActionsGroupArgs']] = None,
                 users: Optional[Sequence['GetPermissionTargetRepoActionsUserArgs']] = None):
        """
        :param Sequence['GetPermissionTargetRepoActionsGroupArgs'] groups: Groups this permission applies for.
        :param Sequence['GetPermissionTargetRepoActionsUserArgs'] users: Users this permission target applies for.
        """
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence['GetPermissionTargetRepoActionsGroupArgs']]:
        """
        Groups this permission applies for.
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[Sequence['GetPermissionTargetRepoActionsGroupArgs']]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter
    def users(self) -> Optional[Sequence['GetPermissionTargetRepoActionsUserArgs']]:
        """
        Users this permission target applies for.
        """
        return pulumi.get(self, "users")

    @users.setter
    def users(self, value: Optional[Sequence['GetPermissionTargetRepoActionsUserArgs']]):
        pulumi.set(self, "users", value)


@pulumi.input_type
class GetPermissionTargetRepoActionsGroupArgs:
    def __init__(__self__, *,
                 name: str,
                 permissions: Sequence[str]):
        """
        :param str name: Name of the permission target.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the permission target.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def permissions(self) -> Sequence[str]:
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: Sequence[str]):
        pulumi.set(self, "permissions", value)


@pulumi.input_type
class GetPermissionTargetRepoActionsUserArgs:
    def __init__(__self__, *,
                 name: str,
                 permissions: Sequence[str]):
        """
        :param str name: Name of the permission target.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the permission target.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def permissions(self) -> Sequence[str]:
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: Sequence[str]):
        pulumi.set(self, "permissions", value)


@pulumi.input_type
class GetRemoteAlpineRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class GetRemoteBowerRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class GetRemoteCargoRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class GetRemoteChefRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class GetRemoteCocoapodsRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class GetRemoteComposerRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class GetRemoteConanRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class GetRemoteCondaRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class GetRemoteCranRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class GetRemoteDebianRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class GetRemoteDockerRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class GetRemoteGemsRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class GetRemoteGenericRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class GetRemoteGitlfsRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class GetRemoteGoRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class GetRemoteGradleRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class GetRemoteHelmRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class GetRemoteHelmociRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class GetRemoteIvyRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class GetRemoteMavenRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class GetRemoteNpmRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class GetRemoteNugetRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class GetRemoteOciRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class GetRemoteOpkgRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class GetRemoteP2RepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class GetRemotePubRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class GetRemotePuppetRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class GetRemotePypiRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class GetRemoteRpmRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class GetRemoteSbtRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class GetRemoteSwiftRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class GetRemoteTerraformRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


@pulumi.input_type
class GetRemoteVcsRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 properties_enabled: Optional[bool] = None,
                 source_origin_absence_detection: Optional[bool] = None,
                 statistics_enabled: Optional[bool] = None):
        """
        :param bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[bool]):
        pulumi.set(self, "properties_enabled", value)

    @property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[bool]):
        pulumi.set(self, "statistics_enabled", value)


