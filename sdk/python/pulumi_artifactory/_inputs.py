# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'ArchivePolicySearchCriteriaArgs',
    'ArchivePolicySearchCriteriaArgsDict',
    'ArtifactCustomWebhookCriteriaArgs',
    'ArtifactCustomWebhookCriteriaArgsDict',
    'ArtifactCustomWebhookHandlerArgs',
    'ArtifactCustomWebhookHandlerArgsDict',
    'ArtifactLifecycleCustomWebhookHandlerArgs',
    'ArtifactLifecycleCustomWebhookHandlerArgsDict',
    'ArtifactLifecycleWebhookHandlerArgs',
    'ArtifactLifecycleWebhookHandlerArgsDict',
    'ArtifactPropertyCustomWebhookCriteriaArgs',
    'ArtifactPropertyCustomWebhookCriteriaArgsDict',
    'ArtifactPropertyCustomWebhookHandlerArgs',
    'ArtifactPropertyCustomWebhookHandlerArgsDict',
    'ArtifactPropertyWebhookCriteriaArgs',
    'ArtifactPropertyWebhookCriteriaArgsDict',
    'ArtifactPropertyWebhookHandlerArgs',
    'ArtifactPropertyWebhookHandlerArgsDict',
    'ArtifactWebhookCriteriaArgs',
    'ArtifactWebhookCriteriaArgsDict',
    'ArtifactWebhookHandlerArgs',
    'ArtifactWebhookHandlerArgsDict',
    'ArtifactoryReleaseBundleCustomWebhookCriteriaArgs',
    'ArtifactoryReleaseBundleCustomWebhookCriteriaArgsDict',
    'ArtifactoryReleaseBundleCustomWebhookHandlerArgs',
    'ArtifactoryReleaseBundleCustomWebhookHandlerArgsDict',
    'ArtifactoryReleaseBundleWebhookCriteriaArgs',
    'ArtifactoryReleaseBundleWebhookCriteriaArgsDict',
    'ArtifactoryReleaseBundleWebhookHandlerArgs',
    'ArtifactoryReleaseBundleWebhookHandlerArgsDict',
    'BuildCustomWebhookCriteriaArgs',
    'BuildCustomWebhookCriteriaArgsDict',
    'BuildCustomWebhookHandlerArgs',
    'BuildCustomWebhookHandlerArgsDict',
    'BuildWebhookCriteriaArgs',
    'BuildWebhookCriteriaArgsDict',
    'BuildWebhookHandlerArgs',
    'BuildWebhookHandlerArgsDict',
    'DestinationCustomWebhookCriteriaArgs',
    'DestinationCustomWebhookCriteriaArgsDict',
    'DestinationCustomWebhookHandlerArgs',
    'DestinationCustomWebhookHandlerArgsDict',
    'DestinationWebhookCriteriaArgs',
    'DestinationWebhookCriteriaArgsDict',
    'DestinationWebhookHandlerArgs',
    'DestinationWebhookHandlerArgsDict',
    'DistributionCustomWebhookCriteriaArgs',
    'DistributionCustomWebhookCriteriaArgsDict',
    'DistributionCustomWebhookHandlerArgs',
    'DistributionCustomWebhookHandlerArgsDict',
    'DistributionWebhookCriteriaArgs',
    'DistributionWebhookCriteriaArgsDict',
    'DistributionWebhookHandlerArgs',
    'DistributionWebhookHandlerArgsDict',
    'DockerCustomWebhookCriteriaArgs',
    'DockerCustomWebhookCriteriaArgsDict',
    'DockerCustomWebhookHandlerArgs',
    'DockerCustomWebhookHandlerArgsDict',
    'DockerWebhookCriteriaArgs',
    'DockerWebhookCriteriaArgsDict',
    'DockerWebhookHandlerArgs',
    'DockerWebhookHandlerArgsDict',
    'FederatedAlpineRepositoryMemberArgs',
    'FederatedAlpineRepositoryMemberArgsDict',
    'FederatedAnsibleRepositoryMemberArgs',
    'FederatedAnsibleRepositoryMemberArgsDict',
    'FederatedBowerRepositoryMemberArgs',
    'FederatedBowerRepositoryMemberArgsDict',
    'FederatedCargoRepositoryMemberArgs',
    'FederatedCargoRepositoryMemberArgsDict',
    'FederatedChefRepositoryMemberArgs',
    'FederatedChefRepositoryMemberArgsDict',
    'FederatedCocoapodsRepositoryMemberArgs',
    'FederatedCocoapodsRepositoryMemberArgsDict',
    'FederatedComposerRepositoryMemberArgs',
    'FederatedComposerRepositoryMemberArgsDict',
    'FederatedConanRepositoryMemberArgs',
    'FederatedConanRepositoryMemberArgsDict',
    'FederatedCondaRepositoryMemberArgs',
    'FederatedCondaRepositoryMemberArgsDict',
    'FederatedCranRepositoryMemberArgs',
    'FederatedCranRepositoryMemberArgsDict',
    'FederatedDebianRepositoryMemberArgs',
    'FederatedDebianRepositoryMemberArgsDict',
    'FederatedDockerRepositoryMemberArgs',
    'FederatedDockerRepositoryMemberArgsDict',
    'FederatedDockerV1RepositoryMemberArgs',
    'FederatedDockerV1RepositoryMemberArgsDict',
    'FederatedDockerV2RepositoryMemberArgs',
    'FederatedDockerV2RepositoryMemberArgsDict',
    'FederatedGemsRepositoryMemberArgs',
    'FederatedGemsRepositoryMemberArgsDict',
    'FederatedGenericRepositoryMemberArgs',
    'FederatedGenericRepositoryMemberArgsDict',
    'FederatedGitltfsRepositoryMemberArgs',
    'FederatedGitltfsRepositoryMemberArgsDict',
    'FederatedGoRepositoryMemberArgs',
    'FederatedGoRepositoryMemberArgsDict',
    'FederatedGradleRepositoryMemberArgs',
    'FederatedGradleRepositoryMemberArgsDict',
    'FederatedHelmRepositoryMemberArgs',
    'FederatedHelmRepositoryMemberArgsDict',
    'FederatedHelmociRepositoryMemberArgs',
    'FederatedHelmociRepositoryMemberArgsDict',
    'FederatedHuggingfacemlRepositoryMemberArgs',
    'FederatedHuggingfacemlRepositoryMemberArgsDict',
    'FederatedIvyRepositoryMemberArgs',
    'FederatedIvyRepositoryMemberArgsDict',
    'FederatedMavenRepositoryMemberArgs',
    'FederatedMavenRepositoryMemberArgsDict',
    'FederatedNpmRepositoryMemberArgs',
    'FederatedNpmRepositoryMemberArgsDict',
    'FederatedNugetRepositoryMemberArgs',
    'FederatedNugetRepositoryMemberArgsDict',
    'FederatedOciRepositoryMemberArgs',
    'FederatedOciRepositoryMemberArgsDict',
    'FederatedOpkgRepositoryMemberArgs',
    'FederatedOpkgRepositoryMemberArgsDict',
    'FederatedPuppetRepositoryMemberArgs',
    'FederatedPuppetRepositoryMemberArgsDict',
    'FederatedPypiRepositoryMemberArgs',
    'FederatedPypiRepositoryMemberArgsDict',
    'FederatedReleasebundlesRepositoryMemberArgs',
    'FederatedReleasebundlesRepositoryMemberArgsDict',
    'FederatedRpmRepositoryMemberArgs',
    'FederatedRpmRepositoryMemberArgsDict',
    'FederatedSbtRepositoryMemberArgs',
    'FederatedSbtRepositoryMemberArgsDict',
    'FederatedSwiftRepositoryMemberArgs',
    'FederatedSwiftRepositoryMemberArgsDict',
    'FederatedTerraformModuleRepositoryMemberArgs',
    'FederatedTerraformModuleRepositoryMemberArgsDict',
    'FederatedTerraformProviderRepositoryMemberArgs',
    'FederatedTerraformProviderRepositoryMemberArgsDict',
    'FederatedVagrantRepositoryMemberArgs',
    'FederatedVagrantRepositoryMemberArgsDict',
    'LocalRepositoryMultiReplicationReplicationArgs',
    'LocalRepositoryMultiReplicationReplicationArgsDict',
    'ManagedUserPasswordPolicyArgs',
    'ManagedUserPasswordPolicyArgsDict',
    'OauthSettingsOauthProviderArgs',
    'OauthSettingsOauthProviderArgsDict',
    'PackageCleanupPolicySearchCriteriaArgs',
    'PackageCleanupPolicySearchCriteriaArgsDict',
    'PermissionTargetBuildArgs',
    'PermissionTargetBuildArgsDict',
    'PermissionTargetBuildActionsArgs',
    'PermissionTargetBuildActionsArgsDict',
    'PermissionTargetBuildActionsGroupArgs',
    'PermissionTargetBuildActionsGroupArgsDict',
    'PermissionTargetBuildActionsUserArgs',
    'PermissionTargetBuildActionsUserArgsDict',
    'PermissionTargetReleaseBundleArgs',
    'PermissionTargetReleaseBundleArgsDict',
    'PermissionTargetReleaseBundleActionsArgs',
    'PermissionTargetReleaseBundleActionsArgsDict',
    'PermissionTargetReleaseBundleActionsGroupArgs',
    'PermissionTargetReleaseBundleActionsGroupArgsDict',
    'PermissionTargetReleaseBundleActionsUserArgs',
    'PermissionTargetReleaseBundleActionsUserArgsDict',
    'PermissionTargetRepoArgs',
    'PermissionTargetRepoArgsDict',
    'PermissionTargetRepoActionsArgs',
    'PermissionTargetRepoActionsArgsDict',
    'PermissionTargetRepoActionsGroupArgs',
    'PermissionTargetRepoActionsGroupArgsDict',
    'PermissionTargetRepoActionsUserArgs',
    'PermissionTargetRepoActionsUserArgsDict',
    'PropertySetPropertyArgs',
    'PropertySetPropertyArgsDict',
    'PropertySetPropertyPredefinedValueArgs',
    'PropertySetPropertyPredefinedValueArgsDict',
    'PushReplicationReplicationArgs',
    'PushReplicationReplicationArgsDict',
    'ReleaseBundleCustomWebhookCriteriaArgs',
    'ReleaseBundleCustomWebhookCriteriaArgsDict',
    'ReleaseBundleCustomWebhookHandlerArgs',
    'ReleaseBundleCustomWebhookHandlerArgsDict',
    'ReleaseBundleV2CleanupPolicySearchCriteriaArgs',
    'ReleaseBundleV2CleanupPolicySearchCriteriaArgsDict',
    'ReleaseBundleV2CleanupPolicySearchCriteriaReleaseBundleArgs',
    'ReleaseBundleV2CleanupPolicySearchCriteriaReleaseBundleArgsDict',
    'ReleaseBundleV2CustomWebhookCriteriaArgs',
    'ReleaseBundleV2CustomWebhookCriteriaArgsDict',
    'ReleaseBundleV2CustomWebhookHandlerArgs',
    'ReleaseBundleV2CustomWebhookHandlerArgsDict',
    'ReleaseBundleV2PromotionCustomWebhookCriteriaArgs',
    'ReleaseBundleV2PromotionCustomWebhookCriteriaArgsDict',
    'ReleaseBundleV2PromotionCustomWebhookHandlerArgs',
    'ReleaseBundleV2PromotionCustomWebhookHandlerArgsDict',
    'ReleaseBundleV2PromotionWebhookCriteriaArgs',
    'ReleaseBundleV2PromotionWebhookCriteriaArgsDict',
    'ReleaseBundleV2PromotionWebhookHandlerArgs',
    'ReleaseBundleV2PromotionWebhookHandlerArgsDict',
    'ReleaseBundleV2SourceArgs',
    'ReleaseBundleV2SourceArgsDict',
    'ReleaseBundleV2SourceArtifactArgs',
    'ReleaseBundleV2SourceArtifactArgsDict',
    'ReleaseBundleV2SourceBuildArgs',
    'ReleaseBundleV2SourceBuildArgsDict',
    'ReleaseBundleV2SourceReleaseBundleArgs',
    'ReleaseBundleV2SourceReleaseBundleArgsDict',
    'ReleaseBundleV2WebhookCriteriaArgs',
    'ReleaseBundleV2WebhookCriteriaArgsDict',
    'ReleaseBundleV2WebhookHandlerArgs',
    'ReleaseBundleV2WebhookHandlerArgsDict',
    'ReleaseBundleWebhookCriteriaArgs',
    'ReleaseBundleWebhookCriteriaArgsDict',
    'ReleaseBundleWebhookHandlerArgs',
    'ReleaseBundleWebhookHandlerArgsDict',
    'RemoteAlpineRepositoryContentSynchronisationArgs',
    'RemoteAlpineRepositoryContentSynchronisationArgsDict',
    'RemoteAnsibleRepositoryContentSynchronisationArgs',
    'RemoteAnsibleRepositoryContentSynchronisationArgsDict',
    'RemoteBowerRepositoryContentSynchronisationArgs',
    'RemoteBowerRepositoryContentSynchronisationArgsDict',
    'RemoteCargoRepositoryContentSynchronisationArgs',
    'RemoteCargoRepositoryContentSynchronisationArgsDict',
    'RemoteChefRepositoryContentSynchronisationArgs',
    'RemoteChefRepositoryContentSynchronisationArgsDict',
    'RemoteCocoapodsRepositoryContentSynchronisationArgs',
    'RemoteCocoapodsRepositoryContentSynchronisationArgsDict',
    'RemoteComposerRepositoryContentSynchronisationArgs',
    'RemoteComposerRepositoryContentSynchronisationArgsDict',
    'RemoteConanRepositoryContentSynchronisationArgs',
    'RemoteConanRepositoryContentSynchronisationArgsDict',
    'RemoteCondaRepositoryContentSynchronisationArgs',
    'RemoteCondaRepositoryContentSynchronisationArgsDict',
    'RemoteCranRepositoryContentSynchronisationArgs',
    'RemoteCranRepositoryContentSynchronisationArgsDict',
    'RemoteDebianRepositoryContentSynchronisationArgs',
    'RemoteDebianRepositoryContentSynchronisationArgsDict',
    'RemoteDockerRepositoryContentSynchronisationArgs',
    'RemoteDockerRepositoryContentSynchronisationArgsDict',
    'RemoteGemsRepositoryContentSynchronisationArgs',
    'RemoteGemsRepositoryContentSynchronisationArgsDict',
    'RemoteGenericRepositoryContentSynchronisationArgs',
    'RemoteGenericRepositoryContentSynchronisationArgsDict',
    'RemoteGitlfsRepositoryContentSynchronisationArgs',
    'RemoteGitlfsRepositoryContentSynchronisationArgsDict',
    'RemoteGoRepositoryContentSynchronisationArgs',
    'RemoteGoRepositoryContentSynchronisationArgsDict',
    'RemoteGradleRepositoryContentSynchronisationArgs',
    'RemoteGradleRepositoryContentSynchronisationArgsDict',
    'RemoteHelmRepositoryContentSynchronisationArgs',
    'RemoteHelmRepositoryContentSynchronisationArgsDict',
    'RemoteHelmociRepositoryContentSynchronisationArgs',
    'RemoteHelmociRepositoryContentSynchronisationArgsDict',
    'RemoteHexRepositoryContentSynchronisationArgs',
    'RemoteHexRepositoryContentSynchronisationArgsDict',
    'RemoteHuggingfacemlRepositoryContentSynchronisationArgs',
    'RemoteHuggingfacemlRepositoryContentSynchronisationArgsDict',
    'RemoteIvyRepositoryContentSynchronisationArgs',
    'RemoteIvyRepositoryContentSynchronisationArgsDict',
    'RemoteMavenRepositoryContentSynchronisationArgs',
    'RemoteMavenRepositoryContentSynchronisationArgsDict',
    'RemoteNpmRepositoryContentSynchronisationArgs',
    'RemoteNpmRepositoryContentSynchronisationArgsDict',
    'RemoteNugetRepositoryContentSynchronisationArgs',
    'RemoteNugetRepositoryContentSynchronisationArgsDict',
    'RemoteOciRepositoryContentSynchronisationArgs',
    'RemoteOciRepositoryContentSynchronisationArgsDict',
    'RemoteOpkgRepositoryContentSynchronisationArgs',
    'RemoteOpkgRepositoryContentSynchronisationArgsDict',
    'RemoteP2RepositoryContentSynchronisationArgs',
    'RemoteP2RepositoryContentSynchronisationArgsDict',
    'RemotePubRepositoryContentSynchronisationArgs',
    'RemotePubRepositoryContentSynchronisationArgsDict',
    'RemotePuppetRepositoryContentSynchronisationArgs',
    'RemotePuppetRepositoryContentSynchronisationArgsDict',
    'RemotePypiRepositoryContentSynchronisationArgs',
    'RemotePypiRepositoryContentSynchronisationArgsDict',
    'RemoteRpmRepositoryContentSynchronisationArgs',
    'RemoteRpmRepositoryContentSynchronisationArgsDict',
    'RemoteSbtRepositoryContentSynchronisationArgs',
    'RemoteSbtRepositoryContentSynchronisationArgsDict',
    'RemoteSwiftRepositoryContentSynchronisationArgs',
    'RemoteSwiftRepositoryContentSynchronisationArgsDict',
    'RemoteTerraformRepositoryContentSynchronisationArgs',
    'RemoteTerraformRepositoryContentSynchronisationArgsDict',
    'RemoteVcsRepositoryContentSynchronisationArgs',
    'RemoteVcsRepositoryContentSynchronisationArgsDict',
    'UnmanagedUserPasswordPolicyArgs',
    'UnmanagedUserPasswordPolicyArgsDict',
    'UserCustomWebhookHandlerArgs',
    'UserCustomWebhookHandlerArgsDict',
    'UserPasswordPolicyArgs',
    'UserPasswordPolicyArgsDict',
    'UserWebhookHandlerArgs',
    'UserWebhookHandlerArgsDict',
    'VaultConfigurationConfigArgs',
    'VaultConfigurationConfigArgsDict',
    'VaultConfigurationConfigAuthArgs',
    'VaultConfigurationConfigAuthArgsDict',
    'VaultConfigurationConfigMountArgs',
    'VaultConfigurationConfigMountArgsDict',
    'GetFederatedAlpineRepositoryMemberArgs',
    'GetFederatedAlpineRepositoryMemberArgsDict',
    'GetFederatedAnsibleRepositoryMemberArgs',
    'GetFederatedAnsibleRepositoryMemberArgsDict',
    'GetFederatedBowerRepositoryMemberArgs',
    'GetFederatedBowerRepositoryMemberArgsDict',
    'GetFederatedCargoRepositoryMemberArgs',
    'GetFederatedCargoRepositoryMemberArgsDict',
    'GetFederatedChefRepositoryMemberArgs',
    'GetFederatedChefRepositoryMemberArgsDict',
    'GetFederatedCocoapodsRepositoryMemberArgs',
    'GetFederatedCocoapodsRepositoryMemberArgsDict',
    'GetFederatedComposerRepositoryMemberArgs',
    'GetFederatedComposerRepositoryMemberArgsDict',
    'GetFederatedConanRepositoryMemberArgs',
    'GetFederatedConanRepositoryMemberArgsDict',
    'GetFederatedCondaRepositoryMemberArgs',
    'GetFederatedCondaRepositoryMemberArgsDict',
    'GetFederatedCranRepositoryMemberArgs',
    'GetFederatedCranRepositoryMemberArgsDict',
    'GetFederatedDebianRepositoryMemberArgs',
    'GetFederatedDebianRepositoryMemberArgsDict',
    'GetFederatedDockerRepositoryMemberArgs',
    'GetFederatedDockerRepositoryMemberArgsDict',
    'GetFederatedDockerV1RepositoryMemberArgs',
    'GetFederatedDockerV1RepositoryMemberArgsDict',
    'GetFederatedDockerV2RepositoryMemberArgs',
    'GetFederatedDockerV2RepositoryMemberArgsDict',
    'GetFederatedGemsRepositoryMemberArgs',
    'GetFederatedGemsRepositoryMemberArgsDict',
    'GetFederatedGenericRepositoryMemberArgs',
    'GetFederatedGenericRepositoryMemberArgsDict',
    'GetFederatedGitlfsRepositoryMemberArgs',
    'GetFederatedGitlfsRepositoryMemberArgsDict',
    'GetFederatedGoRepositoryMemberArgs',
    'GetFederatedGoRepositoryMemberArgsDict',
    'GetFederatedGradleRepositoryMemberArgs',
    'GetFederatedGradleRepositoryMemberArgsDict',
    'GetFederatedHelmRepositoryMemberArgs',
    'GetFederatedHelmRepositoryMemberArgsDict',
    'GetFederatedHelmociRepositoryMemberArgs',
    'GetFederatedHelmociRepositoryMemberArgsDict',
    'GetFederatedHuggingfacemlRepositoryMemberArgs',
    'GetFederatedHuggingfacemlRepositoryMemberArgsDict',
    'GetFederatedIvyRepositoryMemberArgs',
    'GetFederatedIvyRepositoryMemberArgsDict',
    'GetFederatedMavenRepositoryMemberArgs',
    'GetFederatedMavenRepositoryMemberArgsDict',
    'GetFederatedNpmRepositoryMemberArgs',
    'GetFederatedNpmRepositoryMemberArgsDict',
    'GetFederatedNugetRepositoryMemberArgs',
    'GetFederatedNugetRepositoryMemberArgsDict',
    'GetFederatedOciRepositoryMemberArgs',
    'GetFederatedOciRepositoryMemberArgsDict',
    'GetFederatedOpkgRepositoryMemberArgs',
    'GetFederatedOpkgRepositoryMemberArgsDict',
    'GetFederatedPuppetRepositoryMemberArgs',
    'GetFederatedPuppetRepositoryMemberArgsDict',
    'GetFederatedPypiRepositoryMemberArgs',
    'GetFederatedPypiRepositoryMemberArgsDict',
    'GetFederatedReleasebundlesRepositoryMemberArgs',
    'GetFederatedReleasebundlesRepositoryMemberArgsDict',
    'GetFederatedRpmRepositoryMemberArgs',
    'GetFederatedRpmRepositoryMemberArgsDict',
    'GetFederatedSbtRepositoryMemberArgs',
    'GetFederatedSbtRepositoryMemberArgsDict',
    'GetFederatedSwiftRepositoryMemberArgs',
    'GetFederatedSwiftRepositoryMemberArgsDict',
    'GetFederatedTerraformModuleRepositoryMemberArgs',
    'GetFederatedTerraformModuleRepositoryMemberArgsDict',
    'GetFederatedTerraformProviderRepositoryMemberArgs',
    'GetFederatedTerraformProviderRepositoryMemberArgsDict',
    'GetFederatedVagrantRepositoryMemberArgs',
    'GetFederatedVagrantRepositoryMemberArgsDict',
    'GetPermissionTargetBuildArgs',
    'GetPermissionTargetBuildArgsDict',
    'GetPermissionTargetBuildActionsArgs',
    'GetPermissionTargetBuildActionsArgsDict',
    'GetPermissionTargetBuildActionsGroupArgs',
    'GetPermissionTargetBuildActionsGroupArgsDict',
    'GetPermissionTargetBuildActionsUserArgs',
    'GetPermissionTargetBuildActionsUserArgsDict',
    'GetPermissionTargetReleaseBundleArgs',
    'GetPermissionTargetReleaseBundleArgsDict',
    'GetPermissionTargetReleaseBundleActionsArgs',
    'GetPermissionTargetReleaseBundleActionsArgsDict',
    'GetPermissionTargetReleaseBundleActionsGroupArgs',
    'GetPermissionTargetReleaseBundleActionsGroupArgsDict',
    'GetPermissionTargetReleaseBundleActionsUserArgs',
    'GetPermissionTargetReleaseBundleActionsUserArgsDict',
    'GetPermissionTargetRepoArgs',
    'GetPermissionTargetRepoArgsDict',
    'GetPermissionTargetRepoActionsArgs',
    'GetPermissionTargetRepoActionsArgsDict',
    'GetPermissionTargetRepoActionsGroupArgs',
    'GetPermissionTargetRepoActionsGroupArgsDict',
    'GetPermissionTargetRepoActionsUserArgs',
    'GetPermissionTargetRepoActionsUserArgsDict',
    'GetRemoteAlpineRepositoryContentSynchronisationArgs',
    'GetRemoteAlpineRepositoryContentSynchronisationArgsDict',
    'GetRemoteAnsibleRepositoryContentSynchronisationArgs',
    'GetRemoteAnsibleRepositoryContentSynchronisationArgsDict',
    'GetRemoteBowerRepositoryContentSynchronisationArgs',
    'GetRemoteBowerRepositoryContentSynchronisationArgsDict',
    'GetRemoteCargoRepositoryContentSynchronisationArgs',
    'GetRemoteCargoRepositoryContentSynchronisationArgsDict',
    'GetRemoteChefRepositoryContentSynchronisationArgs',
    'GetRemoteChefRepositoryContentSynchronisationArgsDict',
    'GetRemoteCocoapodsRepositoryContentSynchronisationArgs',
    'GetRemoteCocoapodsRepositoryContentSynchronisationArgsDict',
    'GetRemoteComposerRepositoryContentSynchronisationArgs',
    'GetRemoteComposerRepositoryContentSynchronisationArgsDict',
    'GetRemoteConanRepositoryContentSynchronisationArgs',
    'GetRemoteConanRepositoryContentSynchronisationArgsDict',
    'GetRemoteCondaRepositoryContentSynchronisationArgs',
    'GetRemoteCondaRepositoryContentSynchronisationArgsDict',
    'GetRemoteCranRepositoryContentSynchronisationArgs',
    'GetRemoteCranRepositoryContentSynchronisationArgsDict',
    'GetRemoteDebianRepositoryContentSynchronisationArgs',
    'GetRemoteDebianRepositoryContentSynchronisationArgsDict',
    'GetRemoteDockerRepositoryContentSynchronisationArgs',
    'GetRemoteDockerRepositoryContentSynchronisationArgsDict',
    'GetRemoteGenericRepositoryContentSynchronisationArgs',
    'GetRemoteGenericRepositoryContentSynchronisationArgsDict',
    'GetRemoteGitlfsRepositoryContentSynchronisationArgs',
    'GetRemoteGitlfsRepositoryContentSynchronisationArgsDict',
    'GetRemoteGoRepositoryContentSynchronisationArgs',
    'GetRemoteGoRepositoryContentSynchronisationArgsDict',
    'GetRemoteGradleRepositoryContentSynchronisationArgs',
    'GetRemoteGradleRepositoryContentSynchronisationArgsDict',
    'GetRemoteHelmRepositoryContentSynchronisationArgs',
    'GetRemoteHelmRepositoryContentSynchronisationArgsDict',
    'GetRemoteHelmociRepositoryContentSynchronisationArgs',
    'GetRemoteHelmociRepositoryContentSynchronisationArgsDict',
    'GetRemoteIvyRepositoryContentSynchronisationArgs',
    'GetRemoteIvyRepositoryContentSynchronisationArgsDict',
    'GetRemoteMavenRepositoryContentSynchronisationArgs',
    'GetRemoteMavenRepositoryContentSynchronisationArgsDict',
    'GetRemoteNpmRepositoryContentSynchronisationArgs',
    'GetRemoteNpmRepositoryContentSynchronisationArgsDict',
    'GetRemoteNugetRepositoryContentSynchronisationArgs',
    'GetRemoteNugetRepositoryContentSynchronisationArgsDict',
    'GetRemoteOciRepositoryContentSynchronisationArgs',
    'GetRemoteOciRepositoryContentSynchronisationArgsDict',
    'GetRemoteOpkgRepositoryContentSynchronisationArgs',
    'GetRemoteOpkgRepositoryContentSynchronisationArgsDict',
    'GetRemoteP2RepositoryContentSynchronisationArgs',
    'GetRemoteP2RepositoryContentSynchronisationArgsDict',
    'GetRemotePubRepositoryContentSynchronisationArgs',
    'GetRemotePubRepositoryContentSynchronisationArgsDict',
    'GetRemotePuppetRepositoryContentSynchronisationArgs',
    'GetRemotePuppetRepositoryContentSynchronisationArgsDict',
    'GetRemotePypiRepositoryContentSynchronisationArgs',
    'GetRemotePypiRepositoryContentSynchronisationArgsDict',
    'GetRemoteRpmRepositoryContentSynchronisationArgs',
    'GetRemoteRpmRepositoryContentSynchronisationArgsDict',
    'GetRemoteSbtRepositoryContentSynchronisationArgs',
    'GetRemoteSbtRepositoryContentSynchronisationArgsDict',
    'GetRemoteSwiftRepositoryContentSynchronisationArgs',
    'GetRemoteSwiftRepositoryContentSynchronisationArgsDict',
    'GetRemoteTerraformRepositoryContentSynchronisationArgs',
    'GetRemoteTerraformRepositoryContentSynchronisationArgsDict',
    'GetRemoteVcsRepositoryContentSynchronisationArgs',
    'GetRemoteVcsRepositoryContentSynchronisationArgsDict',
]

MYPY = False

if not MYPY:
    class ArchivePolicySearchCriteriaArgsDict(TypedDict):
        included_packages: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Specify a pattern for a package name or an explicit package name. It accept only single element which can be specific package or pattern, and for including all packages use `**`. Example: `included_packages = ["**"]`
        """
        included_projects: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of projects on which you want this policy to run. To include repositories that are not assigned to any project, enter the project key `default`. Can be empty when `include_all_projects` is set to `true`.
        ~>This setting is relevant only on the global level, for Platform Admins.
        """
        package_types: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        repos: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Specify one or more patterns for the repository name(s) on which you want the archive policy to run. You can also specify explicit repository names. Specifying at least one pattern or explicit name is required. Only packages in repositories that match the pattern or explicit name will be archived. For including all repos use `**`. Example: `repos = ["**"]`
        """
        created_before_in_days: NotRequired[pulumi.Input[_builtins.int]]
        """
        The archive policy will archive packages based on how long ago they were created. For example, if this parameter is 2 then packages created more than 2 days ago will be archived as part of the policy.
        > **Requires Artifactory 7.111.2 or later.**
        ~>JFrog recommends using the `created_before_in_days` condition to ensure that packages currently in use are not archived.
        """
        created_before_in_months: NotRequired[pulumi.Input[_builtins.int]]
        """
        The archive policy will archive packages based on how long ago they were created. For example, if this parameter is 2 then packages created more than 2 months ago will be archived as part of the policy.
        """
        excluded_packages: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specify explicit package names that you want excluded from the policy. Only Name explicit names (and not patterns) are accepted.
        """
        excluded_properties: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]]]
        """
        A key-value pair applied to the lead artifact of a package. Packages with this property will be excluded from archival.
        """
        excluded_repos: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specify patterns for repository names or explicit repository names that you want excluded from the archive policy.
        """
        include_all_projects: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Set this value to `true` if you want the policy to run on all Artifactory projects. The default value is `false`.

        ~>This attribute is relevant only on the global level, for Platform Admins.
        """
        included_properties: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]]]
        """
        A key-value pair applied to the lead artifact of a package. Packages with this property will be archived.
        """
        keep_last_n_versions: NotRequired[pulumi.Input[_builtins.int]]
        """
        Set a value for the number of latest versions to keep. The archive policy will remove all versions before the number you select here. The latest version is always excluded.

        ~>Versions are determined by creation date.

        ~>Not all package types support this condition. If you include a package type in your policy that is not compatible with this condition, a validation error (400) is returned. For information on which package types support this condition, see here.
        """
        last_downloaded_before_in_days: NotRequired[pulumi.Input[_builtins.int]]
        """
        The archive policy will archive packages based on how long ago they were downloaded. For example, if this parameter is 5 then packages downloaded more than 5 days ago will be archived as part of the policy.
        > **Requires Artifactory 7.111.2 or later.**
        ~>JFrog recommends using the `last_downloaded_before_in_days` condition to ensure that packages currently in use are not archived.
        """
        last_downloaded_before_in_months: NotRequired[pulumi.Input[_builtins.int]]
        """
        The archive policy will archive packages based on how long ago they were downloaded. For example, if this parameter is 5 then packages downloaded more than 5 months ago will be archived as part of the policy.
        """
elif False:
    ArchivePolicySearchCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ArchivePolicySearchCriteriaArgs:
    def __init__(__self__, *,
                 included_packages: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 included_projects: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 package_types: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 repos: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 created_before_in_days: Optional[pulumi.Input[_builtins.int]] = None,
                 created_before_in_months: Optional[pulumi.Input[_builtins.int]] = None,
                 excluded_packages: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 excluded_properties: Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]]] = None,
                 excluded_repos: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 include_all_projects: Optional[pulumi.Input[_builtins.bool]] = None,
                 included_properties: Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]]] = None,
                 keep_last_n_versions: Optional[pulumi.Input[_builtins.int]] = None,
                 last_downloaded_before_in_days: Optional[pulumi.Input[_builtins.int]] = None,
                 last_downloaded_before_in_months: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] included_packages: Specify a pattern for a package name or an explicit package name. It accept only single element which can be specific package or pattern, and for including all packages use `**`. Example: `included_packages = ["**"]`
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] included_projects: List of projects on which you want this policy to run. To include repositories that are not assigned to any project, enter the project key `default`. Can be empty when `include_all_projects` is set to `true`.
               ~>This setting is relevant only on the global level, for Platform Admins.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] repos: Specify one or more patterns for the repository name(s) on which you want the archive policy to run. You can also specify explicit repository names. Specifying at least one pattern or explicit name is required. Only packages in repositories that match the pattern or explicit name will be archived. For including all repos use `**`. Example: `repos = ["**"]`
        :param pulumi.Input[_builtins.int] created_before_in_days: The archive policy will archive packages based on how long ago they were created. For example, if this parameter is 2 then packages created more than 2 days ago will be archived as part of the policy.
               > **Requires Artifactory 7.111.2 or later.**
               ~>JFrog recommends using the `created_before_in_days` condition to ensure that packages currently in use are not archived.
        :param pulumi.Input[_builtins.int] created_before_in_months: The archive policy will archive packages based on how long ago they were created. For example, if this parameter is 2 then packages created more than 2 months ago will be archived as part of the policy.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] excluded_packages: Specify explicit package names that you want excluded from the policy. Only Name explicit names (and not patterns) are accepted.
        :param pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]] excluded_properties: A key-value pair applied to the lead artifact of a package. Packages with this property will be excluded from archival.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] excluded_repos: Specify patterns for repository names or explicit repository names that you want excluded from the archive policy.
        :param pulumi.Input[_builtins.bool] include_all_projects: Set this value to `true` if you want the policy to run on all Artifactory projects. The default value is `false`.
               
               ~>This attribute is relevant only on the global level, for Platform Admins.
        :param pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]] included_properties: A key-value pair applied to the lead artifact of a package. Packages with this property will be archived.
        :param pulumi.Input[_builtins.int] keep_last_n_versions: Set a value for the number of latest versions to keep. The archive policy will remove all versions before the number you select here. The latest version is always excluded.
               
               ~>Versions are determined by creation date.
               
               ~>Not all package types support this condition. If you include a package type in your policy that is not compatible with this condition, a validation error (400) is returned. For information on which package types support this condition, see here.
        :param pulumi.Input[_builtins.int] last_downloaded_before_in_days: The archive policy will archive packages based on how long ago they were downloaded. For example, if this parameter is 5 then packages downloaded more than 5 days ago will be archived as part of the policy.
               > **Requires Artifactory 7.111.2 or later.**
               ~>JFrog recommends using the `last_downloaded_before_in_days` condition to ensure that packages currently in use are not archived.
        :param pulumi.Input[_builtins.int] last_downloaded_before_in_months: The archive policy will archive packages based on how long ago they were downloaded. For example, if this parameter is 5 then packages downloaded more than 5 months ago will be archived as part of the policy.
        """
        pulumi.set(__self__, "included_packages", included_packages)
        pulumi.set(__self__, "included_projects", included_projects)
        pulumi.set(__self__, "package_types", package_types)
        pulumi.set(__self__, "repos", repos)
        if created_before_in_days is not None:
            pulumi.set(__self__, "created_before_in_days", created_before_in_days)
        if created_before_in_months is not None:
            warnings.warn("""Use `created_before_in_days` instead of `created_before_in_months`. Renamed to `created_before_in_days` starting in version 7.111.2.""", DeprecationWarning)
            pulumi.log.warn("""created_before_in_months is deprecated: Use `created_before_in_days` instead of `created_before_in_months`. Renamed to `created_before_in_days` starting in version 7.111.2.""")
        if created_before_in_months is not None:
            pulumi.set(__self__, "created_before_in_months", created_before_in_months)
        if excluded_packages is not None:
            pulumi.set(__self__, "excluded_packages", excluded_packages)
        if excluded_properties is not None:
            pulumi.set(__self__, "excluded_properties", excluded_properties)
        if excluded_repos is not None:
            pulumi.set(__self__, "excluded_repos", excluded_repos)
        if include_all_projects is not None:
            pulumi.set(__self__, "include_all_projects", include_all_projects)
        if included_properties is not None:
            pulumi.set(__self__, "included_properties", included_properties)
        if keep_last_n_versions is not None:
            pulumi.set(__self__, "keep_last_n_versions", keep_last_n_versions)
        if last_downloaded_before_in_days is not None:
            pulumi.set(__self__, "last_downloaded_before_in_days", last_downloaded_before_in_days)
        if last_downloaded_before_in_months is not None:
            warnings.warn("""Use `last_downloaded_before_in_days` instead of `last_downloaded_before_in_months`. Renamed to `last_downloaded_before_in_days` starting in version 7.111.2.""", DeprecationWarning)
            pulumi.log.warn("""last_downloaded_before_in_months is deprecated: Use `last_downloaded_before_in_days` instead of `last_downloaded_before_in_months`. Renamed to `last_downloaded_before_in_days` starting in version 7.111.2.""")
        if last_downloaded_before_in_months is not None:
            pulumi.set(__self__, "last_downloaded_before_in_months", last_downloaded_before_in_months)

    @_builtins.property
    @pulumi.getter(name="includedPackages")
    def included_packages(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Specify a pattern for a package name or an explicit package name. It accept only single element which can be specific package or pattern, and for including all packages use `**`. Example: `included_packages = ["**"]`
        """
        return pulumi.get(self, "included_packages")

    @included_packages.setter
    def included_packages(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "included_packages", value)

    @_builtins.property
    @pulumi.getter(name="includedProjects")
    def included_projects(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of projects on which you want this policy to run. To include repositories that are not assigned to any project, enter the project key `default`. Can be empty when `include_all_projects` is set to `true`.
        ~>This setting is relevant only on the global level, for Platform Admins.
        """
        return pulumi.get(self, "included_projects")

    @included_projects.setter
    def included_projects(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "included_projects", value)

    @_builtins.property
    @pulumi.getter(name="packageTypes")
    def package_types(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "package_types")

    @package_types.setter
    def package_types(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "package_types", value)

    @_builtins.property
    @pulumi.getter
    def repos(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Specify one or more patterns for the repository name(s) on which you want the archive policy to run. You can also specify explicit repository names. Specifying at least one pattern or explicit name is required. Only packages in repositories that match the pattern or explicit name will be archived. For including all repos use `**`. Example: `repos = ["**"]`
        """
        return pulumi.get(self, "repos")

    @repos.setter
    def repos(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "repos", value)

    @_builtins.property
    @pulumi.getter(name="createdBeforeInDays")
    def created_before_in_days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The archive policy will archive packages based on how long ago they were created. For example, if this parameter is 2 then packages created more than 2 days ago will be archived as part of the policy.
        > **Requires Artifactory 7.111.2 or later.**
        ~>JFrog recommends using the `created_before_in_days` condition to ensure that packages currently in use are not archived.
        """
        return pulumi.get(self, "created_before_in_days")

    @created_before_in_days.setter
    def created_before_in_days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "created_before_in_days", value)

    @_builtins.property
    @pulumi.getter(name="createdBeforeInMonths")
    @_utilities.deprecated("""Use `created_before_in_days` instead of `created_before_in_months`. Renamed to `created_before_in_days` starting in version 7.111.2.""")
    def created_before_in_months(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The archive policy will archive packages based on how long ago they were created. For example, if this parameter is 2 then packages created more than 2 months ago will be archived as part of the policy.
        """
        return pulumi.get(self, "created_before_in_months")

    @created_before_in_months.setter
    def created_before_in_months(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "created_before_in_months", value)

    @_builtins.property
    @pulumi.getter(name="excludedPackages")
    def excluded_packages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specify explicit package names that you want excluded from the policy. Only Name explicit names (and not patterns) are accepted.
        """
        return pulumi.get(self, "excluded_packages")

    @excluded_packages.setter
    def excluded_packages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_packages", value)

    @_builtins.property
    @pulumi.getter(name="excludedProperties")
    def excluded_properties(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]]]:
        """
        A key-value pair applied to the lead artifact of a package. Packages with this property will be excluded from archival.
        """
        return pulumi.get(self, "excluded_properties")

    @excluded_properties.setter
    def excluded_properties(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]]]):
        pulumi.set(self, "excluded_properties", value)

    @_builtins.property
    @pulumi.getter(name="excludedRepos")
    def excluded_repos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specify patterns for repository names or explicit repository names that you want excluded from the archive policy.
        """
        return pulumi.get(self, "excluded_repos")

    @excluded_repos.setter
    def excluded_repos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_repos", value)

    @_builtins.property
    @pulumi.getter(name="includeAllProjects")
    def include_all_projects(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Set this value to `true` if you want the policy to run on all Artifactory projects. The default value is `false`.

        ~>This attribute is relevant only on the global level, for Platform Admins.
        """
        return pulumi.get(self, "include_all_projects")

    @include_all_projects.setter
    def include_all_projects(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "include_all_projects", value)

    @_builtins.property
    @pulumi.getter(name="includedProperties")
    def included_properties(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]]]:
        """
        A key-value pair applied to the lead artifact of a package. Packages with this property will be archived.
        """
        return pulumi.get(self, "included_properties")

    @included_properties.setter
    def included_properties(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]]]):
        pulumi.set(self, "included_properties", value)

    @_builtins.property
    @pulumi.getter(name="keepLastNVersions")
    def keep_last_n_versions(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Set a value for the number of latest versions to keep. The archive policy will remove all versions before the number you select here. The latest version is always excluded.

        ~>Versions are determined by creation date.

        ~>Not all package types support this condition. If you include a package type in your policy that is not compatible with this condition, a validation error (400) is returned. For information on which package types support this condition, see here.
        """
        return pulumi.get(self, "keep_last_n_versions")

    @keep_last_n_versions.setter
    def keep_last_n_versions(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "keep_last_n_versions", value)

    @_builtins.property
    @pulumi.getter(name="lastDownloadedBeforeInDays")
    def last_downloaded_before_in_days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The archive policy will archive packages based on how long ago they were downloaded. For example, if this parameter is 5 then packages downloaded more than 5 days ago will be archived as part of the policy.
        > **Requires Artifactory 7.111.2 or later.**
        ~>JFrog recommends using the `last_downloaded_before_in_days` condition to ensure that packages currently in use are not archived.
        """
        return pulumi.get(self, "last_downloaded_before_in_days")

    @last_downloaded_before_in_days.setter
    def last_downloaded_before_in_days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "last_downloaded_before_in_days", value)

    @_builtins.property
    @pulumi.getter(name="lastDownloadedBeforeInMonths")
    @_utilities.deprecated("""Use `last_downloaded_before_in_days` instead of `last_downloaded_before_in_months`. Renamed to `last_downloaded_before_in_days` starting in version 7.111.2.""")
    def last_downloaded_before_in_months(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The archive policy will archive packages based on how long ago they were downloaded. For example, if this parameter is 5 then packages downloaded more than 5 months ago will be archived as part of the policy.
        """
        return pulumi.get(self, "last_downloaded_before_in_months")

    @last_downloaded_before_in_months.setter
    def last_downloaded_before_in_months(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "last_downloaded_before_in_months", value)


if not MYPY:
    class ArtifactCustomWebhookCriteriaArgsDict(TypedDict):
        any_federated: pulumi.Input[_builtins.bool]
        """
        Trigger on any federated repositories
        """
        any_local: pulumi.Input[_builtins.bool]
        """
        Trigger on any local repo.
        """
        any_remote: pulumi.Input[_builtins.bool]
        """
        Trigger on any remote repo.
        """
        repo_keys: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Trigger on this list of repo keys.
        """
        exclude_patterns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        include_patterns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
elif False:
    ArtifactCustomWebhookCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ArtifactCustomWebhookCriteriaArgs:
    def __init__(__self__, *,
                 any_federated: pulumi.Input[_builtins.bool],
                 any_local: pulumi.Input[_builtins.bool],
                 any_remote: pulumi.Input[_builtins.bool],
                 repo_keys: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 exclude_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 include_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.bool] any_federated: Trigger on any federated repositories
        :param pulumi.Input[_builtins.bool] any_local: Trigger on any local repo.
        :param pulumi.Input[_builtins.bool] any_remote: Trigger on any remote repo.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] repo_keys: Trigger on this list of repo keys.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        pulumi.set(__self__, "any_federated", any_federated)
        pulumi.set(__self__, "any_local", any_local)
        pulumi.set(__self__, "any_remote", any_remote)
        pulumi.set(__self__, "repo_keys", repo_keys)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @_builtins.property
    @pulumi.getter(name="anyFederated")
    def any_federated(self) -> pulumi.Input[_builtins.bool]:
        """
        Trigger on any federated repositories
        """
        return pulumi.get(self, "any_federated")

    @any_federated.setter
    def any_federated(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "any_federated", value)

    @_builtins.property
    @pulumi.getter(name="anyLocal")
    def any_local(self) -> pulumi.Input[_builtins.bool]:
        """
        Trigger on any local repo.
        """
        return pulumi.get(self, "any_local")

    @any_local.setter
    def any_local(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "any_local", value)

    @_builtins.property
    @pulumi.getter(name="anyRemote")
    def any_remote(self) -> pulumi.Input[_builtins.bool]:
        """
        Trigger on any remote repo.
        """
        return pulumi.get(self, "any_remote")

    @any_remote.setter
    def any_remote(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "any_remote", value)

    @_builtins.property
    @pulumi.getter(name="repoKeys")
    def repo_keys(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Trigger on this list of repo keys.
        """
        return pulumi.get(self, "repo_keys")

    @repo_keys.setter
    def repo_keys(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "repo_keys", value)

    @_builtins.property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "exclude_patterns")

    @exclude_patterns.setter
    def exclude_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exclude_patterns", value)

    @_builtins.property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "include_patterns")

    @include_patterns.setter
    def include_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "include_patterns", value)


if not MYPY:
    class ArtifactCustomWebhookHandlerArgsDict(TypedDict):
        url: pulumi.Input[_builtins.str]
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        http_headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        """
        method: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the HTTP method for the URL that the Webhook invokes. Allowed values are: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`.
        """
        payload: NotRequired[pulumi.Input[_builtins.str]]
        """
        This attribute is used to build the request body. Used in custom webhooks
        """
        proxy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        secrets: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example: 
        """
elif False:
    ArtifactCustomWebhookHandlerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ArtifactCustomWebhookHandlerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[_builtins.str],
                 http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 method: Optional[pulumi.Input[_builtins.str]] = None,
                 payload: Optional[pulumi.Input[_builtins.str]] = None,
                 proxy: Optional[pulumi.Input[_builtins.str]] = None,
                 secrets: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] http_headers: HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        :param pulumi.Input[_builtins.str] method: Specifies the HTTP method for the URL that the Webhook invokes. Allowed values are: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`.
        :param pulumi.Input[_builtins.str] payload: This attribute is used to build the request body. Used in custom webhooks
        :param pulumi.Input[_builtins.str] proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] secrets: Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example: 
        """
        pulumi.set(__self__, "url", url)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        """
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "http_headers", value)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the HTTP method for the URL that the Webhook invokes. Allowed values are: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        This attribute is used to build the request body. Used in custom webhooks
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "payload", value)

    @_builtins.property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy", value)

    @_builtins.property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example: 
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "secrets", value)


if not MYPY:
    class ArtifactLifecycleCustomWebhookHandlerArgsDict(TypedDict):
        url: pulumi.Input[_builtins.str]
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        http_headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        """
        method: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the HTTP method for the URL that the Webhook invokes. Allowed values are: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`.
        """
        payload: NotRequired[pulumi.Input[_builtins.str]]
        """
        This attribute is used to build the request body. Used in custom webhooks
        """
        proxy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        secrets: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
elif False:
    ArtifactLifecycleCustomWebhookHandlerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ArtifactLifecycleCustomWebhookHandlerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[_builtins.str],
                 http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 method: Optional[pulumi.Input[_builtins.str]] = None,
                 payload: Optional[pulumi.Input[_builtins.str]] = None,
                 proxy: Optional[pulumi.Input[_builtins.str]] = None,
                 secrets: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] http_headers: HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        :param pulumi.Input[_builtins.str] method: Specifies the HTTP method for the URL that the Webhook invokes. Allowed values are: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`.
        :param pulumi.Input[_builtins.str] payload: This attribute is used to build the request body. Used in custom webhooks
        :param pulumi.Input[_builtins.str] proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] secrets: Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
        pulumi.set(__self__, "url", url)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        """
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "http_headers", value)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the HTTP method for the URL that the Webhook invokes. Allowed values are: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        This attribute is used to build the request body. Used in custom webhooks
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "payload", value)

    @_builtins.property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy", value)

    @_builtins.property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "secrets", value)


if not MYPY:
    class ArtifactLifecycleWebhookHandlerArgsDict(TypedDict):
        url: pulumi.Input[_builtins.str]
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        custom_http_headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        proxy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        use_secret_for_signing: NotRequired[pulumi.Input[_builtins.bool]]
        """
        When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
elif False:
    ArtifactLifecycleWebhookHandlerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ArtifactLifecycleWebhookHandlerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[_builtins.str],
                 custom_http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 proxy: Optional[pulumi.Input[_builtins.str]] = None,
                 secret: Optional[pulumi.Input[_builtins.str]] = None,
                 use_secret_for_signing: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] custom_http_headers: Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        :param pulumi.Input[_builtins.str] proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param pulumi.Input[_builtins.str] secret: Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        :param pulumi.Input[_builtins.bool] use_secret_for_signing: When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        pulumi.set(__self__, "url", url)
        if custom_http_headers is not None:
            pulumi.set(__self__, "custom_http_headers", custom_http_headers)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if use_secret_for_signing is not None:
            pulumi.set(__self__, "use_secret_for_signing", use_secret_for_signing)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="customHttpHeaders")
    def custom_http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        return pulumi.get(self, "custom_http_headers")

    @custom_http_headers.setter
    def custom_http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "custom_http_headers", value)

    @_builtins.property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret", value)

    @_builtins.property
    @pulumi.getter(name="useSecretForSigning")
    def use_secret_for_signing(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        return pulumi.get(self, "use_secret_for_signing")

    @use_secret_for_signing.setter
    def use_secret_for_signing(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_secret_for_signing", value)


if not MYPY:
    class ArtifactPropertyCustomWebhookCriteriaArgsDict(TypedDict):
        any_federated: pulumi.Input[_builtins.bool]
        """
        Trigger on any federated repositories
        """
        any_local: pulumi.Input[_builtins.bool]
        """
        Trigger on any local repo.
        """
        any_remote: pulumi.Input[_builtins.bool]
        """
        Trigger on any remote repo.
        """
        repo_keys: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Trigger on this list of repo keys.
        """
        exclude_patterns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        include_patterns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
elif False:
    ArtifactPropertyCustomWebhookCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ArtifactPropertyCustomWebhookCriteriaArgs:
    def __init__(__self__, *,
                 any_federated: pulumi.Input[_builtins.bool],
                 any_local: pulumi.Input[_builtins.bool],
                 any_remote: pulumi.Input[_builtins.bool],
                 repo_keys: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 exclude_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 include_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.bool] any_federated: Trigger on any federated repositories
        :param pulumi.Input[_builtins.bool] any_local: Trigger on any local repo.
        :param pulumi.Input[_builtins.bool] any_remote: Trigger on any remote repo.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] repo_keys: Trigger on this list of repo keys.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        pulumi.set(__self__, "any_federated", any_federated)
        pulumi.set(__self__, "any_local", any_local)
        pulumi.set(__self__, "any_remote", any_remote)
        pulumi.set(__self__, "repo_keys", repo_keys)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @_builtins.property
    @pulumi.getter(name="anyFederated")
    def any_federated(self) -> pulumi.Input[_builtins.bool]:
        """
        Trigger on any federated repositories
        """
        return pulumi.get(self, "any_federated")

    @any_federated.setter
    def any_federated(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "any_federated", value)

    @_builtins.property
    @pulumi.getter(name="anyLocal")
    def any_local(self) -> pulumi.Input[_builtins.bool]:
        """
        Trigger on any local repo.
        """
        return pulumi.get(self, "any_local")

    @any_local.setter
    def any_local(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "any_local", value)

    @_builtins.property
    @pulumi.getter(name="anyRemote")
    def any_remote(self) -> pulumi.Input[_builtins.bool]:
        """
        Trigger on any remote repo.
        """
        return pulumi.get(self, "any_remote")

    @any_remote.setter
    def any_remote(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "any_remote", value)

    @_builtins.property
    @pulumi.getter(name="repoKeys")
    def repo_keys(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Trigger on this list of repo keys.
        """
        return pulumi.get(self, "repo_keys")

    @repo_keys.setter
    def repo_keys(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "repo_keys", value)

    @_builtins.property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "exclude_patterns")

    @exclude_patterns.setter
    def exclude_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exclude_patterns", value)

    @_builtins.property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "include_patterns")

    @include_patterns.setter
    def include_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "include_patterns", value)


if not MYPY:
    class ArtifactPropertyCustomWebhookHandlerArgsDict(TypedDict):
        url: pulumi.Input[_builtins.str]
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        http_headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        """
        method: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the HTTP method for the URL that the Webhook invokes. Allowed values are: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`.
        """
        payload: NotRequired[pulumi.Input[_builtins.str]]
        """
        This attribute is used to build the request body. Used in custom webhooks
        """
        proxy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        secrets: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
elif False:
    ArtifactPropertyCustomWebhookHandlerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ArtifactPropertyCustomWebhookHandlerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[_builtins.str],
                 http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 method: Optional[pulumi.Input[_builtins.str]] = None,
                 payload: Optional[pulumi.Input[_builtins.str]] = None,
                 proxy: Optional[pulumi.Input[_builtins.str]] = None,
                 secrets: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] http_headers: HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        :param pulumi.Input[_builtins.str] method: Specifies the HTTP method for the URL that the Webhook invokes. Allowed values are: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`.
        :param pulumi.Input[_builtins.str] payload: This attribute is used to build the request body. Used in custom webhooks
        :param pulumi.Input[_builtins.str] proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] secrets: Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
        pulumi.set(__self__, "url", url)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        """
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "http_headers", value)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the HTTP method for the URL that the Webhook invokes. Allowed values are: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        This attribute is used to build the request body. Used in custom webhooks
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "payload", value)

    @_builtins.property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy", value)

    @_builtins.property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "secrets", value)


if not MYPY:
    class ArtifactPropertyWebhookCriteriaArgsDict(TypedDict):
        any_federated: pulumi.Input[_builtins.bool]
        """
        Trigger on any federated repo.
        """
        any_local: pulumi.Input[_builtins.bool]
        """
        Trigger on any local repo.
        """
        any_remote: pulumi.Input[_builtins.bool]
        """
        Trigger on any remote repo.
        """
        repo_keys: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Trigger on this list of repo keys.
        """
        exclude_patterns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        include_patterns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
elif False:
    ArtifactPropertyWebhookCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ArtifactPropertyWebhookCriteriaArgs:
    def __init__(__self__, *,
                 any_federated: pulumi.Input[_builtins.bool],
                 any_local: pulumi.Input[_builtins.bool],
                 any_remote: pulumi.Input[_builtins.bool],
                 repo_keys: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 exclude_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 include_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.bool] any_federated: Trigger on any federated repo.
        :param pulumi.Input[_builtins.bool] any_local: Trigger on any local repo.
        :param pulumi.Input[_builtins.bool] any_remote: Trigger on any remote repo.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] repo_keys: Trigger on this list of repo keys.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        pulumi.set(__self__, "any_federated", any_federated)
        pulumi.set(__self__, "any_local", any_local)
        pulumi.set(__self__, "any_remote", any_remote)
        pulumi.set(__self__, "repo_keys", repo_keys)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @_builtins.property
    @pulumi.getter(name="anyFederated")
    def any_federated(self) -> pulumi.Input[_builtins.bool]:
        """
        Trigger on any federated repo.
        """
        return pulumi.get(self, "any_federated")

    @any_federated.setter
    def any_federated(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "any_federated", value)

    @_builtins.property
    @pulumi.getter(name="anyLocal")
    def any_local(self) -> pulumi.Input[_builtins.bool]:
        """
        Trigger on any local repo.
        """
        return pulumi.get(self, "any_local")

    @any_local.setter
    def any_local(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "any_local", value)

    @_builtins.property
    @pulumi.getter(name="anyRemote")
    def any_remote(self) -> pulumi.Input[_builtins.bool]:
        """
        Trigger on any remote repo.
        """
        return pulumi.get(self, "any_remote")

    @any_remote.setter
    def any_remote(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "any_remote", value)

    @_builtins.property
    @pulumi.getter(name="repoKeys")
    def repo_keys(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Trigger on this list of repo keys.
        """
        return pulumi.get(self, "repo_keys")

    @repo_keys.setter
    def repo_keys(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "repo_keys", value)

    @_builtins.property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "exclude_patterns")

    @exclude_patterns.setter
    def exclude_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exclude_patterns", value)

    @_builtins.property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "include_patterns")

    @include_patterns.setter
    def include_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "include_patterns", value)


if not MYPY:
    class ArtifactPropertyWebhookHandlerArgsDict(TypedDict):
        url: pulumi.Input[_builtins.str]
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        custom_http_headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        proxy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        use_secret_for_signing: NotRequired[pulumi.Input[_builtins.bool]]
        """
        When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
elif False:
    ArtifactPropertyWebhookHandlerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ArtifactPropertyWebhookHandlerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[_builtins.str],
                 custom_http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 proxy: Optional[pulumi.Input[_builtins.str]] = None,
                 secret: Optional[pulumi.Input[_builtins.str]] = None,
                 use_secret_for_signing: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] custom_http_headers: Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        :param pulumi.Input[_builtins.str] proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param pulumi.Input[_builtins.str] secret: Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        :param pulumi.Input[_builtins.bool] use_secret_for_signing: When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        pulumi.set(__self__, "url", url)
        if custom_http_headers is not None:
            pulumi.set(__self__, "custom_http_headers", custom_http_headers)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if use_secret_for_signing is not None:
            pulumi.set(__self__, "use_secret_for_signing", use_secret_for_signing)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="customHttpHeaders")
    def custom_http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        return pulumi.get(self, "custom_http_headers")

    @custom_http_headers.setter
    def custom_http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "custom_http_headers", value)

    @_builtins.property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret", value)

    @_builtins.property
    @pulumi.getter(name="useSecretForSigning")
    def use_secret_for_signing(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        return pulumi.get(self, "use_secret_for_signing")

    @use_secret_for_signing.setter
    def use_secret_for_signing(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_secret_for_signing", value)


if not MYPY:
    class ArtifactWebhookCriteriaArgsDict(TypedDict):
        any_federated: pulumi.Input[_builtins.bool]
        """
        Trigger on any federated repo.
        """
        any_local: pulumi.Input[_builtins.bool]
        """
        Trigger on any local repo.
        """
        any_remote: pulumi.Input[_builtins.bool]
        """
        Trigger on any remote repo.
        """
        repo_keys: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Trigger on this list of repo keys.
        """
        exclude_patterns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        include_patterns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
elif False:
    ArtifactWebhookCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ArtifactWebhookCriteriaArgs:
    def __init__(__self__, *,
                 any_federated: pulumi.Input[_builtins.bool],
                 any_local: pulumi.Input[_builtins.bool],
                 any_remote: pulumi.Input[_builtins.bool],
                 repo_keys: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 exclude_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 include_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.bool] any_federated: Trigger on any federated repo.
        :param pulumi.Input[_builtins.bool] any_local: Trigger on any local repo.
        :param pulumi.Input[_builtins.bool] any_remote: Trigger on any remote repo.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] repo_keys: Trigger on this list of repo keys.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        pulumi.set(__self__, "any_federated", any_federated)
        pulumi.set(__self__, "any_local", any_local)
        pulumi.set(__self__, "any_remote", any_remote)
        pulumi.set(__self__, "repo_keys", repo_keys)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @_builtins.property
    @pulumi.getter(name="anyFederated")
    def any_federated(self) -> pulumi.Input[_builtins.bool]:
        """
        Trigger on any federated repo.
        """
        return pulumi.get(self, "any_federated")

    @any_federated.setter
    def any_federated(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "any_federated", value)

    @_builtins.property
    @pulumi.getter(name="anyLocal")
    def any_local(self) -> pulumi.Input[_builtins.bool]:
        """
        Trigger on any local repo.
        """
        return pulumi.get(self, "any_local")

    @any_local.setter
    def any_local(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "any_local", value)

    @_builtins.property
    @pulumi.getter(name="anyRemote")
    def any_remote(self) -> pulumi.Input[_builtins.bool]:
        """
        Trigger on any remote repo.
        """
        return pulumi.get(self, "any_remote")

    @any_remote.setter
    def any_remote(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "any_remote", value)

    @_builtins.property
    @pulumi.getter(name="repoKeys")
    def repo_keys(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Trigger on this list of repo keys.
        """
        return pulumi.get(self, "repo_keys")

    @repo_keys.setter
    def repo_keys(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "repo_keys", value)

    @_builtins.property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "exclude_patterns")

    @exclude_patterns.setter
    def exclude_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exclude_patterns", value)

    @_builtins.property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "include_patterns")

    @include_patterns.setter
    def include_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "include_patterns", value)


if not MYPY:
    class ArtifactWebhookHandlerArgsDict(TypedDict):
        url: pulumi.Input[_builtins.str]
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        custom_http_headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        proxy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        use_secret_for_signing: NotRequired[pulumi.Input[_builtins.bool]]
        """
        When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
elif False:
    ArtifactWebhookHandlerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ArtifactWebhookHandlerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[_builtins.str],
                 custom_http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 proxy: Optional[pulumi.Input[_builtins.str]] = None,
                 secret: Optional[pulumi.Input[_builtins.str]] = None,
                 use_secret_for_signing: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] custom_http_headers: Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        :param pulumi.Input[_builtins.str] proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param pulumi.Input[_builtins.str] secret: Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        :param pulumi.Input[_builtins.bool] use_secret_for_signing: When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        pulumi.set(__self__, "url", url)
        if custom_http_headers is not None:
            pulumi.set(__self__, "custom_http_headers", custom_http_headers)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if use_secret_for_signing is not None:
            pulumi.set(__self__, "use_secret_for_signing", use_secret_for_signing)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="customHttpHeaders")
    def custom_http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        return pulumi.get(self, "custom_http_headers")

    @custom_http_headers.setter
    def custom_http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "custom_http_headers", value)

    @_builtins.property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret", value)

    @_builtins.property
    @pulumi.getter(name="useSecretForSigning")
    def use_secret_for_signing(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        return pulumi.get(self, "use_secret_for_signing")

    @use_secret_for_signing.setter
    def use_secret_for_signing(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_secret_for_signing", value)


if not MYPY:
    class ArtifactoryReleaseBundleCustomWebhookCriteriaArgsDict(TypedDict):
        any_release_bundle: pulumi.Input[_builtins.bool]
        """
        Trigger on any release bundle
        """
        exclude_patterns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`. **Cannot be set if `any_release_bundle` is set to `true`.**
        """
        include_patterns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`. **Cannot be set if `any_release_bundle` is set to `true`.** Either this or `registered_release_bundle_names` must be set when `any_release_bundle` is `false`.
        """
        registered_release_bundle_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Trigger on this list of release bundle names
        """
elif False:
    ArtifactoryReleaseBundleCustomWebhookCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ArtifactoryReleaseBundleCustomWebhookCriteriaArgs:
    def __init__(__self__, *,
                 any_release_bundle: pulumi.Input[_builtins.bool],
                 exclude_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 include_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 registered_release_bundle_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.bool] any_release_bundle: Trigger on any release bundle
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`. **Cannot be set if `any_release_bundle` is set to `true`.**
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`. **Cannot be set if `any_release_bundle` is set to `true`.** Either this or `registered_release_bundle_names` must be set when `any_release_bundle` is `false`.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] registered_release_bundle_names: Trigger on this list of release bundle names
        """
        pulumi.set(__self__, "any_release_bundle", any_release_bundle)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)
        if registered_release_bundle_names is not None:
            pulumi.set(__self__, "registered_release_bundle_names", registered_release_bundle_names)

    @_builtins.property
    @pulumi.getter(name="anyReleaseBundle")
    def any_release_bundle(self) -> pulumi.Input[_builtins.bool]:
        """
        Trigger on any release bundle
        """
        return pulumi.get(self, "any_release_bundle")

    @any_release_bundle.setter
    def any_release_bundle(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "any_release_bundle", value)

    @_builtins.property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`. **Cannot be set if `any_release_bundle` is set to `true`.**
        """
        return pulumi.get(self, "exclude_patterns")

    @exclude_patterns.setter
    def exclude_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exclude_patterns", value)

    @_builtins.property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`. **Cannot be set if `any_release_bundle` is set to `true`.** Either this or `registered_release_bundle_names` must be set when `any_release_bundle` is `false`.
        """
        return pulumi.get(self, "include_patterns")

    @include_patterns.setter
    def include_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "include_patterns", value)

    @_builtins.property
    @pulumi.getter(name="registeredReleaseBundleNames")
    def registered_release_bundle_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Trigger on this list of release bundle names
        """
        return pulumi.get(self, "registered_release_bundle_names")

    @registered_release_bundle_names.setter
    def registered_release_bundle_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "registered_release_bundle_names", value)


if not MYPY:
    class ArtifactoryReleaseBundleCustomWebhookHandlerArgsDict(TypedDict):
        url: pulumi.Input[_builtins.str]
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        http_headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        """
        method: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the HTTP method for the URL that the Webhook invokes. Allowed values are: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`.
        """
        payload: NotRequired[pulumi.Input[_builtins.str]]
        """
        This attribute is used to build the request body. Used in custom webhooks
        """
        proxy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        secrets: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
elif False:
    ArtifactoryReleaseBundleCustomWebhookHandlerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ArtifactoryReleaseBundleCustomWebhookHandlerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[_builtins.str],
                 http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 method: Optional[pulumi.Input[_builtins.str]] = None,
                 payload: Optional[pulumi.Input[_builtins.str]] = None,
                 proxy: Optional[pulumi.Input[_builtins.str]] = None,
                 secrets: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] http_headers: HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        :param pulumi.Input[_builtins.str] method: Specifies the HTTP method for the URL that the Webhook invokes. Allowed values are: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`.
        :param pulumi.Input[_builtins.str] payload: This attribute is used to build the request body. Used in custom webhooks
        :param pulumi.Input[_builtins.str] proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] secrets: Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
        pulumi.set(__self__, "url", url)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        """
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "http_headers", value)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the HTTP method for the URL that the Webhook invokes. Allowed values are: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        This attribute is used to build the request body. Used in custom webhooks
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "payload", value)

    @_builtins.property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy", value)

    @_builtins.property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "secrets", value)


if not MYPY:
    class ArtifactoryReleaseBundleWebhookCriteriaArgsDict(TypedDict):
        any_release_bundle: pulumi.Input[_builtins.bool]
        """
        Trigger on any release bundle
        """
        exclude_patterns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`. **Cannot be set if `any_release_bundle` is set to `true`.**
        """
        include_patterns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`. **Cannot be set if `any_release_bundle` is set to `true`.** Either this or `registered_release_bundle_names` must be set when `any_release_bundle` is `false`.
        """
        registered_release_bundle_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Trigger on this list of release bundle names. Either this or `include_patterns` must be set when `any_release_bundle` is `false`.
        """
elif False:
    ArtifactoryReleaseBundleWebhookCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ArtifactoryReleaseBundleWebhookCriteriaArgs:
    def __init__(__self__, *,
                 any_release_bundle: pulumi.Input[_builtins.bool],
                 exclude_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 include_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 registered_release_bundle_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.bool] any_release_bundle: Trigger on any release bundle
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`. **Cannot be set if `any_release_bundle` is set to `true`.**
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`. **Cannot be set if `any_release_bundle` is set to `true`.** Either this or `registered_release_bundle_names` must be set when `any_release_bundle` is `false`.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] registered_release_bundle_names: Trigger on this list of release bundle names. Either this or `include_patterns` must be set when `any_release_bundle` is `false`.
        """
        pulumi.set(__self__, "any_release_bundle", any_release_bundle)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)
        if registered_release_bundle_names is not None:
            pulumi.set(__self__, "registered_release_bundle_names", registered_release_bundle_names)

    @_builtins.property
    @pulumi.getter(name="anyReleaseBundle")
    def any_release_bundle(self) -> pulumi.Input[_builtins.bool]:
        """
        Trigger on any release bundle
        """
        return pulumi.get(self, "any_release_bundle")

    @any_release_bundle.setter
    def any_release_bundle(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "any_release_bundle", value)

    @_builtins.property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`. **Cannot be set if `any_release_bundle` is set to `true`.**
        """
        return pulumi.get(self, "exclude_patterns")

    @exclude_patterns.setter
    def exclude_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exclude_patterns", value)

    @_builtins.property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`. **Cannot be set if `any_release_bundle` is set to `true`.** Either this or `registered_release_bundle_names` must be set when `any_release_bundle` is `false`.
        """
        return pulumi.get(self, "include_patterns")

    @include_patterns.setter
    def include_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "include_patterns", value)

    @_builtins.property
    @pulumi.getter(name="registeredReleaseBundleNames")
    def registered_release_bundle_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Trigger on this list of release bundle names. Either this or `include_patterns` must be set when `any_release_bundle` is `false`.
        """
        return pulumi.get(self, "registered_release_bundle_names")

    @registered_release_bundle_names.setter
    def registered_release_bundle_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "registered_release_bundle_names", value)


if not MYPY:
    class ArtifactoryReleaseBundleWebhookHandlerArgsDict(TypedDict):
        url: pulumi.Input[_builtins.str]
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        custom_http_headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        proxy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        use_secret_for_signing: NotRequired[pulumi.Input[_builtins.bool]]
        """
        When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
elif False:
    ArtifactoryReleaseBundleWebhookHandlerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ArtifactoryReleaseBundleWebhookHandlerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[_builtins.str],
                 custom_http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 proxy: Optional[pulumi.Input[_builtins.str]] = None,
                 secret: Optional[pulumi.Input[_builtins.str]] = None,
                 use_secret_for_signing: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] custom_http_headers: Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        :param pulumi.Input[_builtins.str] proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param pulumi.Input[_builtins.str] secret: Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        :param pulumi.Input[_builtins.bool] use_secret_for_signing: When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        pulumi.set(__self__, "url", url)
        if custom_http_headers is not None:
            pulumi.set(__self__, "custom_http_headers", custom_http_headers)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if use_secret_for_signing is not None:
            pulumi.set(__self__, "use_secret_for_signing", use_secret_for_signing)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="customHttpHeaders")
    def custom_http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        return pulumi.get(self, "custom_http_headers")

    @custom_http_headers.setter
    def custom_http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "custom_http_headers", value)

    @_builtins.property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret", value)

    @_builtins.property
    @pulumi.getter(name="useSecretForSigning")
    def use_secret_for_signing(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        return pulumi.get(self, "use_secret_for_signing")

    @use_secret_for_signing.setter
    def use_secret_for_signing(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_secret_for_signing", value)


if not MYPY:
    class BuildCustomWebhookCriteriaArgsDict(TypedDict):
        any_build: pulumi.Input[_builtins.bool]
        """
        Trigger on any build.
        """
        exclude_patterns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`. **Cannot be set if `any_build` is set to `true`.**
        """
        include_patterns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`. **Cannot be set if `any_build` is set to `true`.**
        """
        selected_builds: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Trigger on this list of build names.
        """
elif False:
    BuildCustomWebhookCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BuildCustomWebhookCriteriaArgs:
    def __init__(__self__, *,
                 any_build: pulumi.Input[_builtins.bool],
                 exclude_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 include_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 selected_builds: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.bool] any_build: Trigger on any build.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`. **Cannot be set if `any_build` is set to `true`.**
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`. **Cannot be set if `any_build` is set to `true`.**
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] selected_builds: Trigger on this list of build names.
        """
        pulumi.set(__self__, "any_build", any_build)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)
        if selected_builds is not None:
            pulumi.set(__self__, "selected_builds", selected_builds)

    @_builtins.property
    @pulumi.getter(name="anyBuild")
    def any_build(self) -> pulumi.Input[_builtins.bool]:
        """
        Trigger on any build.
        """
        return pulumi.get(self, "any_build")

    @any_build.setter
    def any_build(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "any_build", value)

    @_builtins.property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`. **Cannot be set if `any_build` is set to `true`.**
        """
        return pulumi.get(self, "exclude_patterns")

    @exclude_patterns.setter
    def exclude_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exclude_patterns", value)

    @_builtins.property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`. **Cannot be set if `any_build` is set to `true`.**
        """
        return pulumi.get(self, "include_patterns")

    @include_patterns.setter
    def include_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "include_patterns", value)

    @_builtins.property
    @pulumi.getter(name="selectedBuilds")
    def selected_builds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Trigger on this list of build names.
        """
        return pulumi.get(self, "selected_builds")

    @selected_builds.setter
    def selected_builds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "selected_builds", value)


if not MYPY:
    class BuildCustomWebhookHandlerArgsDict(TypedDict):
        url: pulumi.Input[_builtins.str]
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        http_headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        """
        method: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the HTTP method for the URL that the Webhook invokes. Allowed values are: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`.
        """
        payload: NotRequired[pulumi.Input[_builtins.str]]
        """
        This attribute is used to build the request body. Used in custom webhooks
        """
        proxy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        secrets: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
elif False:
    BuildCustomWebhookHandlerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BuildCustomWebhookHandlerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[_builtins.str],
                 http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 method: Optional[pulumi.Input[_builtins.str]] = None,
                 payload: Optional[pulumi.Input[_builtins.str]] = None,
                 proxy: Optional[pulumi.Input[_builtins.str]] = None,
                 secrets: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] http_headers: HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        :param pulumi.Input[_builtins.str] method: Specifies the HTTP method for the URL that the Webhook invokes. Allowed values are: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`.
        :param pulumi.Input[_builtins.str] payload: This attribute is used to build the request body. Used in custom webhooks
        :param pulumi.Input[_builtins.str] proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] secrets: Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
        pulumi.set(__self__, "url", url)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        """
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "http_headers", value)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the HTTP method for the URL that the Webhook invokes. Allowed values are: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        This attribute is used to build the request body. Used in custom webhooks
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "payload", value)

    @_builtins.property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy", value)

    @_builtins.property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "secrets", value)


if not MYPY:
    class BuildWebhookCriteriaArgsDict(TypedDict):
        any_build: pulumi.Input[_builtins.bool]
        """
        Trigger on any build.
        """
        exclude_patterns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`. **Cannot be set if `any_build` is set to `true`.**
        """
        include_patterns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`. **Cannot be set if `any_build` is set to `true`.**
        """
        selected_builds: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Trigger on this list of build names.
        """
elif False:
    BuildWebhookCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BuildWebhookCriteriaArgs:
    def __init__(__self__, *,
                 any_build: pulumi.Input[_builtins.bool],
                 exclude_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 include_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 selected_builds: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.bool] any_build: Trigger on any build.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`. **Cannot be set if `any_build` is set to `true`.**
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`. **Cannot be set if `any_build` is set to `true`.**
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] selected_builds: Trigger on this list of build names.
        """
        pulumi.set(__self__, "any_build", any_build)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)
        if selected_builds is not None:
            pulumi.set(__self__, "selected_builds", selected_builds)

    @_builtins.property
    @pulumi.getter(name="anyBuild")
    def any_build(self) -> pulumi.Input[_builtins.bool]:
        """
        Trigger on any build.
        """
        return pulumi.get(self, "any_build")

    @any_build.setter
    def any_build(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "any_build", value)

    @_builtins.property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`. **Cannot be set if `any_build` is set to `true`.**
        """
        return pulumi.get(self, "exclude_patterns")

    @exclude_patterns.setter
    def exclude_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exclude_patterns", value)

    @_builtins.property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`. **Cannot be set if `any_build` is set to `true`.**
        """
        return pulumi.get(self, "include_patterns")

    @include_patterns.setter
    def include_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "include_patterns", value)

    @_builtins.property
    @pulumi.getter(name="selectedBuilds")
    def selected_builds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Trigger on this list of build names.
        """
        return pulumi.get(self, "selected_builds")

    @selected_builds.setter
    def selected_builds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "selected_builds", value)


if not MYPY:
    class BuildWebhookHandlerArgsDict(TypedDict):
        url: pulumi.Input[_builtins.str]
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        custom_http_headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        proxy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        use_secret_for_signing: NotRequired[pulumi.Input[_builtins.bool]]
        """
        When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
elif False:
    BuildWebhookHandlerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BuildWebhookHandlerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[_builtins.str],
                 custom_http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 proxy: Optional[pulumi.Input[_builtins.str]] = None,
                 secret: Optional[pulumi.Input[_builtins.str]] = None,
                 use_secret_for_signing: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] custom_http_headers: Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        :param pulumi.Input[_builtins.str] proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param pulumi.Input[_builtins.str] secret: Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        :param pulumi.Input[_builtins.bool] use_secret_for_signing: When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        pulumi.set(__self__, "url", url)
        if custom_http_headers is not None:
            pulumi.set(__self__, "custom_http_headers", custom_http_headers)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if use_secret_for_signing is not None:
            pulumi.set(__self__, "use_secret_for_signing", use_secret_for_signing)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="customHttpHeaders")
    def custom_http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        return pulumi.get(self, "custom_http_headers")

    @custom_http_headers.setter
    def custom_http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "custom_http_headers", value)

    @_builtins.property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret", value)

    @_builtins.property
    @pulumi.getter(name="useSecretForSigning")
    def use_secret_for_signing(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        return pulumi.get(self, "use_secret_for_signing")

    @use_secret_for_signing.setter
    def use_secret_for_signing(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_secret_for_signing", value)


if not MYPY:
    class DestinationCustomWebhookCriteriaArgsDict(TypedDict):
        any_release_bundle: pulumi.Input[_builtins.bool]
        """
        Trigger on any release bundle
        """
        exclude_patterns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`
        """
        include_patterns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`
        """
        registered_release_bundle_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Trigger on this list of release bundle names
        """
elif False:
    DestinationCustomWebhookCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DestinationCustomWebhookCriteriaArgs:
    def __init__(__self__, *,
                 any_release_bundle: pulumi.Input[_builtins.bool],
                 exclude_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 include_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 registered_release_bundle_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.bool] any_release_bundle: Trigger on any release bundle
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] registered_release_bundle_names: Trigger on this list of release bundle names
        """
        pulumi.set(__self__, "any_release_bundle", any_release_bundle)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)
        if registered_release_bundle_names is not None:
            pulumi.set(__self__, "registered_release_bundle_names", registered_release_bundle_names)

    @_builtins.property
    @pulumi.getter(name="anyReleaseBundle")
    def any_release_bundle(self) -> pulumi.Input[_builtins.bool]:
        """
        Trigger on any release bundle
        """
        return pulumi.get(self, "any_release_bundle")

    @any_release_bundle.setter
    def any_release_bundle(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "any_release_bundle", value)

    @_builtins.property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`
        """
        return pulumi.get(self, "exclude_patterns")

    @exclude_patterns.setter
    def exclude_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exclude_patterns", value)

    @_builtins.property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`
        """
        return pulumi.get(self, "include_patterns")

    @include_patterns.setter
    def include_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "include_patterns", value)

    @_builtins.property
    @pulumi.getter(name="registeredReleaseBundleNames")
    def registered_release_bundle_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Trigger on this list of release bundle names
        """
        return pulumi.get(self, "registered_release_bundle_names")

    @registered_release_bundle_names.setter
    def registered_release_bundle_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "registered_release_bundle_names", value)


if not MYPY:
    class DestinationCustomWebhookHandlerArgsDict(TypedDict):
        url: pulumi.Input[_builtins.str]
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        http_headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        """
        method: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the HTTP method for the URL that the Webhook invokes. Allowed values are: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`.
        """
        payload: NotRequired[pulumi.Input[_builtins.str]]
        """
        This attribute is used to build the request body. Used in custom webhooks
        """
        proxy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        secrets: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
elif False:
    DestinationCustomWebhookHandlerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DestinationCustomWebhookHandlerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[_builtins.str],
                 http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 method: Optional[pulumi.Input[_builtins.str]] = None,
                 payload: Optional[pulumi.Input[_builtins.str]] = None,
                 proxy: Optional[pulumi.Input[_builtins.str]] = None,
                 secrets: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] http_headers: HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        :param pulumi.Input[_builtins.str] method: Specifies the HTTP method for the URL that the Webhook invokes. Allowed values are: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`.
        :param pulumi.Input[_builtins.str] payload: This attribute is used to build the request body. Used in custom webhooks
        :param pulumi.Input[_builtins.str] proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] secrets: Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
        pulumi.set(__self__, "url", url)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        """
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "http_headers", value)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the HTTP method for the URL that the Webhook invokes. Allowed values are: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        This attribute is used to build the request body. Used in custom webhooks
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "payload", value)

    @_builtins.property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy", value)

    @_builtins.property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "secrets", value)


if not MYPY:
    class DestinationWebhookCriteriaArgsDict(TypedDict):
        any_release_bundle: pulumi.Input[_builtins.bool]
        """
        Trigger on any release bundle
        """
        exclude_patterns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`
        """
        include_patterns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`
        """
        registered_release_bundle_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Trigger on this list of release bundle names
        """
elif False:
    DestinationWebhookCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DestinationWebhookCriteriaArgs:
    def __init__(__self__, *,
                 any_release_bundle: pulumi.Input[_builtins.bool],
                 exclude_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 include_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 registered_release_bundle_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.bool] any_release_bundle: Trigger on any release bundle
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] registered_release_bundle_names: Trigger on this list of release bundle names
        """
        pulumi.set(__self__, "any_release_bundle", any_release_bundle)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)
        if registered_release_bundle_names is not None:
            pulumi.set(__self__, "registered_release_bundle_names", registered_release_bundle_names)

    @_builtins.property
    @pulumi.getter(name="anyReleaseBundle")
    def any_release_bundle(self) -> pulumi.Input[_builtins.bool]:
        """
        Trigger on any release bundle
        """
        return pulumi.get(self, "any_release_bundle")

    @any_release_bundle.setter
    def any_release_bundle(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "any_release_bundle", value)

    @_builtins.property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`
        """
        return pulumi.get(self, "exclude_patterns")

    @exclude_patterns.setter
    def exclude_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exclude_patterns", value)

    @_builtins.property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`
        """
        return pulumi.get(self, "include_patterns")

    @include_patterns.setter
    def include_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "include_patterns", value)

    @_builtins.property
    @pulumi.getter(name="registeredReleaseBundleNames")
    def registered_release_bundle_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Trigger on this list of release bundle names
        """
        return pulumi.get(self, "registered_release_bundle_names")

    @registered_release_bundle_names.setter
    def registered_release_bundle_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "registered_release_bundle_names", value)


if not MYPY:
    class DestinationWebhookHandlerArgsDict(TypedDict):
        url: pulumi.Input[_builtins.str]
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        custom_http_headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        proxy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        use_secret_for_signing: NotRequired[pulumi.Input[_builtins.bool]]
        """
        When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
elif False:
    DestinationWebhookHandlerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DestinationWebhookHandlerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[_builtins.str],
                 custom_http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 proxy: Optional[pulumi.Input[_builtins.str]] = None,
                 secret: Optional[pulumi.Input[_builtins.str]] = None,
                 use_secret_for_signing: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] custom_http_headers: Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        :param pulumi.Input[_builtins.str] proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param pulumi.Input[_builtins.str] secret: Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        :param pulumi.Input[_builtins.bool] use_secret_for_signing: When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        pulumi.set(__self__, "url", url)
        if custom_http_headers is not None:
            pulumi.set(__self__, "custom_http_headers", custom_http_headers)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if use_secret_for_signing is not None:
            pulumi.set(__self__, "use_secret_for_signing", use_secret_for_signing)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="customHttpHeaders")
    def custom_http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        return pulumi.get(self, "custom_http_headers")

    @custom_http_headers.setter
    def custom_http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "custom_http_headers", value)

    @_builtins.property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret", value)

    @_builtins.property
    @pulumi.getter(name="useSecretForSigning")
    def use_secret_for_signing(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        return pulumi.get(self, "use_secret_for_signing")

    @use_secret_for_signing.setter
    def use_secret_for_signing(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_secret_for_signing", value)


if not MYPY:
    class DistributionCustomWebhookCriteriaArgsDict(TypedDict):
        any_release_bundle: pulumi.Input[_builtins.bool]
        """
        Trigger on any release bundle.
        """
        exclude_patterns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        include_patterns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        registered_release_bundle_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Trigger on this list of release bundle names.
        """
elif False:
    DistributionCustomWebhookCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DistributionCustomWebhookCriteriaArgs:
    def __init__(__self__, *,
                 any_release_bundle: pulumi.Input[_builtins.bool],
                 exclude_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 include_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 registered_release_bundle_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.bool] any_release_bundle: Trigger on any release bundle.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] registered_release_bundle_names: Trigger on this list of release bundle names.
        """
        pulumi.set(__self__, "any_release_bundle", any_release_bundle)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)
        if registered_release_bundle_names is not None:
            pulumi.set(__self__, "registered_release_bundle_names", registered_release_bundle_names)

    @_builtins.property
    @pulumi.getter(name="anyReleaseBundle")
    def any_release_bundle(self) -> pulumi.Input[_builtins.bool]:
        """
        Trigger on any release bundle.
        """
        return pulumi.get(self, "any_release_bundle")

    @any_release_bundle.setter
    def any_release_bundle(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "any_release_bundle", value)

    @_builtins.property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "exclude_patterns")

    @exclude_patterns.setter
    def exclude_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exclude_patterns", value)

    @_builtins.property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "include_patterns")

    @include_patterns.setter
    def include_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "include_patterns", value)

    @_builtins.property
    @pulumi.getter(name="registeredReleaseBundleNames")
    def registered_release_bundle_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Trigger on this list of release bundle names.
        """
        return pulumi.get(self, "registered_release_bundle_names")

    @registered_release_bundle_names.setter
    def registered_release_bundle_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "registered_release_bundle_names", value)


if not MYPY:
    class DistributionCustomWebhookHandlerArgsDict(TypedDict):
        url: pulumi.Input[_builtins.str]
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        http_headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        """
        method: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the HTTP method for the URL that the Webhook invokes. Allowed values are: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`.
        """
        payload: NotRequired[pulumi.Input[_builtins.str]]
        """
        This attribute is used to build the request body. Used in custom webhooks
        """
        proxy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        secrets: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
elif False:
    DistributionCustomWebhookHandlerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DistributionCustomWebhookHandlerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[_builtins.str],
                 http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 method: Optional[pulumi.Input[_builtins.str]] = None,
                 payload: Optional[pulumi.Input[_builtins.str]] = None,
                 proxy: Optional[pulumi.Input[_builtins.str]] = None,
                 secrets: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] http_headers: HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        :param pulumi.Input[_builtins.str] method: Specifies the HTTP method for the URL that the Webhook invokes. Allowed values are: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`.
        :param pulumi.Input[_builtins.str] payload: This attribute is used to build the request body. Used in custom webhooks
        :param pulumi.Input[_builtins.str] proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] secrets: Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
        pulumi.set(__self__, "url", url)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        """
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "http_headers", value)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the HTTP method for the URL that the Webhook invokes. Allowed values are: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        This attribute is used to build the request body. Used in custom webhooks
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "payload", value)

    @_builtins.property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy", value)

    @_builtins.property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "secrets", value)


if not MYPY:
    class DistributionWebhookCriteriaArgsDict(TypedDict):
        any_release_bundle: pulumi.Input[_builtins.bool]
        """
        Trigger on any release bundle.
        """
        exclude_patterns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        include_patterns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        registered_release_bundle_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Trigger on this list of release bundle names.
        """
elif False:
    DistributionWebhookCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DistributionWebhookCriteriaArgs:
    def __init__(__self__, *,
                 any_release_bundle: pulumi.Input[_builtins.bool],
                 exclude_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 include_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 registered_release_bundle_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.bool] any_release_bundle: Trigger on any release bundle.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] registered_release_bundle_names: Trigger on this list of release bundle names.
        """
        pulumi.set(__self__, "any_release_bundle", any_release_bundle)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)
        if registered_release_bundle_names is not None:
            pulumi.set(__self__, "registered_release_bundle_names", registered_release_bundle_names)

    @_builtins.property
    @pulumi.getter(name="anyReleaseBundle")
    def any_release_bundle(self) -> pulumi.Input[_builtins.bool]:
        """
        Trigger on any release bundle.
        """
        return pulumi.get(self, "any_release_bundle")

    @any_release_bundle.setter
    def any_release_bundle(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "any_release_bundle", value)

    @_builtins.property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "exclude_patterns")

    @exclude_patterns.setter
    def exclude_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exclude_patterns", value)

    @_builtins.property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "include_patterns")

    @include_patterns.setter
    def include_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "include_patterns", value)

    @_builtins.property
    @pulumi.getter(name="registeredReleaseBundleNames")
    def registered_release_bundle_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Trigger on this list of release bundle names.
        """
        return pulumi.get(self, "registered_release_bundle_names")

    @registered_release_bundle_names.setter
    def registered_release_bundle_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "registered_release_bundle_names", value)


if not MYPY:
    class DistributionWebhookHandlerArgsDict(TypedDict):
        url: pulumi.Input[_builtins.str]
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        custom_http_headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        proxy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        use_secret_for_signing: NotRequired[pulumi.Input[_builtins.bool]]
        """
        When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
elif False:
    DistributionWebhookHandlerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DistributionWebhookHandlerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[_builtins.str],
                 custom_http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 proxy: Optional[pulumi.Input[_builtins.str]] = None,
                 secret: Optional[pulumi.Input[_builtins.str]] = None,
                 use_secret_for_signing: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] custom_http_headers: Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        :param pulumi.Input[_builtins.str] proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param pulumi.Input[_builtins.str] secret: Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        :param pulumi.Input[_builtins.bool] use_secret_for_signing: When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        pulumi.set(__self__, "url", url)
        if custom_http_headers is not None:
            pulumi.set(__self__, "custom_http_headers", custom_http_headers)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if use_secret_for_signing is not None:
            pulumi.set(__self__, "use_secret_for_signing", use_secret_for_signing)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="customHttpHeaders")
    def custom_http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        return pulumi.get(self, "custom_http_headers")

    @custom_http_headers.setter
    def custom_http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "custom_http_headers", value)

    @_builtins.property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret", value)

    @_builtins.property
    @pulumi.getter(name="useSecretForSigning")
    def use_secret_for_signing(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        return pulumi.get(self, "use_secret_for_signing")

    @use_secret_for_signing.setter
    def use_secret_for_signing(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_secret_for_signing", value)


if not MYPY:
    class DockerCustomWebhookCriteriaArgsDict(TypedDict):
        any_federated: pulumi.Input[_builtins.bool]
        """
        Trigger on any federated repositories
        """
        any_local: pulumi.Input[_builtins.bool]
        """
        Trigger on any local repo.
        """
        any_remote: pulumi.Input[_builtins.bool]
        """
        Trigger on any remote repo.
        """
        repo_keys: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Trigger on this list of repo keys.
        """
        exclude_patterns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        include_patterns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
elif False:
    DockerCustomWebhookCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DockerCustomWebhookCriteriaArgs:
    def __init__(__self__, *,
                 any_federated: pulumi.Input[_builtins.bool],
                 any_local: pulumi.Input[_builtins.bool],
                 any_remote: pulumi.Input[_builtins.bool],
                 repo_keys: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 exclude_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 include_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.bool] any_federated: Trigger on any federated repositories
        :param pulumi.Input[_builtins.bool] any_local: Trigger on any local repo.
        :param pulumi.Input[_builtins.bool] any_remote: Trigger on any remote repo.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] repo_keys: Trigger on this list of repo keys.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        pulumi.set(__self__, "any_federated", any_federated)
        pulumi.set(__self__, "any_local", any_local)
        pulumi.set(__self__, "any_remote", any_remote)
        pulumi.set(__self__, "repo_keys", repo_keys)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @_builtins.property
    @pulumi.getter(name="anyFederated")
    def any_federated(self) -> pulumi.Input[_builtins.bool]:
        """
        Trigger on any federated repositories
        """
        return pulumi.get(self, "any_federated")

    @any_federated.setter
    def any_federated(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "any_federated", value)

    @_builtins.property
    @pulumi.getter(name="anyLocal")
    def any_local(self) -> pulumi.Input[_builtins.bool]:
        """
        Trigger on any local repo.
        """
        return pulumi.get(self, "any_local")

    @any_local.setter
    def any_local(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "any_local", value)

    @_builtins.property
    @pulumi.getter(name="anyRemote")
    def any_remote(self) -> pulumi.Input[_builtins.bool]:
        """
        Trigger on any remote repo.
        """
        return pulumi.get(self, "any_remote")

    @any_remote.setter
    def any_remote(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "any_remote", value)

    @_builtins.property
    @pulumi.getter(name="repoKeys")
    def repo_keys(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Trigger on this list of repo keys.
        """
        return pulumi.get(self, "repo_keys")

    @repo_keys.setter
    def repo_keys(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "repo_keys", value)

    @_builtins.property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "exclude_patterns")

    @exclude_patterns.setter
    def exclude_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exclude_patterns", value)

    @_builtins.property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "include_patterns")

    @include_patterns.setter
    def include_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "include_patterns", value)


if not MYPY:
    class DockerCustomWebhookHandlerArgsDict(TypedDict):
        url: pulumi.Input[_builtins.str]
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        http_headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        """
        method: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the HTTP method for the URL that the Webhook invokes. Allowed values are: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`.
        """
        payload: NotRequired[pulumi.Input[_builtins.str]]
        """
        This attribute is used to build the request body. Used in custom webhooks
        """
        proxy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        secrets: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
elif False:
    DockerCustomWebhookHandlerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DockerCustomWebhookHandlerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[_builtins.str],
                 http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 method: Optional[pulumi.Input[_builtins.str]] = None,
                 payload: Optional[pulumi.Input[_builtins.str]] = None,
                 proxy: Optional[pulumi.Input[_builtins.str]] = None,
                 secrets: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] http_headers: HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        :param pulumi.Input[_builtins.str] method: Specifies the HTTP method for the URL that the Webhook invokes. Allowed values are: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`.
        :param pulumi.Input[_builtins.str] payload: This attribute is used to build the request body. Used in custom webhooks
        :param pulumi.Input[_builtins.str] proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] secrets: Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
        pulumi.set(__self__, "url", url)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        """
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "http_headers", value)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the HTTP method for the URL that the Webhook invokes. Allowed values are: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        This attribute is used to build the request body. Used in custom webhooks
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "payload", value)

    @_builtins.property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy", value)

    @_builtins.property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "secrets", value)


if not MYPY:
    class DockerWebhookCriteriaArgsDict(TypedDict):
        any_federated: pulumi.Input[_builtins.bool]
        """
        Trigger on any federated repo.
        """
        any_local: pulumi.Input[_builtins.bool]
        """
        Trigger on any local repo.
        """
        any_remote: pulumi.Input[_builtins.bool]
        """
        Trigger on any remote repo.
        """
        repo_keys: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Trigger on this list of repo keys.
        """
        exclude_patterns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        include_patterns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
elif False:
    DockerWebhookCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DockerWebhookCriteriaArgs:
    def __init__(__self__, *,
                 any_federated: pulumi.Input[_builtins.bool],
                 any_local: pulumi.Input[_builtins.bool],
                 any_remote: pulumi.Input[_builtins.bool],
                 repo_keys: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 exclude_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 include_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.bool] any_federated: Trigger on any federated repo.
        :param pulumi.Input[_builtins.bool] any_local: Trigger on any local repo.
        :param pulumi.Input[_builtins.bool] any_remote: Trigger on any remote repo.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] repo_keys: Trigger on this list of repo keys.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        pulumi.set(__self__, "any_federated", any_federated)
        pulumi.set(__self__, "any_local", any_local)
        pulumi.set(__self__, "any_remote", any_remote)
        pulumi.set(__self__, "repo_keys", repo_keys)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @_builtins.property
    @pulumi.getter(name="anyFederated")
    def any_federated(self) -> pulumi.Input[_builtins.bool]:
        """
        Trigger on any federated repo.
        """
        return pulumi.get(self, "any_federated")

    @any_federated.setter
    def any_federated(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "any_federated", value)

    @_builtins.property
    @pulumi.getter(name="anyLocal")
    def any_local(self) -> pulumi.Input[_builtins.bool]:
        """
        Trigger on any local repo.
        """
        return pulumi.get(self, "any_local")

    @any_local.setter
    def any_local(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "any_local", value)

    @_builtins.property
    @pulumi.getter(name="anyRemote")
    def any_remote(self) -> pulumi.Input[_builtins.bool]:
        """
        Trigger on any remote repo.
        """
        return pulumi.get(self, "any_remote")

    @any_remote.setter
    def any_remote(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "any_remote", value)

    @_builtins.property
    @pulumi.getter(name="repoKeys")
    def repo_keys(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Trigger on this list of repo keys.
        """
        return pulumi.get(self, "repo_keys")

    @repo_keys.setter
    def repo_keys(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "repo_keys", value)

    @_builtins.property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "exclude_patterns")

    @exclude_patterns.setter
    def exclude_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exclude_patterns", value)

    @_builtins.property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: `org/apache/**`.
        """
        return pulumi.get(self, "include_patterns")

    @include_patterns.setter
    def include_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "include_patterns", value)


if not MYPY:
    class DockerWebhookHandlerArgsDict(TypedDict):
        url: pulumi.Input[_builtins.str]
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        custom_http_headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        proxy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        use_secret_for_signing: NotRequired[pulumi.Input[_builtins.bool]]
        """
        When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
elif False:
    DockerWebhookHandlerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DockerWebhookHandlerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[_builtins.str],
                 custom_http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 proxy: Optional[pulumi.Input[_builtins.str]] = None,
                 secret: Optional[pulumi.Input[_builtins.str]] = None,
                 use_secret_for_signing: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] custom_http_headers: Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        :param pulumi.Input[_builtins.str] proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param pulumi.Input[_builtins.str] secret: Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        :param pulumi.Input[_builtins.bool] use_secret_for_signing: When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        pulumi.set(__self__, "url", url)
        if custom_http_headers is not None:
            pulumi.set(__self__, "custom_http_headers", custom_http_headers)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if use_secret_for_signing is not None:
            pulumi.set(__self__, "use_secret_for_signing", use_secret_for_signing)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="customHttpHeaders")
    def custom_http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        return pulumi.get(self, "custom_http_headers")

    @custom_http_headers.setter
    def custom_http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "custom_http_headers", value)

    @_builtins.property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret", value)

    @_builtins.property
    @pulumi.getter(name="useSecretForSigning")
    def use_secret_for_signing(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        return pulumi.get(self, "use_secret_for_signing")

    @use_secret_for_signing.setter
    def use_secret_for_signing(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_secret_for_signing", value)


if not MYPY:
    class FederatedAlpineRepositoryMemberArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: pulumi.Input[_builtins.str]
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[pulumi.Input[_builtins.str]]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    FederatedAlpineRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FederatedAlpineRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 url: pulumi.Input[_builtins.str],
                 access_token: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[_builtins.str] url: Full URL to ending with the repository name.
        :param pulumi.Input[_builtins.str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class FederatedAnsibleRepositoryMemberArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: pulumi.Input[_builtins.str]
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[pulumi.Input[_builtins.str]]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    FederatedAnsibleRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FederatedAnsibleRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 url: pulumi.Input[_builtins.str],
                 access_token: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[_builtins.str] url: Full URL to ending with the repository name.
        :param pulumi.Input[_builtins.str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class FederatedBowerRepositoryMemberArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: pulumi.Input[_builtins.str]
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[pulumi.Input[_builtins.str]]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    FederatedBowerRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FederatedBowerRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 url: pulumi.Input[_builtins.str],
                 access_token: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[_builtins.str] url: Full URL to ending with the repository name.
        :param pulumi.Input[_builtins.str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class FederatedCargoRepositoryMemberArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: pulumi.Input[_builtins.str]
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[pulumi.Input[_builtins.str]]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    FederatedCargoRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FederatedCargoRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 url: pulumi.Input[_builtins.str],
                 access_token: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[_builtins.str] url: Full URL to ending with the repository name.
        :param pulumi.Input[_builtins.str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class FederatedChefRepositoryMemberArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: pulumi.Input[_builtins.str]
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[pulumi.Input[_builtins.str]]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    FederatedChefRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FederatedChefRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 url: pulumi.Input[_builtins.str],
                 access_token: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[_builtins.str] url: Full URL to ending with the repository name.
        :param pulumi.Input[_builtins.str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class FederatedCocoapodsRepositoryMemberArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: pulumi.Input[_builtins.str]
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[pulumi.Input[_builtins.str]]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    FederatedCocoapodsRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FederatedCocoapodsRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 url: pulumi.Input[_builtins.str],
                 access_token: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[_builtins.str] url: Full URL to ending with the repository name.
        :param pulumi.Input[_builtins.str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class FederatedComposerRepositoryMemberArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: pulumi.Input[_builtins.str]
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[pulumi.Input[_builtins.str]]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    FederatedComposerRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FederatedComposerRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 url: pulumi.Input[_builtins.str],
                 access_token: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[_builtins.str] url: Full URL to ending with the repository name.
        :param pulumi.Input[_builtins.str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class FederatedConanRepositoryMemberArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: pulumi.Input[_builtins.str]
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[pulumi.Input[_builtins.str]]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    FederatedConanRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FederatedConanRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 url: pulumi.Input[_builtins.str],
                 access_token: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[_builtins.str] url: Full URL to ending with the repository name.
        :param pulumi.Input[_builtins.str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class FederatedCondaRepositoryMemberArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: pulumi.Input[_builtins.str]
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[pulumi.Input[_builtins.str]]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    FederatedCondaRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FederatedCondaRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 url: pulumi.Input[_builtins.str],
                 access_token: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[_builtins.str] url: Full URL to ending with the repository name.
        :param pulumi.Input[_builtins.str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class FederatedCranRepositoryMemberArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: pulumi.Input[_builtins.str]
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[pulumi.Input[_builtins.str]]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    FederatedCranRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FederatedCranRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 url: pulumi.Input[_builtins.str],
                 access_token: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[_builtins.str] url: Full URL to ending with the repository name.
        :param pulumi.Input[_builtins.str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class FederatedDebianRepositoryMemberArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: pulumi.Input[_builtins.str]
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[pulumi.Input[_builtins.str]]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    FederatedDebianRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FederatedDebianRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 url: pulumi.Input[_builtins.str],
                 access_token: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[_builtins.str] url: Full URL to ending with the repository name.
        :param pulumi.Input[_builtins.str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class FederatedDockerRepositoryMemberArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: pulumi.Input[_builtins.str]
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[pulumi.Input[_builtins.str]]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    FederatedDockerRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FederatedDockerRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 url: pulumi.Input[_builtins.str],
                 access_token: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[_builtins.str] url: Full URL to ending with the repository name.
        :param pulumi.Input[_builtins.str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class FederatedDockerV1RepositoryMemberArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: pulumi.Input[_builtins.str]
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[pulumi.Input[_builtins.str]]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    FederatedDockerV1RepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FederatedDockerV1RepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 url: pulumi.Input[_builtins.str],
                 access_token: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[_builtins.str] url: Full URL to ending with the repository name.
        :param pulumi.Input[_builtins.str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class FederatedDockerV2RepositoryMemberArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: pulumi.Input[_builtins.str]
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[pulumi.Input[_builtins.str]]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    FederatedDockerV2RepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FederatedDockerV2RepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 url: pulumi.Input[_builtins.str],
                 access_token: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[_builtins.str] url: Full URL to ending with the repository name.
        :param pulumi.Input[_builtins.str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class FederatedGemsRepositoryMemberArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: pulumi.Input[_builtins.str]
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[pulumi.Input[_builtins.str]]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    FederatedGemsRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FederatedGemsRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 url: pulumi.Input[_builtins.str],
                 access_token: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[_builtins.str] url: Full URL to ending with the repository name.
        :param pulumi.Input[_builtins.str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class FederatedGenericRepositoryMemberArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: pulumi.Input[_builtins.str]
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[pulumi.Input[_builtins.str]]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    FederatedGenericRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FederatedGenericRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 url: pulumi.Input[_builtins.str],
                 access_token: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[_builtins.str] url: Full URL to ending with the repository name.
        :param pulumi.Input[_builtins.str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class FederatedGitltfsRepositoryMemberArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: pulumi.Input[_builtins.str]
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[pulumi.Input[_builtins.str]]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    FederatedGitltfsRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FederatedGitltfsRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 url: pulumi.Input[_builtins.str],
                 access_token: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[_builtins.str] url: Full URL to ending with the repository name.
        :param pulumi.Input[_builtins.str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class FederatedGoRepositoryMemberArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: pulumi.Input[_builtins.str]
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[pulumi.Input[_builtins.str]]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    FederatedGoRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FederatedGoRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 url: pulumi.Input[_builtins.str],
                 access_token: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[_builtins.str] url: Full URL to ending with the repository name.
        :param pulumi.Input[_builtins.str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class FederatedGradleRepositoryMemberArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: pulumi.Input[_builtins.str]
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[pulumi.Input[_builtins.str]]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    FederatedGradleRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FederatedGradleRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 url: pulumi.Input[_builtins.str],
                 access_token: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[_builtins.str] url: Full URL to ending with the repository name.
        :param pulumi.Input[_builtins.str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class FederatedHelmRepositoryMemberArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: pulumi.Input[_builtins.str]
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[pulumi.Input[_builtins.str]]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    FederatedHelmRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FederatedHelmRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 url: pulumi.Input[_builtins.str],
                 access_token: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[_builtins.str] url: Full URL to ending with the repository name.
        :param pulumi.Input[_builtins.str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class FederatedHelmociRepositoryMemberArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        """
        url: pulumi.Input[_builtins.str]
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[pulumi.Input[_builtins.str]]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    FederatedHelmociRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FederatedHelmociRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 url: pulumi.Input[_builtins.str],
                 access_token: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[_builtins.str] url: Full URL to ending with the repository name.
        :param pulumi.Input[_builtins.str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class FederatedHuggingfacemlRepositoryMemberArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        """
        url: pulumi.Input[_builtins.str]
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[pulumi.Input[_builtins.str]]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    FederatedHuggingfacemlRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FederatedHuggingfacemlRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 url: pulumi.Input[_builtins.str],
                 access_token: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[_builtins.str] url: Full URL to ending with the repository name.
        :param pulumi.Input[_builtins.str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class FederatedIvyRepositoryMemberArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: pulumi.Input[_builtins.str]
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[pulumi.Input[_builtins.str]]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    FederatedIvyRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FederatedIvyRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 url: pulumi.Input[_builtins.str],
                 access_token: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[_builtins.str] url: Full URL to ending with the repository name.
        :param pulumi.Input[_builtins.str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class FederatedMavenRepositoryMemberArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: pulumi.Input[_builtins.str]
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[pulumi.Input[_builtins.str]]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    FederatedMavenRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FederatedMavenRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 url: pulumi.Input[_builtins.str],
                 access_token: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[_builtins.str] url: Full URL to ending with the repository name.
        :param pulumi.Input[_builtins.str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class FederatedNpmRepositoryMemberArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: pulumi.Input[_builtins.str]
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[pulumi.Input[_builtins.str]]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    FederatedNpmRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FederatedNpmRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 url: pulumi.Input[_builtins.str],
                 access_token: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[_builtins.str] url: Full URL to ending with the repository name.
        :param pulumi.Input[_builtins.str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class FederatedNugetRepositoryMemberArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: pulumi.Input[_builtins.str]
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[pulumi.Input[_builtins.str]]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    FederatedNugetRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FederatedNugetRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 url: pulumi.Input[_builtins.str],
                 access_token: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[_builtins.str] url: Full URL to ending with the repository name.
        :param pulumi.Input[_builtins.str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class FederatedOciRepositoryMemberArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: pulumi.Input[_builtins.str]
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[pulumi.Input[_builtins.str]]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    FederatedOciRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FederatedOciRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 url: pulumi.Input[_builtins.str],
                 access_token: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[_builtins.str] url: Full URL to ending with the repository name.
        :param pulumi.Input[_builtins.str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class FederatedOpkgRepositoryMemberArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: pulumi.Input[_builtins.str]
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[pulumi.Input[_builtins.str]]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    FederatedOpkgRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FederatedOpkgRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 url: pulumi.Input[_builtins.str],
                 access_token: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[_builtins.str] url: Full URL to ending with the repository name.
        :param pulumi.Input[_builtins.str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class FederatedPuppetRepositoryMemberArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: pulumi.Input[_builtins.str]
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[pulumi.Input[_builtins.str]]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    FederatedPuppetRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FederatedPuppetRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 url: pulumi.Input[_builtins.str],
                 access_token: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[_builtins.str] url: Full URL to ending with the repository name.
        :param pulumi.Input[_builtins.str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class FederatedPypiRepositoryMemberArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: pulumi.Input[_builtins.str]
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[pulumi.Input[_builtins.str]]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    FederatedPypiRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FederatedPypiRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 url: pulumi.Input[_builtins.str],
                 access_token: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[_builtins.str] url: Full URL to ending with the repository name.
        :param pulumi.Input[_builtins.str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class FederatedReleasebundlesRepositoryMemberArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: pulumi.Input[_builtins.str]
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[pulumi.Input[_builtins.str]]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    FederatedReleasebundlesRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FederatedReleasebundlesRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 url: pulumi.Input[_builtins.str],
                 access_token: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[_builtins.str] url: Full URL to ending with the repository name.
        :param pulumi.Input[_builtins.str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class FederatedRpmRepositoryMemberArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: pulumi.Input[_builtins.str]
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[pulumi.Input[_builtins.str]]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    FederatedRpmRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FederatedRpmRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 url: pulumi.Input[_builtins.str],
                 access_token: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[_builtins.str] url: Full URL to ending with the repository name.
        :param pulumi.Input[_builtins.str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class FederatedSbtRepositoryMemberArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: pulumi.Input[_builtins.str]
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[pulumi.Input[_builtins.str]]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    FederatedSbtRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FederatedSbtRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 url: pulumi.Input[_builtins.str],
                 access_token: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[_builtins.str] url: Full URL to ending with the repository name.
        :param pulumi.Input[_builtins.str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class FederatedSwiftRepositoryMemberArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: pulumi.Input[_builtins.str]
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[pulumi.Input[_builtins.str]]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    FederatedSwiftRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FederatedSwiftRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 url: pulumi.Input[_builtins.str],
                 access_token: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[_builtins.str] url: Full URL to ending with the repository name.
        :param pulumi.Input[_builtins.str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class FederatedTerraformModuleRepositoryMemberArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: pulumi.Input[_builtins.str]
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[pulumi.Input[_builtins.str]]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    FederatedTerraformModuleRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FederatedTerraformModuleRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 url: pulumi.Input[_builtins.str],
                 access_token: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[_builtins.str] url: Full URL to ending with the repository name.
        :param pulumi.Input[_builtins.str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class FederatedTerraformProviderRepositoryMemberArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: pulumi.Input[_builtins.str]
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[pulumi.Input[_builtins.str]]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    FederatedTerraformProviderRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FederatedTerraformProviderRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 url: pulumi.Input[_builtins.str],
                 access_token: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[_builtins.str] url: Full URL to ending with the repository name.
        :param pulumi.Input[_builtins.str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class FederatedVagrantRepositoryMemberArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: pulumi.Input[_builtins.str]
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[pulumi.Input[_builtins.str]]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    FederatedVagrantRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FederatedVagrantRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 url: pulumi.Input[_builtins.str],
                 access_token: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param pulumi.Input[_builtins.str] url: Full URL to ending with the repository name.
        :param pulumi.Input[_builtins.str] access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class LocalRepositoryMultiReplicationReplicationArgsDict(TypedDict):
        url: pulumi.Input[_builtins.str]
        """
        The URL of the target local repository on a remote Artifactory server. Use the format `https://<artifactory_url>/artifactory/<repository_name>`.
        """
        username: pulumi.Input[_builtins.str]
        """
        Username on the remote Artifactory instance.
        """
        check_binary_existence_in_filestore: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enabling the `check_binary_existence_in_filestore` flag requires an Enterprise Plus license. When true, enables distributed checksum storage. For more information, see [Optimizing Repository Replication with Checksum-Based Storage](https://www.jfrog.com/confluence/display/JFROG/Repository+Replication#RepositoryReplication-OptimizingRepositoryReplicationUsingStorageLevelSynchronizationOptions).
        """
        disable_proxy: NotRequired[pulumi.Input[_builtins.bool]]
        """
        When set to `true`, the `proxy` attribute will be ignored (from version 7.41.7). The default value is `false`.
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        When set, enables replication of this repository to the target specified in `url` attribute. Default value is `true`.
        """
        exclude_path_prefix_pattern: NotRequired[pulumi.Input[_builtins.str]]
        """
        List of artifact patterns to exclude when evaluating artifact requests, in the form of `x/y/**/z/*`. By default, no artifacts are excluded.
        """
        include_path_prefix_pattern: NotRequired[pulumi.Input[_builtins.str]]
        """
        List of artifact patterns to include when evaluating artifact requests in the form of `x/y/**/z/*`. When used, only artifacts matching one of the include patterns are served. By default, all artifacts are included `(**/*)`.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        Use either the HTTP authentication password or [identity token](https://www.jfrog.com/confluence/display/JFROG/User+Profile#UserProfile-IdentityTokenidentitytoken).
        """
        proxy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Proxy key from Artifactory Proxies settings. The proxy configuration will be used when communicating with the remote instance.
        """
        replication_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Replication ID, the value is unknown until the resource is created. Can't be set or updated.
        """
        socket_timeout_millis: NotRequired[pulumi.Input[_builtins.int]]
        """
        The network timeout in milliseconds to use for remote operations. Default value is `15000`.
        """
        sync_deletes: NotRequired[pulumi.Input[_builtins.bool]]
        """
        When set, items that were deleted locally should also be deleted remotely (also applies to properties metadata). Note that enabling this option, will delete artifacts on the target that do not exist in the source repository. Default value is `false`.
        """
        sync_properties: NotRequired[pulumi.Input[_builtins.bool]]
        """
        When set, the task also synchronizes the properties of replicated artifacts. Default value is `true`.
        """
        sync_statistics: NotRequired[pulumi.Input[_builtins.bool]]
        """
        When set, the task also synchronizes artifact download statistics. Set to avoid inadvertent cleanup at the target instance when setting up replication for disaster recovery. Default value is `false`
        """
elif False:
    LocalRepositoryMultiReplicationReplicationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LocalRepositoryMultiReplicationReplicationArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[_builtins.str],
                 username: pulumi.Input[_builtins.str],
                 check_binary_existence_in_filestore: Optional[pulumi.Input[_builtins.bool]] = None,
                 disable_proxy: Optional[pulumi.Input[_builtins.bool]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 exclude_path_prefix_pattern: Optional[pulumi.Input[_builtins.str]] = None,
                 include_path_prefix_pattern: Optional[pulumi.Input[_builtins.str]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 proxy: Optional[pulumi.Input[_builtins.str]] = None,
                 replication_key: Optional[pulumi.Input[_builtins.str]] = None,
                 socket_timeout_millis: Optional[pulumi.Input[_builtins.int]] = None,
                 sync_deletes: Optional[pulumi.Input[_builtins.bool]] = None,
                 sync_properties: Optional[pulumi.Input[_builtins.bool]] = None,
                 sync_statistics: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] url: The URL of the target local repository on a remote Artifactory server. Use the format `https://<artifactory_url>/artifactory/<repository_name>`.
        :param pulumi.Input[_builtins.str] username: Username on the remote Artifactory instance.
        :param pulumi.Input[_builtins.bool] check_binary_existence_in_filestore: Enabling the `check_binary_existence_in_filestore` flag requires an Enterprise Plus license. When true, enables distributed checksum storage. For more information, see [Optimizing Repository Replication with Checksum-Based Storage](https://www.jfrog.com/confluence/display/JFROG/Repository+Replication#RepositoryReplication-OptimizingRepositoryReplicationUsingStorageLevelSynchronizationOptions).
        :param pulumi.Input[_builtins.bool] disable_proxy: When set to `true`, the `proxy` attribute will be ignored (from version 7.41.7). The default value is `false`.
        :param pulumi.Input[_builtins.bool] enabled: When set, enables replication of this repository to the target specified in `url` attribute. Default value is `true`.
        :param pulumi.Input[_builtins.str] exclude_path_prefix_pattern: List of artifact patterns to exclude when evaluating artifact requests, in the form of `x/y/**/z/*`. By default, no artifacts are excluded.
        :param pulumi.Input[_builtins.str] include_path_prefix_pattern: List of artifact patterns to include when evaluating artifact requests in the form of `x/y/**/z/*`. When used, only artifacts matching one of the include patterns are served. By default, all artifacts are included `(**/*)`.
        :param pulumi.Input[_builtins.str] password: Use either the HTTP authentication password or [identity token](https://www.jfrog.com/confluence/display/JFROG/User+Profile#UserProfile-IdentityTokenidentitytoken).
        :param pulumi.Input[_builtins.str] proxy: Proxy key from Artifactory Proxies settings. The proxy configuration will be used when communicating with the remote instance.
        :param pulumi.Input[_builtins.str] replication_key: Replication ID, the value is unknown until the resource is created. Can't be set or updated.
        :param pulumi.Input[_builtins.int] socket_timeout_millis: The network timeout in milliseconds to use for remote operations. Default value is `15000`.
        :param pulumi.Input[_builtins.bool] sync_deletes: When set, items that were deleted locally should also be deleted remotely (also applies to properties metadata). Note that enabling this option, will delete artifacts on the target that do not exist in the source repository. Default value is `false`.
        :param pulumi.Input[_builtins.bool] sync_properties: When set, the task also synchronizes the properties of replicated artifacts. Default value is `true`.
        :param pulumi.Input[_builtins.bool] sync_statistics: When set, the task also synchronizes artifact download statistics. Set to avoid inadvertent cleanup at the target instance when setting up replication for disaster recovery. Default value is `false`
        """
        pulumi.set(__self__, "url", url)
        pulumi.set(__self__, "username", username)
        if check_binary_existence_in_filestore is not None:
            pulumi.set(__self__, "check_binary_existence_in_filestore", check_binary_existence_in_filestore)
        if disable_proxy is not None:
            pulumi.set(__self__, "disable_proxy", disable_proxy)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if exclude_path_prefix_pattern is not None:
            pulumi.set(__self__, "exclude_path_prefix_pattern", exclude_path_prefix_pattern)
        if include_path_prefix_pattern is not None:
            pulumi.set(__self__, "include_path_prefix_pattern", include_path_prefix_pattern)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if replication_key is not None:
            pulumi.set(__self__, "replication_key", replication_key)
        if socket_timeout_millis is not None:
            pulumi.set(__self__, "socket_timeout_millis", socket_timeout_millis)
        if sync_deletes is not None:
            pulumi.set(__self__, "sync_deletes", sync_deletes)
        if sync_properties is not None:
            pulumi.set(__self__, "sync_properties", sync_properties)
        if sync_statistics is not None:
            pulumi.set(__self__, "sync_statistics", sync_statistics)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        The URL of the target local repository on a remote Artifactory server. Use the format `https://<artifactory_url>/artifactory/<repository_name>`.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> pulumi.Input[_builtins.str]:
        """
        Username on the remote Artifactory instance.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "username", value)

    @_builtins.property
    @pulumi.getter(name="checkBinaryExistenceInFilestore")
    def check_binary_existence_in_filestore(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enabling the `check_binary_existence_in_filestore` flag requires an Enterprise Plus license. When true, enables distributed checksum storage. For more information, see [Optimizing Repository Replication with Checksum-Based Storage](https://www.jfrog.com/confluence/display/JFROG/Repository+Replication#RepositoryReplication-OptimizingRepositoryReplicationUsingStorageLevelSynchronizationOptions).
        """
        return pulumi.get(self, "check_binary_existence_in_filestore")

    @check_binary_existence_in_filestore.setter
    def check_binary_existence_in_filestore(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "check_binary_existence_in_filestore", value)

    @_builtins.property
    @pulumi.getter(name="disableProxy")
    def disable_proxy(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When set to `true`, the `proxy` attribute will be ignored (from version 7.41.7). The default value is `false`.
        """
        return pulumi.get(self, "disable_proxy")

    @disable_proxy.setter
    def disable_proxy(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_proxy", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When set, enables replication of this repository to the target specified in `url` attribute. Default value is `true`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="excludePathPrefixPattern")
    def exclude_path_prefix_pattern(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        List of artifact patterns to exclude when evaluating artifact requests, in the form of `x/y/**/z/*`. By default, no artifacts are excluded.
        """
        return pulumi.get(self, "exclude_path_prefix_pattern")

    @exclude_path_prefix_pattern.setter
    def exclude_path_prefix_pattern(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "exclude_path_prefix_pattern", value)

    @_builtins.property
    @pulumi.getter(name="includePathPrefixPattern")
    def include_path_prefix_pattern(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        List of artifact patterns to include when evaluating artifact requests in the form of `x/y/**/z/*`. When used, only artifacts matching one of the include patterns are served. By default, all artifacts are included `(**/*)`.
        """
        return pulumi.get(self, "include_path_prefix_pattern")

    @include_path_prefix_pattern.setter
    def include_path_prefix_pattern(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "include_path_prefix_pattern", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Use either the HTTP authentication password or [identity token](https://www.jfrog.com/confluence/display/JFROG/User+Profile#UserProfile-IdentityTokenidentitytoken).
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Proxy key from Artifactory Proxies settings. The proxy configuration will be used when communicating with the remote instance.
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy", value)

    @_builtins.property
    @pulumi.getter(name="replicationKey")
    def replication_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Replication ID, the value is unknown until the resource is created. Can't be set or updated.
        """
        return pulumi.get(self, "replication_key")

    @replication_key.setter
    def replication_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "replication_key", value)

    @_builtins.property
    @pulumi.getter(name="socketTimeoutMillis")
    def socket_timeout_millis(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The network timeout in milliseconds to use for remote operations. Default value is `15000`.
        """
        return pulumi.get(self, "socket_timeout_millis")

    @socket_timeout_millis.setter
    def socket_timeout_millis(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "socket_timeout_millis", value)

    @_builtins.property
    @pulumi.getter(name="syncDeletes")
    def sync_deletes(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When set, items that were deleted locally should also be deleted remotely (also applies to properties metadata). Note that enabling this option, will delete artifacts on the target that do not exist in the source repository. Default value is `false`.
        """
        return pulumi.get(self, "sync_deletes")

    @sync_deletes.setter
    def sync_deletes(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "sync_deletes", value)

    @_builtins.property
    @pulumi.getter(name="syncProperties")
    def sync_properties(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When set, the task also synchronizes the properties of replicated artifacts. Default value is `true`.
        """
        return pulumi.get(self, "sync_properties")

    @sync_properties.setter
    def sync_properties(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "sync_properties", value)

    @_builtins.property
    @pulumi.getter(name="syncStatistics")
    def sync_statistics(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When set, the task also synchronizes artifact download statistics. Set to avoid inadvertent cleanup at the target instance when setting up replication for disaster recovery. Default value is `false`
        """
        return pulumi.get(self, "sync_statistics")

    @sync_statistics.setter
    def sync_statistics(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "sync_statistics", value)


if not MYPY:
    class ManagedUserPasswordPolicyArgsDict(TypedDict):
        digit: NotRequired[pulumi.Input[_builtins.int]]
        """
        Minimum number of digits that the password must contain
        """
        length: NotRequired[pulumi.Input[_builtins.int]]
        """
        Minimum length of the password
        """
        lowercase: NotRequired[pulumi.Input[_builtins.int]]
        """
        Minimum number of lowercase letters that the password must contain
        """
        special_char: NotRequired[pulumi.Input[_builtins.int]]
        """
        Minimum number of special char that the password must contain. Special chars list: `!"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~`
        """
        uppercase: NotRequired[pulumi.Input[_builtins.int]]
        """
        Minimum number of uppercase letters that the password must contain
        """
elif False:
    ManagedUserPasswordPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedUserPasswordPolicyArgs:
    def __init__(__self__, *,
                 digit: Optional[pulumi.Input[_builtins.int]] = None,
                 length: Optional[pulumi.Input[_builtins.int]] = None,
                 lowercase: Optional[pulumi.Input[_builtins.int]] = None,
                 special_char: Optional[pulumi.Input[_builtins.int]] = None,
                 uppercase: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] digit: Minimum number of digits that the password must contain
        :param pulumi.Input[_builtins.int] length: Minimum length of the password
        :param pulumi.Input[_builtins.int] lowercase: Minimum number of lowercase letters that the password must contain
        :param pulumi.Input[_builtins.int] special_char: Minimum number of special char that the password must contain. Special chars list: `!"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~`
        :param pulumi.Input[_builtins.int] uppercase: Minimum number of uppercase letters that the password must contain
        """
        if digit is not None:
            pulumi.set(__self__, "digit", digit)
        if length is not None:
            pulumi.set(__self__, "length", length)
        if lowercase is not None:
            pulumi.set(__self__, "lowercase", lowercase)
        if special_char is not None:
            pulumi.set(__self__, "special_char", special_char)
        if uppercase is not None:
            pulumi.set(__self__, "uppercase", uppercase)

    @_builtins.property
    @pulumi.getter
    def digit(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Minimum number of digits that the password must contain
        """
        return pulumi.get(self, "digit")

    @digit.setter
    def digit(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "digit", value)

    @_builtins.property
    @pulumi.getter
    def length(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Minimum length of the password
        """
        return pulumi.get(self, "length")

    @length.setter
    def length(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "length", value)

    @_builtins.property
    @pulumi.getter
    def lowercase(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Minimum number of lowercase letters that the password must contain
        """
        return pulumi.get(self, "lowercase")

    @lowercase.setter
    def lowercase(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "lowercase", value)

    @_builtins.property
    @pulumi.getter(name="specialChar")
    def special_char(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Minimum number of special char that the password must contain. Special chars list: `!"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~`
        """
        return pulumi.get(self, "special_char")

    @special_char.setter
    def special_char(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "special_char", value)

    @_builtins.property
    @pulumi.getter
    def uppercase(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Minimum number of uppercase letters that the password must contain
        """
        return pulumi.get(self, "uppercase")

    @uppercase.setter
    def uppercase(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "uppercase", value)


if not MYPY:
    class OauthSettingsOauthProviderArgsDict(TypedDict):
        api_url: pulumi.Input[_builtins.str]
        """
        OAuth user info endpoint for the IdP.
        """
        auth_url: pulumi.Input[_builtins.str]
        """
        OAuth authorization endpoint for the IdP.
        """
        client_id: pulumi.Input[_builtins.str]
        """
        OAuth client ID configured on the IdP.
        """
        client_secret: pulumi.Input[_builtins.str]
        """
        OAuth client secret configured on the IdP.
        """
        name: pulumi.Input[_builtins.str]
        """
        Name of the Artifactory OAuth provider.
        """
        token_url: pulumi.Input[_builtins.str]
        """
        OAuth token endpoint for the IdP.
        """
        type: pulumi.Input[_builtins.str]
        """
        Type of OAuth provider. (e.g., `github`, `google`, `cloudfoundry`, or `openId`)
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable the Artifactory OAuth provider.  Default value is `true`.
        """
elif False:
    OauthSettingsOauthProviderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OauthSettingsOauthProviderArgs:
    def __init__(__self__, *,
                 api_url: pulumi.Input[_builtins.str],
                 auth_url: pulumi.Input[_builtins.str],
                 client_id: pulumi.Input[_builtins.str],
                 client_secret: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 token_url: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] api_url: OAuth user info endpoint for the IdP.
        :param pulumi.Input[_builtins.str] auth_url: OAuth authorization endpoint for the IdP.
        :param pulumi.Input[_builtins.str] client_id: OAuth client ID configured on the IdP.
        :param pulumi.Input[_builtins.str] client_secret: OAuth client secret configured on the IdP.
        :param pulumi.Input[_builtins.str] name: Name of the Artifactory OAuth provider.
        :param pulumi.Input[_builtins.str] token_url: OAuth token endpoint for the IdP.
        :param pulumi.Input[_builtins.str] type: Type of OAuth provider. (e.g., `github`, `google`, `cloudfoundry`, or `openId`)
        :param pulumi.Input[_builtins.bool] enabled: Enable the Artifactory OAuth provider.  Default value is `true`.
        """
        pulumi.set(__self__, "api_url", api_url)
        pulumi.set(__self__, "auth_url", auth_url)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "token_url", token_url)
        pulumi.set(__self__, "type", type)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter(name="apiUrl")
    def api_url(self) -> pulumi.Input[_builtins.str]:
        """
        OAuth user info endpoint for the IdP.
        """
        return pulumi.get(self, "api_url")

    @api_url.setter
    def api_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "api_url", value)

    @_builtins.property
    @pulumi.getter(name="authUrl")
    def auth_url(self) -> pulumi.Input[_builtins.str]:
        """
        OAuth authorization endpoint for the IdP.
        """
        return pulumi.get(self, "auth_url")

    @auth_url.setter
    def auth_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "auth_url", value)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[_builtins.str]:
        """
        OAuth client ID configured on the IdP.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[_builtins.str]:
        """
        OAuth client secret configured on the IdP.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "client_secret", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the Artifactory OAuth provider.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="tokenUrl")
    def token_url(self) -> pulumi.Input[_builtins.str]:
        """
        OAuth token endpoint for the IdP.
        """
        return pulumi.get(self, "token_url")

    @token_url.setter
    def token_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token_url", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of OAuth provider. (e.g., `github`, `google`, `cloudfoundry`, or `openId`)
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable the Artifactory OAuth provider.  Default value is `true`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class PackageCleanupPolicySearchCriteriaArgsDict(TypedDict):
        included_packages: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Specify a pattern for a package name or an explicit package name on which you want the cleanup policy to run. Only one pattern or explicit name can be entered. To include all packages, use `**`. Example: `included_packages = ["**"]`
        """
        included_projects: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Enter the project keys for the projects on which you want the policy to run. To include repositories that are not assigned to any project, enter the project key `default`. Can be empty when `include_all_projects` is set to `true`.
        """
        package_types: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        repos: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Specify one or more patterns for the repository name(s) on which you want the cleanup policy to run. You can also specify explicit repository names. Specifying at least one pattern or explicit name is mandatory. Only packages in repositories that match the pattern or explicit name will be deleted. For including all repos use `**`. Example: `repos = ["**"]`
        """
        created_before_in_days: NotRequired[pulumi.Input[_builtins.int]]
        """
        The cleanup policy will delete packages based on how long ago they were created. For example, if this parameter is 5 then packages created more than 5 days ago will be deleted as part of the policy.

        ~>JFrog recommends using the `created_before_in_days` condition to ensure that packages currently in use are not deleted.
        """
        created_before_in_months: NotRequired[pulumi.Input[_builtins.int]]
        """
        The cleanup policy will delete packages based on how long ago they were created. For example, if this parameter is 2 then packages created more than 2 months ago will be deleted as part of the policy.

        ~>JFrog recommends using the `created_before_in_months` condition to ensure that packages currently in use are not deleted.
        """
        excluded_packages: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specify explicit package names that you want excluded from the policy. Only explicit names (and not patterns) are accepted.
        """
        excluded_properties: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]]]
        """
        A key-value pair applied to the lead artifact of a package. Packages with this property will be excluded from deletion.
        """
        excluded_repos: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specify patterns for repository names or explicit repository names that you want excluded from the cleanup policy.
        """
        include_all_projects: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Set this value to `true` if you want the policy to run on all Artifactory projects. The default value is `false`.

         ~>This parameter is relevant only on the global level, for Platform Admins.
        """
        included_properties: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]]]
        """
        A key-value pair applied to the lead artifact of a package. Packages with this property will be deleted.
        """
        keep_last_n_versions: NotRequired[pulumi.Input[_builtins.int]]
        """
        Set a value for the number of latest versions to keep. The cleanup policy will remove all versions prior to the number you select here. The latest version is always excluded.

        ~>Not all package types support this condition. For information on which package types support this condition, [learn more](https://jfrog.com/help/r/jfrog-platform-administration-documentation/retention-policies/package-types-coverage).
        """
        last_downloaded_before_in_days: NotRequired[pulumi.Input[_builtins.int]]
        """
        The cleanup policy will delete packages based on how long ago they were downloaded. For example, if this parameter is 5 then packages downloaded more than 5 days ago will be deleted as part of the policy.

        ~>JFrog recommends using the `last_downloaded_before_in_days` condition to ensure that packages currently in use are not deleted.
        """
        last_downloaded_before_in_months: NotRequired[pulumi.Input[_builtins.int]]
        """
        The cleanup policy will delete packages based on how long ago they were downloaded. For example, if this parameter is 5 then packages downloaded more than 5 months ago will be deleted as part of the policy.

        ~>JFrog recommends using the `last_downloaded_before_in_months` condition to ensure that packages currently in use are not deleted.
        """
elif False:
    PackageCleanupPolicySearchCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PackageCleanupPolicySearchCriteriaArgs:
    def __init__(__self__, *,
                 included_packages: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 included_projects: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 package_types: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 repos: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 created_before_in_days: Optional[pulumi.Input[_builtins.int]] = None,
                 created_before_in_months: Optional[pulumi.Input[_builtins.int]] = None,
                 excluded_packages: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 excluded_properties: Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]]] = None,
                 excluded_repos: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 include_all_projects: Optional[pulumi.Input[_builtins.bool]] = None,
                 included_properties: Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]]] = None,
                 keep_last_n_versions: Optional[pulumi.Input[_builtins.int]] = None,
                 last_downloaded_before_in_days: Optional[pulumi.Input[_builtins.int]] = None,
                 last_downloaded_before_in_months: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] included_packages: Specify a pattern for a package name or an explicit package name on which you want the cleanup policy to run. Only one pattern or explicit name can be entered. To include all packages, use `**`. Example: `included_packages = ["**"]`
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] included_projects: Enter the project keys for the projects on which you want the policy to run. To include repositories that are not assigned to any project, enter the project key `default`. Can be empty when `include_all_projects` is set to `true`.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] repos: Specify one or more patterns for the repository name(s) on which you want the cleanup policy to run. You can also specify explicit repository names. Specifying at least one pattern or explicit name is mandatory. Only packages in repositories that match the pattern or explicit name will be deleted. For including all repos use `**`. Example: `repos = ["**"]`
        :param pulumi.Input[_builtins.int] created_before_in_days: The cleanup policy will delete packages based on how long ago they were created. For example, if this parameter is 5 then packages created more than 5 days ago will be deleted as part of the policy.
               
               ~>JFrog recommends using the `created_before_in_days` condition to ensure that packages currently in use are not deleted.
        :param pulumi.Input[_builtins.int] created_before_in_months: The cleanup policy will delete packages based on how long ago they were created. For example, if this parameter is 2 then packages created more than 2 months ago will be deleted as part of the policy.
               
               ~>JFrog recommends using the `created_before_in_months` condition to ensure that packages currently in use are not deleted.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] excluded_packages: Specify explicit package names that you want excluded from the policy. Only explicit names (and not patterns) are accepted.
        :param pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]] excluded_properties: A key-value pair applied to the lead artifact of a package. Packages with this property will be excluded from deletion.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] excluded_repos: Specify patterns for repository names or explicit repository names that you want excluded from the cleanup policy.
        :param pulumi.Input[_builtins.bool] include_all_projects: Set this value to `true` if you want the policy to run on all Artifactory projects. The default value is `false`.
               
                ~>This parameter is relevant only on the global level, for Platform Admins.
        :param pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]] included_properties: A key-value pair applied to the lead artifact of a package. Packages with this property will be deleted.
        :param pulumi.Input[_builtins.int] keep_last_n_versions: Set a value for the number of latest versions to keep. The cleanup policy will remove all versions prior to the number you select here. The latest version is always excluded.
               
               ~>Not all package types support this condition. For information on which package types support this condition, [learn more](https://jfrog.com/help/r/jfrog-platform-administration-documentation/retention-policies/package-types-coverage).
        :param pulumi.Input[_builtins.int] last_downloaded_before_in_days: The cleanup policy will delete packages based on how long ago they were downloaded. For example, if this parameter is 5 then packages downloaded more than 5 days ago will be deleted as part of the policy.
               
               ~>JFrog recommends using the `last_downloaded_before_in_days` condition to ensure that packages currently in use are not deleted.
        :param pulumi.Input[_builtins.int] last_downloaded_before_in_months: The cleanup policy will delete packages based on how long ago they were downloaded. For example, if this parameter is 5 then packages downloaded more than 5 months ago will be deleted as part of the policy.
               
               ~>JFrog recommends using the `last_downloaded_before_in_months` condition to ensure that packages currently in use are not deleted.
        """
        pulumi.set(__self__, "included_packages", included_packages)
        pulumi.set(__self__, "included_projects", included_projects)
        pulumi.set(__self__, "package_types", package_types)
        pulumi.set(__self__, "repos", repos)
        if created_before_in_days is not None:
            pulumi.set(__self__, "created_before_in_days", created_before_in_days)
        if created_before_in_months is not None:
            warnings.warn("""Use `created_before_in_days` instead of `created_before_in_months`. Renamed to `created_before_in_days` starting in version 7.111.2.""", DeprecationWarning)
            pulumi.log.warn("""created_before_in_months is deprecated: Use `created_before_in_days` instead of `created_before_in_months`. Renamed to `created_before_in_days` starting in version 7.111.2.""")
        if created_before_in_months is not None:
            pulumi.set(__self__, "created_before_in_months", created_before_in_months)
        if excluded_packages is not None:
            pulumi.set(__self__, "excluded_packages", excluded_packages)
        if excluded_properties is not None:
            pulumi.set(__self__, "excluded_properties", excluded_properties)
        if excluded_repos is not None:
            pulumi.set(__self__, "excluded_repos", excluded_repos)
        if include_all_projects is not None:
            pulumi.set(__self__, "include_all_projects", include_all_projects)
        if included_properties is not None:
            pulumi.set(__self__, "included_properties", included_properties)
        if keep_last_n_versions is not None:
            pulumi.set(__self__, "keep_last_n_versions", keep_last_n_versions)
        if last_downloaded_before_in_days is not None:
            pulumi.set(__self__, "last_downloaded_before_in_days", last_downloaded_before_in_days)
        if last_downloaded_before_in_months is not None:
            warnings.warn("""Use `last_downloaded_before_in_days` instead of `last_downloaded_before_in_months`. Renamed to `last_downloaded_before_in_days` starting in version 7.111.2.""", DeprecationWarning)
            pulumi.log.warn("""last_downloaded_before_in_months is deprecated: Use `last_downloaded_before_in_days` instead of `last_downloaded_before_in_months`. Renamed to `last_downloaded_before_in_days` starting in version 7.111.2.""")
        if last_downloaded_before_in_months is not None:
            pulumi.set(__self__, "last_downloaded_before_in_months", last_downloaded_before_in_months)

    @_builtins.property
    @pulumi.getter(name="includedPackages")
    def included_packages(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Specify a pattern for a package name or an explicit package name on which you want the cleanup policy to run. Only one pattern or explicit name can be entered. To include all packages, use `**`. Example: `included_packages = ["**"]`
        """
        return pulumi.get(self, "included_packages")

    @included_packages.setter
    def included_packages(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "included_packages", value)

    @_builtins.property
    @pulumi.getter(name="includedProjects")
    def included_projects(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Enter the project keys for the projects on which you want the policy to run. To include repositories that are not assigned to any project, enter the project key `default`. Can be empty when `include_all_projects` is set to `true`.
        """
        return pulumi.get(self, "included_projects")

    @included_projects.setter
    def included_projects(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "included_projects", value)

    @_builtins.property
    @pulumi.getter(name="packageTypes")
    def package_types(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "package_types")

    @package_types.setter
    def package_types(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "package_types", value)

    @_builtins.property
    @pulumi.getter
    def repos(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Specify one or more patterns for the repository name(s) on which you want the cleanup policy to run. You can also specify explicit repository names. Specifying at least one pattern or explicit name is mandatory. Only packages in repositories that match the pattern or explicit name will be deleted. For including all repos use `**`. Example: `repos = ["**"]`
        """
        return pulumi.get(self, "repos")

    @repos.setter
    def repos(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "repos", value)

    @_builtins.property
    @pulumi.getter(name="createdBeforeInDays")
    def created_before_in_days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The cleanup policy will delete packages based on how long ago they were created. For example, if this parameter is 5 then packages created more than 5 days ago will be deleted as part of the policy.

        ~>JFrog recommends using the `created_before_in_days` condition to ensure that packages currently in use are not deleted.
        """
        return pulumi.get(self, "created_before_in_days")

    @created_before_in_days.setter
    def created_before_in_days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "created_before_in_days", value)

    @_builtins.property
    @pulumi.getter(name="createdBeforeInMonths")
    @_utilities.deprecated("""Use `created_before_in_days` instead of `created_before_in_months`. Renamed to `created_before_in_days` starting in version 7.111.2.""")
    def created_before_in_months(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The cleanup policy will delete packages based on how long ago they were created. For example, if this parameter is 2 then packages created more than 2 months ago will be deleted as part of the policy.

        ~>JFrog recommends using the `created_before_in_months` condition to ensure that packages currently in use are not deleted.
        """
        return pulumi.get(self, "created_before_in_months")

    @created_before_in_months.setter
    def created_before_in_months(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "created_before_in_months", value)

    @_builtins.property
    @pulumi.getter(name="excludedPackages")
    def excluded_packages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specify explicit package names that you want excluded from the policy. Only explicit names (and not patterns) are accepted.
        """
        return pulumi.get(self, "excluded_packages")

    @excluded_packages.setter
    def excluded_packages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_packages", value)

    @_builtins.property
    @pulumi.getter(name="excludedProperties")
    def excluded_properties(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]]]:
        """
        A key-value pair applied to the lead artifact of a package. Packages with this property will be excluded from deletion.
        """
        return pulumi.get(self, "excluded_properties")

    @excluded_properties.setter
    def excluded_properties(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]]]):
        pulumi.set(self, "excluded_properties", value)

    @_builtins.property
    @pulumi.getter(name="excludedRepos")
    def excluded_repos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specify patterns for repository names or explicit repository names that you want excluded from the cleanup policy.
        """
        return pulumi.get(self, "excluded_repos")

    @excluded_repos.setter
    def excluded_repos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_repos", value)

    @_builtins.property
    @pulumi.getter(name="includeAllProjects")
    def include_all_projects(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Set this value to `true` if you want the policy to run on all Artifactory projects. The default value is `false`.

         ~>This parameter is relevant only on the global level, for Platform Admins.
        """
        return pulumi.get(self, "include_all_projects")

    @include_all_projects.setter
    def include_all_projects(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "include_all_projects", value)

    @_builtins.property
    @pulumi.getter(name="includedProperties")
    def included_properties(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]]]:
        """
        A key-value pair applied to the lead artifact of a package. Packages with this property will be deleted.
        """
        return pulumi.get(self, "included_properties")

    @included_properties.setter
    def included_properties(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]]]):
        pulumi.set(self, "included_properties", value)

    @_builtins.property
    @pulumi.getter(name="keepLastNVersions")
    def keep_last_n_versions(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Set a value for the number of latest versions to keep. The cleanup policy will remove all versions prior to the number you select here. The latest version is always excluded.

        ~>Not all package types support this condition. For information on which package types support this condition, [learn more](https://jfrog.com/help/r/jfrog-platform-administration-documentation/retention-policies/package-types-coverage).
        """
        return pulumi.get(self, "keep_last_n_versions")

    @keep_last_n_versions.setter
    def keep_last_n_versions(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "keep_last_n_versions", value)

    @_builtins.property
    @pulumi.getter(name="lastDownloadedBeforeInDays")
    def last_downloaded_before_in_days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The cleanup policy will delete packages based on how long ago they were downloaded. For example, if this parameter is 5 then packages downloaded more than 5 days ago will be deleted as part of the policy.

        ~>JFrog recommends using the `last_downloaded_before_in_days` condition to ensure that packages currently in use are not deleted.
        """
        return pulumi.get(self, "last_downloaded_before_in_days")

    @last_downloaded_before_in_days.setter
    def last_downloaded_before_in_days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "last_downloaded_before_in_days", value)

    @_builtins.property
    @pulumi.getter(name="lastDownloadedBeforeInMonths")
    @_utilities.deprecated("""Use `last_downloaded_before_in_days` instead of `last_downloaded_before_in_months`. Renamed to `last_downloaded_before_in_days` starting in version 7.111.2.""")
    def last_downloaded_before_in_months(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The cleanup policy will delete packages based on how long ago they were downloaded. For example, if this parameter is 5 then packages downloaded more than 5 months ago will be deleted as part of the policy.

        ~>JFrog recommends using the `last_downloaded_before_in_months` condition to ensure that packages currently in use are not deleted.
        """
        return pulumi.get(self, "last_downloaded_before_in_months")

    @last_downloaded_before_in_months.setter
    def last_downloaded_before_in_months(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "last_downloaded_before_in_months", value)


if not MYPY:
    class PermissionTargetBuildArgsDict(TypedDict):
        repositories: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        This can only be 1 value: "artifactory-build-info", and currently, validation of sets/lists is not allowed. Artifactory will reject the request if you change this
        """
        actions: NotRequired[pulumi.Input['PermissionTargetBuildActionsArgsDict']]
        excludes_patterns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The default value will be [] if nothing is supplied
        """
        includes_patterns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The default value will be [""] if nothing is supplied
        """
elif False:
    PermissionTargetBuildArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PermissionTargetBuildArgs:
    def __init__(__self__, *,
                 repositories: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 actions: Optional[pulumi.Input['PermissionTargetBuildActionsArgs']] = None,
                 excludes_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 includes_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] repositories: This can only be 1 value: "artifactory-build-info", and currently, validation of sets/lists is not allowed. Artifactory will reject the request if you change this
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] excludes_patterns: The default value will be [] if nothing is supplied
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] includes_patterns: The default value will be [""] if nothing is supplied
        """
        pulumi.set(__self__, "repositories", repositories)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if excludes_patterns is not None:
            pulumi.set(__self__, "excludes_patterns", excludes_patterns)
        if includes_patterns is not None:
            pulumi.set(__self__, "includes_patterns", includes_patterns)

    @_builtins.property
    @pulumi.getter
    def repositories(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        This can only be 1 value: "artifactory-build-info", and currently, validation of sets/lists is not allowed. Artifactory will reject the request if you change this
        """
        return pulumi.get(self, "repositories")

    @repositories.setter
    def repositories(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "repositories", value)

    @_builtins.property
    @pulumi.getter
    def actions(self) -> Optional[pulumi.Input['PermissionTargetBuildActionsArgs']]:
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional[pulumi.Input['PermissionTargetBuildActionsArgs']]):
        pulumi.set(self, "actions", value)

    @_builtins.property
    @pulumi.getter(name="excludesPatterns")
    def excludes_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The default value will be [] if nothing is supplied
        """
        return pulumi.get(self, "excludes_patterns")

    @excludes_patterns.setter
    def excludes_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excludes_patterns", value)

    @_builtins.property
    @pulumi.getter(name="includesPatterns")
    def includes_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The default value will be [""] if nothing is supplied
        """
        return pulumi.get(self, "includes_patterns")

    @includes_patterns.setter
    def includes_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "includes_patterns", value)


if not MYPY:
    class PermissionTargetBuildActionsArgsDict(TypedDict):
        groups: NotRequired[pulumi.Input[Sequence[pulumi.Input['PermissionTargetBuildActionsGroupArgsDict']]]]
        """
        Groups this permission applies for.
        """
        users: NotRequired[pulumi.Input[Sequence[pulumi.Input['PermissionTargetBuildActionsUserArgsDict']]]]
        """
        Users this permission target applies for.
        """
elif False:
    PermissionTargetBuildActionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PermissionTargetBuildActionsArgs:
    def __init__(__self__, *,
                 groups: Optional[pulumi.Input[Sequence[pulumi.Input['PermissionTargetBuildActionsGroupArgs']]]] = None,
                 users: Optional[pulumi.Input[Sequence[pulumi.Input['PermissionTargetBuildActionsUserArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PermissionTargetBuildActionsGroupArgs']]] groups: Groups this permission applies for.
        :param pulumi.Input[Sequence[pulumi.Input['PermissionTargetBuildActionsUserArgs']]] users: Users this permission target applies for.
        """
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @_builtins.property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PermissionTargetBuildActionsGroupArgs']]]]:
        """
        Groups this permission applies for.
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PermissionTargetBuildActionsGroupArgs']]]]):
        pulumi.set(self, "groups", value)

    @_builtins.property
    @pulumi.getter
    def users(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PermissionTargetBuildActionsUserArgs']]]]:
        """
        Users this permission target applies for.
        """
        return pulumi.get(self, "users")

    @users.setter
    def users(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PermissionTargetBuildActionsUserArgs']]]]):
        pulumi.set(self, "users", value)


if not MYPY:
    class PermissionTargetBuildActionsGroupArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name of permission.
        """
        permissions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    PermissionTargetBuildActionsGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PermissionTargetBuildActionsGroupArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 permissions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[_builtins.str] name: Name of permission.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of permission.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def permissions(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "permissions", value)


if not MYPY:
    class PermissionTargetBuildActionsUserArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name of permission.
        """
        permissions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    PermissionTargetBuildActionsUserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PermissionTargetBuildActionsUserArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 permissions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[_builtins.str] name: Name of permission.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of permission.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def permissions(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "permissions", value)


if not MYPY:
    class PermissionTargetReleaseBundleArgsDict(TypedDict):
        repositories: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        This can only be 1 value: "artifactory-build-info", and currently, validation of sets/lists is not allowed. Artifactory will reject the request if you change this
        """
        actions: NotRequired[pulumi.Input['PermissionTargetReleaseBundleActionsArgsDict']]
        excludes_patterns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The default value will be [] if nothing is supplied
        """
        includes_patterns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The default value will be [""] if nothing is supplied
        """
elif False:
    PermissionTargetReleaseBundleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PermissionTargetReleaseBundleArgs:
    def __init__(__self__, *,
                 repositories: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 actions: Optional[pulumi.Input['PermissionTargetReleaseBundleActionsArgs']] = None,
                 excludes_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 includes_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] repositories: This can only be 1 value: "artifactory-build-info", and currently, validation of sets/lists is not allowed. Artifactory will reject the request if you change this
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] excludes_patterns: The default value will be [] if nothing is supplied
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] includes_patterns: The default value will be [""] if nothing is supplied
        """
        pulumi.set(__self__, "repositories", repositories)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if excludes_patterns is not None:
            pulumi.set(__self__, "excludes_patterns", excludes_patterns)
        if includes_patterns is not None:
            pulumi.set(__self__, "includes_patterns", includes_patterns)

    @_builtins.property
    @pulumi.getter
    def repositories(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        This can only be 1 value: "artifactory-build-info", and currently, validation of sets/lists is not allowed. Artifactory will reject the request if you change this
        """
        return pulumi.get(self, "repositories")

    @repositories.setter
    def repositories(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "repositories", value)

    @_builtins.property
    @pulumi.getter
    def actions(self) -> Optional[pulumi.Input['PermissionTargetReleaseBundleActionsArgs']]:
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional[pulumi.Input['PermissionTargetReleaseBundleActionsArgs']]):
        pulumi.set(self, "actions", value)

    @_builtins.property
    @pulumi.getter(name="excludesPatterns")
    def excludes_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The default value will be [] if nothing is supplied
        """
        return pulumi.get(self, "excludes_patterns")

    @excludes_patterns.setter
    def excludes_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excludes_patterns", value)

    @_builtins.property
    @pulumi.getter(name="includesPatterns")
    def includes_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The default value will be [""] if nothing is supplied
        """
        return pulumi.get(self, "includes_patterns")

    @includes_patterns.setter
    def includes_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "includes_patterns", value)


if not MYPY:
    class PermissionTargetReleaseBundleActionsArgsDict(TypedDict):
        groups: NotRequired[pulumi.Input[Sequence[pulumi.Input['PermissionTargetReleaseBundleActionsGroupArgsDict']]]]
        """
        Groups this permission applies for.
        """
        users: NotRequired[pulumi.Input[Sequence[pulumi.Input['PermissionTargetReleaseBundleActionsUserArgsDict']]]]
        """
        Users this permission target applies for.
        """
elif False:
    PermissionTargetReleaseBundleActionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PermissionTargetReleaseBundleActionsArgs:
    def __init__(__self__, *,
                 groups: Optional[pulumi.Input[Sequence[pulumi.Input['PermissionTargetReleaseBundleActionsGroupArgs']]]] = None,
                 users: Optional[pulumi.Input[Sequence[pulumi.Input['PermissionTargetReleaseBundleActionsUserArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PermissionTargetReleaseBundleActionsGroupArgs']]] groups: Groups this permission applies for.
        :param pulumi.Input[Sequence[pulumi.Input['PermissionTargetReleaseBundleActionsUserArgs']]] users: Users this permission target applies for.
        """
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @_builtins.property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PermissionTargetReleaseBundleActionsGroupArgs']]]]:
        """
        Groups this permission applies for.
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PermissionTargetReleaseBundleActionsGroupArgs']]]]):
        pulumi.set(self, "groups", value)

    @_builtins.property
    @pulumi.getter
    def users(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PermissionTargetReleaseBundleActionsUserArgs']]]]:
        """
        Users this permission target applies for.
        """
        return pulumi.get(self, "users")

    @users.setter
    def users(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PermissionTargetReleaseBundleActionsUserArgs']]]]):
        pulumi.set(self, "users", value)


if not MYPY:
    class PermissionTargetReleaseBundleActionsGroupArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name of permission.
        """
        permissions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    PermissionTargetReleaseBundleActionsGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PermissionTargetReleaseBundleActionsGroupArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 permissions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[_builtins.str] name: Name of permission.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of permission.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def permissions(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "permissions", value)


if not MYPY:
    class PermissionTargetReleaseBundleActionsUserArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name of permission.
        """
        permissions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    PermissionTargetReleaseBundleActionsUserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PermissionTargetReleaseBundleActionsUserArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 permissions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[_builtins.str] name: Name of permission.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of permission.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def permissions(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "permissions", value)


if not MYPY:
    class PermissionTargetRepoArgsDict(TypedDict):
        repositories: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of repositories this permission target is applicable for. You can specify the name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        """
        actions: NotRequired[pulumi.Input['PermissionTargetRepoActionsArgsDict']]
        excludes_patterns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Pattern of artifacts to exclude.
        """
        includes_patterns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Pattern of artifacts to include.
        """
elif False:
    PermissionTargetRepoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PermissionTargetRepoArgs:
    def __init__(__self__, *,
                 repositories: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 actions: Optional[pulumi.Input['PermissionTargetRepoActionsArgs']] = None,
                 excludes_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 includes_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] repositories: List of repositories this permission target is applicable for. You can specify the name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] excludes_patterns: Pattern of artifacts to exclude.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] includes_patterns: Pattern of artifacts to include.
        """
        pulumi.set(__self__, "repositories", repositories)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if excludes_patterns is not None:
            pulumi.set(__self__, "excludes_patterns", excludes_patterns)
        if includes_patterns is not None:
            pulumi.set(__self__, "includes_patterns", includes_patterns)

    @_builtins.property
    @pulumi.getter
    def repositories(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of repositories this permission target is applicable for. You can specify the name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        """
        return pulumi.get(self, "repositories")

    @repositories.setter
    def repositories(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "repositories", value)

    @_builtins.property
    @pulumi.getter
    def actions(self) -> Optional[pulumi.Input['PermissionTargetRepoActionsArgs']]:
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional[pulumi.Input['PermissionTargetRepoActionsArgs']]):
        pulumi.set(self, "actions", value)

    @_builtins.property
    @pulumi.getter(name="excludesPatterns")
    def excludes_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Pattern of artifacts to exclude.
        """
        return pulumi.get(self, "excludes_patterns")

    @excludes_patterns.setter
    def excludes_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excludes_patterns", value)

    @_builtins.property
    @pulumi.getter(name="includesPatterns")
    def includes_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Pattern of artifacts to include.
        """
        return pulumi.get(self, "includes_patterns")

    @includes_patterns.setter
    def includes_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "includes_patterns", value)


if not MYPY:
    class PermissionTargetRepoActionsArgsDict(TypedDict):
        groups: NotRequired[pulumi.Input[Sequence[pulumi.Input['PermissionTargetRepoActionsGroupArgsDict']]]]
        """
        Groups this permission applies for.
        """
        users: NotRequired[pulumi.Input[Sequence[pulumi.Input['PermissionTargetRepoActionsUserArgsDict']]]]
        """
        Users this permission target applies for.
        """
elif False:
    PermissionTargetRepoActionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PermissionTargetRepoActionsArgs:
    def __init__(__self__, *,
                 groups: Optional[pulumi.Input[Sequence[pulumi.Input['PermissionTargetRepoActionsGroupArgs']]]] = None,
                 users: Optional[pulumi.Input[Sequence[pulumi.Input['PermissionTargetRepoActionsUserArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PermissionTargetRepoActionsGroupArgs']]] groups: Groups this permission applies for.
        :param pulumi.Input[Sequence[pulumi.Input['PermissionTargetRepoActionsUserArgs']]] users: Users this permission target applies for.
        """
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @_builtins.property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PermissionTargetRepoActionsGroupArgs']]]]:
        """
        Groups this permission applies for.
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PermissionTargetRepoActionsGroupArgs']]]]):
        pulumi.set(self, "groups", value)

    @_builtins.property
    @pulumi.getter
    def users(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PermissionTargetRepoActionsUserArgs']]]]:
        """
        Users this permission target applies for.
        """
        return pulumi.get(self, "users")

    @users.setter
    def users(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PermissionTargetRepoActionsUserArgs']]]]):
        pulumi.set(self, "users", value)


if not MYPY:
    class PermissionTargetRepoActionsGroupArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name of permission.
        """
        permissions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    PermissionTargetRepoActionsGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PermissionTargetRepoActionsGroupArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 permissions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[_builtins.str] name: Name of permission.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of permission.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def permissions(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "permissions", value)


if not MYPY:
    class PermissionTargetRepoActionsUserArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name of permission.
        """
        permissions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    PermissionTargetRepoActionsUserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PermissionTargetRepoActionsUserArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 permissions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[_builtins.str] name: Name of permission.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of permission.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def permissions(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "permissions", value)


if not MYPY:
    class PropertySetPropertyArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The name pf the property.
        """
        closed_predefined_values: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Disables `multiple_choice` if set to `false` at the same time with multiple_choice set to `true`. Default value is `false`
        """
        multiple_choice: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Defines if user can select multiple values. `closed_predefined_values` should be set to `true`. Default value is `false`.
        """
        predefined_values: NotRequired[pulumi.Input[Sequence[pulumi.Input['PropertySetPropertyPredefinedValueArgsDict']]]]
        """
        Properties in the property set. Predefined values is mandatory when closed_predefined_values or multiple_choice is set to 'true'
        """
elif False:
    PropertySetPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PropertySetPropertyArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 closed_predefined_values: Optional[pulumi.Input[_builtins.bool]] = None,
                 multiple_choice: Optional[pulumi.Input[_builtins.bool]] = None,
                 predefined_values: Optional[pulumi.Input[Sequence[pulumi.Input['PropertySetPropertyPredefinedValueArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name pf the property.
        :param pulumi.Input[_builtins.bool] closed_predefined_values: Disables `multiple_choice` if set to `false` at the same time with multiple_choice set to `true`. Default value is `false`
        :param pulumi.Input[_builtins.bool] multiple_choice: Defines if user can select multiple values. `closed_predefined_values` should be set to `true`. Default value is `false`.
        :param pulumi.Input[Sequence[pulumi.Input['PropertySetPropertyPredefinedValueArgs']]] predefined_values: Properties in the property set. Predefined values is mandatory when closed_predefined_values or multiple_choice is set to 'true'
        """
        pulumi.set(__self__, "name", name)
        if closed_predefined_values is not None:
            pulumi.set(__self__, "closed_predefined_values", closed_predefined_values)
        if multiple_choice is not None:
            pulumi.set(__self__, "multiple_choice", multiple_choice)
        if predefined_values is not None:
            pulumi.set(__self__, "predefined_values", predefined_values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name pf the property.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="closedPredefinedValues")
    def closed_predefined_values(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Disables `multiple_choice` if set to `false` at the same time with multiple_choice set to `true`. Default value is `false`
        """
        return pulumi.get(self, "closed_predefined_values")

    @closed_predefined_values.setter
    def closed_predefined_values(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "closed_predefined_values", value)

    @_builtins.property
    @pulumi.getter(name="multipleChoice")
    def multiple_choice(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Defines if user can select multiple values. `closed_predefined_values` should be set to `true`. Default value is `false`.
        """
        return pulumi.get(self, "multiple_choice")

    @multiple_choice.setter
    def multiple_choice(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "multiple_choice", value)

    @_builtins.property
    @pulumi.getter(name="predefinedValues")
    def predefined_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PropertySetPropertyPredefinedValueArgs']]]]:
        """
        Properties in the property set. Predefined values is mandatory when closed_predefined_values or multiple_choice is set to 'true'
        """
        return pulumi.get(self, "predefined_values")

    @predefined_values.setter
    def predefined_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PropertySetPropertyPredefinedValueArgs']]]]):
        pulumi.set(self, "predefined_values", value)


if not MYPY:
    class PropertySetPropertyPredefinedValueArgsDict(TypedDict):
        default_value: pulumi.Input[_builtins.bool]
        """
        Whether the value is selected by default in the UI.
        """
        name: pulumi.Input[_builtins.str]
        """
        Property set name.
        """
elif False:
    PropertySetPropertyPredefinedValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PropertySetPropertyPredefinedValueArgs:
    def __init__(__self__, *,
                 default_value: pulumi.Input[_builtins.bool],
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.bool] default_value: Whether the value is selected by default in the UI.
        :param pulumi.Input[_builtins.str] name: Property set name.
        """
        pulumi.set(__self__, "default_value", default_value)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> pulumi.Input[_builtins.bool]:
        """
        Whether the value is selected by default in the UI.
        """
        return pulumi.get(self, "default_value")

    @default_value.setter
    def default_value(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "default_value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Property set name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class PushReplicationReplicationArgsDict(TypedDict):
        password: pulumi.Input[_builtins.str]
        """
        Required for local repository, but not needed for remote repository.
        """
        url: pulumi.Input[_builtins.str]
        """
        The URL of the target local repository on a remote Artifactory server. Required for local repository, but not needed for remote repository.
        """
        username: pulumi.Input[_builtins.str]
        """
        Required for local repository, but not needed for remote repository.
        """
        check_binary_existence_in_filestore: NotRequired[pulumi.Input[_builtins.bool]]
        """
        When true, enables distributed checksum storage. For more information, see
        [Optimizing Repository Replication with Checksum-Based Storage](https://www.jfrog.com/confluence/display/JFROG/Repository+Replication#RepositoryReplication-OptimizingRepositoryReplicationUsingStorageLevelSynchronizationOptions).
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        When set, this replication will be enabled when saved.
        """
        path_prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        Only artifacts that located in path that matches the subpath within the remote repository will be replicated.
        """
        proxy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Proxy key from Artifactory Proxies settings. The proxy configuration will be used when communicating with the remote instance.
        """
        socket_timeout_millis: NotRequired[pulumi.Input[_builtins.int]]
        """
        The network timeout in milliseconds to use for remote operations.
        """
        sync_deletes: NotRequired[pulumi.Input[_builtins.bool]]
        """
        When set, items that were deleted locally should also be deleted remotely (also applies to properties metadata).
        Note that enabling this option, will delete artifacts on the target that do not exist in the source repository.
        """
        sync_properties: NotRequired[pulumi.Input[_builtins.bool]]
        """
        When set, the task also synchronizes the properties of replicated artifacts.
        """
        sync_statistics: NotRequired[pulumi.Input[_builtins.bool]]
        """
        When set, artifact download statistics will also be replicated. Set to avoid inadvertent cleanup at the target instance when setting up replication for disaster recovery.
        """
elif False:
    PushReplicationReplicationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PushReplicationReplicationArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[_builtins.str],
                 url: pulumi.Input[_builtins.str],
                 username: pulumi.Input[_builtins.str],
                 check_binary_existence_in_filestore: Optional[pulumi.Input[_builtins.bool]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 path_prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 proxy: Optional[pulumi.Input[_builtins.str]] = None,
                 socket_timeout_millis: Optional[pulumi.Input[_builtins.int]] = None,
                 sync_deletes: Optional[pulumi.Input[_builtins.bool]] = None,
                 sync_properties: Optional[pulumi.Input[_builtins.bool]] = None,
                 sync_statistics: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] password: Required for local repository, but not needed for remote repository.
        :param pulumi.Input[_builtins.str] url: The URL of the target local repository on a remote Artifactory server. Required for local repository, but not needed for remote repository.
        :param pulumi.Input[_builtins.str] username: Required for local repository, but not needed for remote repository.
        :param pulumi.Input[_builtins.bool] check_binary_existence_in_filestore: When true, enables distributed checksum storage. For more information, see
               [Optimizing Repository Replication with Checksum-Based Storage](https://www.jfrog.com/confluence/display/JFROG/Repository+Replication#RepositoryReplication-OptimizingRepositoryReplicationUsingStorageLevelSynchronizationOptions).
        :param pulumi.Input[_builtins.bool] enabled: When set, this replication will be enabled when saved.
        :param pulumi.Input[_builtins.str] path_prefix: Only artifacts that located in path that matches the subpath within the remote repository will be replicated.
        :param pulumi.Input[_builtins.str] proxy: Proxy key from Artifactory Proxies settings. The proxy configuration will be used when communicating with the remote instance.
        :param pulumi.Input[_builtins.int] socket_timeout_millis: The network timeout in milliseconds to use for remote operations.
        :param pulumi.Input[_builtins.bool] sync_deletes: When set, items that were deleted locally should also be deleted remotely (also applies to properties metadata).
               Note that enabling this option, will delete artifacts on the target that do not exist in the source repository.
        :param pulumi.Input[_builtins.bool] sync_properties: When set, the task also synchronizes the properties of replicated artifacts.
        :param pulumi.Input[_builtins.bool] sync_statistics: When set, artifact download statistics will also be replicated. Set to avoid inadvertent cleanup at the target instance when setting up replication for disaster recovery.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "url", url)
        pulumi.set(__self__, "username", username)
        if check_binary_existence_in_filestore is not None:
            pulumi.set(__self__, "check_binary_existence_in_filestore", check_binary_existence_in_filestore)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if path_prefix is not None:
            pulumi.set(__self__, "path_prefix", path_prefix)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if socket_timeout_millis is not None:
            pulumi.set(__self__, "socket_timeout_millis", socket_timeout_millis)
        if sync_deletes is not None:
            pulumi.set(__self__, "sync_deletes", sync_deletes)
        if sync_properties is not None:
            pulumi.set(__self__, "sync_properties", sync_properties)
        if sync_statistics is not None:
            pulumi.set(__self__, "sync_statistics", sync_statistics)

    @_builtins.property
    @pulumi.getter
    def password(self) -> pulumi.Input[_builtins.str]:
        """
        Required for local repository, but not needed for remote repository.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        The URL of the target local repository on a remote Artifactory server. Required for local repository, but not needed for remote repository.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> pulumi.Input[_builtins.str]:
        """
        Required for local repository, but not needed for remote repository.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "username", value)

    @_builtins.property
    @pulumi.getter(name="checkBinaryExistenceInFilestore")
    def check_binary_existence_in_filestore(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When true, enables distributed checksum storage. For more information, see
        [Optimizing Repository Replication with Checksum-Based Storage](https://www.jfrog.com/confluence/display/JFROG/Repository+Replication#RepositoryReplication-OptimizingRepositoryReplicationUsingStorageLevelSynchronizationOptions).
        """
        return pulumi.get(self, "check_binary_existence_in_filestore")

    @check_binary_existence_in_filestore.setter
    def check_binary_existence_in_filestore(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "check_binary_existence_in_filestore", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When set, this replication will be enabled when saved.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="pathPrefix")
    def path_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Only artifacts that located in path that matches the subpath within the remote repository will be replicated.
        """
        return pulumi.get(self, "path_prefix")

    @path_prefix.setter
    def path_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path_prefix", value)

    @_builtins.property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Proxy key from Artifactory Proxies settings. The proxy configuration will be used when communicating with the remote instance.
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy", value)

    @_builtins.property
    @pulumi.getter(name="socketTimeoutMillis")
    def socket_timeout_millis(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The network timeout in milliseconds to use for remote operations.
        """
        return pulumi.get(self, "socket_timeout_millis")

    @socket_timeout_millis.setter
    def socket_timeout_millis(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "socket_timeout_millis", value)

    @_builtins.property
    @pulumi.getter(name="syncDeletes")
    def sync_deletes(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When set, items that were deleted locally should also be deleted remotely (also applies to properties metadata).
        Note that enabling this option, will delete artifacts on the target that do not exist in the source repository.
        """
        return pulumi.get(self, "sync_deletes")

    @sync_deletes.setter
    def sync_deletes(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "sync_deletes", value)

    @_builtins.property
    @pulumi.getter(name="syncProperties")
    def sync_properties(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When set, the task also synchronizes the properties of replicated artifacts.
        """
        return pulumi.get(self, "sync_properties")

    @sync_properties.setter
    def sync_properties(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "sync_properties", value)

    @_builtins.property
    @pulumi.getter(name="syncStatistics")
    def sync_statistics(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When set, artifact download statistics will also be replicated. Set to avoid inadvertent cleanup at the target instance when setting up replication for disaster recovery.
        """
        return pulumi.get(self, "sync_statistics")

    @sync_statistics.setter
    def sync_statistics(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "sync_statistics", value)


if not MYPY:
    class ReleaseBundleCustomWebhookCriteriaArgsDict(TypedDict):
        any_release_bundle: pulumi.Input[_builtins.bool]
        """
        Trigger on any release bundle.
        """
        exclude_patterns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: "org/apache/**". **Cannot be set if `any_release_bundle` is set to `true`.**
        """
        include_patterns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: "org/apache/**". **Cannot be set if `any_release_bundle` is set to `true`.** Either this or `registered_release_bundle_names` must be set when `any_release_bundle` is `false`.
        """
        registered_release_bundle_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Trigger on this list of release bundle names. Either this or `include_patterns` must be set when `any_release_bundle` is `false`.
        """
elif False:
    ReleaseBundleCustomWebhookCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReleaseBundleCustomWebhookCriteriaArgs:
    def __init__(__self__, *,
                 any_release_bundle: pulumi.Input[_builtins.bool],
                 exclude_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 include_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 registered_release_bundle_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.bool] any_release_bundle: Trigger on any release bundle.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: "org/apache/**". **Cannot be set if `any_release_bundle` is set to `true`.**
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: "org/apache/**". **Cannot be set if `any_release_bundle` is set to `true`.** Either this or `registered_release_bundle_names` must be set when `any_release_bundle` is `false`.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] registered_release_bundle_names: Trigger on this list of release bundle names. Either this or `include_patterns` must be set when `any_release_bundle` is `false`.
        """
        pulumi.set(__self__, "any_release_bundle", any_release_bundle)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)
        if registered_release_bundle_names is not None:
            pulumi.set(__self__, "registered_release_bundle_names", registered_release_bundle_names)

    @_builtins.property
    @pulumi.getter(name="anyReleaseBundle")
    def any_release_bundle(self) -> pulumi.Input[_builtins.bool]:
        """
        Trigger on any release bundle.
        """
        return pulumi.get(self, "any_release_bundle")

    @any_release_bundle.setter
    def any_release_bundle(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "any_release_bundle", value)

    @_builtins.property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: "org/apache/**". **Cannot be set if `any_release_bundle` is set to `true`.**
        """
        return pulumi.get(self, "exclude_patterns")

    @exclude_patterns.setter
    def exclude_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exclude_patterns", value)

    @_builtins.property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: "org/apache/**". **Cannot be set if `any_release_bundle` is set to `true`.** Either this or `registered_release_bundle_names` must be set when `any_release_bundle` is `false`.
        """
        return pulumi.get(self, "include_patterns")

    @include_patterns.setter
    def include_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "include_patterns", value)

    @_builtins.property
    @pulumi.getter(name="registeredReleaseBundleNames")
    def registered_release_bundle_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Trigger on this list of release bundle names. Either this or `include_patterns` must be set when `any_release_bundle` is `false`.
        """
        return pulumi.get(self, "registered_release_bundle_names")

    @registered_release_bundle_names.setter
    def registered_release_bundle_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "registered_release_bundle_names", value)


if not MYPY:
    class ReleaseBundleCustomWebhookHandlerArgsDict(TypedDict):
        url: pulumi.Input[_builtins.str]
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        http_headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        """
        method: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the HTTP method for the URL that the Webhook invokes. Allowed values are: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`.
        """
        payload: NotRequired[pulumi.Input[_builtins.str]]
        """
        This attribute is used to build the request body. Used in custom webhooks
        """
        proxy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        secrets: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
elif False:
    ReleaseBundleCustomWebhookHandlerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReleaseBundleCustomWebhookHandlerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[_builtins.str],
                 http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 method: Optional[pulumi.Input[_builtins.str]] = None,
                 payload: Optional[pulumi.Input[_builtins.str]] = None,
                 proxy: Optional[pulumi.Input[_builtins.str]] = None,
                 secrets: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] http_headers: HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        :param pulumi.Input[_builtins.str] method: Specifies the HTTP method for the URL that the Webhook invokes. Allowed values are: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`.
        :param pulumi.Input[_builtins.str] payload: This attribute is used to build the request body. Used in custom webhooks
        :param pulumi.Input[_builtins.str] proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] secrets: Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
        pulumi.set(__self__, "url", url)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        """
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "http_headers", value)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the HTTP method for the URL that the Webhook invokes. Allowed values are: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        This attribute is used to build the request body. Used in custom webhooks
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "payload", value)

    @_builtins.property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy", value)

    @_builtins.property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "secrets", value)


if not MYPY:
    class ReleaseBundleV2CleanupPolicySearchCriteriaArgsDict(TypedDict):
        exclude_promoted_environments: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        A list of environments to exclude from the cleanup process. To exclude all, set to `**`. Example: `exclude_promoted_environments = ["**"]`
        """
        created_before_in_months: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the time frame for filtering based on item creation date (for example, 24 months). Defaults to `24`.
        """
        include_all_projects: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Set this value to `true` if you want the policy to run on all Artifactory projects. The default value is `false`.
        """
        included_projects: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of projects on which you want this policy to run. To include repositories that are not assigned to any project, enter the project key `default`.

        ~>This setting is relevant only on the global level, for Platform Admins.
        """
        release_bundles: NotRequired[pulumi.Input[Sequence[pulumi.Input['ReleaseBundleV2CleanupPolicySearchCriteriaReleaseBundleArgsDict']]]]
        """
        Specify the release bundles to include in the cleanup policy. The policy will only clean up the release bundles that match the specified criteria.
        """
elif False:
    ReleaseBundleV2CleanupPolicySearchCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReleaseBundleV2CleanupPolicySearchCriteriaArgs:
    def __init__(__self__, *,
                 exclude_promoted_environments: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 created_before_in_months: Optional[pulumi.Input[_builtins.int]] = None,
                 include_all_projects: Optional[pulumi.Input[_builtins.bool]] = None,
                 included_projects: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 release_bundles: Optional[pulumi.Input[Sequence[pulumi.Input['ReleaseBundleV2CleanupPolicySearchCriteriaReleaseBundleArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] exclude_promoted_environments: A list of environments to exclude from the cleanup process. To exclude all, set to `**`. Example: `exclude_promoted_environments = ["**"]`
        :param pulumi.Input[_builtins.int] created_before_in_months: Specifies the time frame for filtering based on item creation date (for example, 24 months). Defaults to `24`.
        :param pulumi.Input[_builtins.bool] include_all_projects: Set this value to `true` if you want the policy to run on all Artifactory projects. The default value is `false`.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] included_projects: List of projects on which you want this policy to run. To include repositories that are not assigned to any project, enter the project key `default`.
               
               ~>This setting is relevant only on the global level, for Platform Admins.
        :param pulumi.Input[Sequence[pulumi.Input['ReleaseBundleV2CleanupPolicySearchCriteriaReleaseBundleArgs']]] release_bundles: Specify the release bundles to include in the cleanup policy. The policy will only clean up the release bundles that match the specified criteria.
        """
        pulumi.set(__self__, "exclude_promoted_environments", exclude_promoted_environments)
        if created_before_in_months is not None:
            pulumi.set(__self__, "created_before_in_months", created_before_in_months)
        if include_all_projects is not None:
            pulumi.set(__self__, "include_all_projects", include_all_projects)
        if included_projects is not None:
            pulumi.set(__self__, "included_projects", included_projects)
        if release_bundles is not None:
            pulumi.set(__self__, "release_bundles", release_bundles)

    @_builtins.property
    @pulumi.getter(name="excludePromotedEnvironments")
    def exclude_promoted_environments(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        A list of environments to exclude from the cleanup process. To exclude all, set to `**`. Example: `exclude_promoted_environments = ["**"]`
        """
        return pulumi.get(self, "exclude_promoted_environments")

    @exclude_promoted_environments.setter
    def exclude_promoted_environments(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "exclude_promoted_environments", value)

    @_builtins.property
    @pulumi.getter(name="createdBeforeInMonths")
    def created_before_in_months(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the time frame for filtering based on item creation date (for example, 24 months). Defaults to `24`.
        """
        return pulumi.get(self, "created_before_in_months")

    @created_before_in_months.setter
    def created_before_in_months(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "created_before_in_months", value)

    @_builtins.property
    @pulumi.getter(name="includeAllProjects")
    def include_all_projects(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Set this value to `true` if you want the policy to run on all Artifactory projects. The default value is `false`.
        """
        return pulumi.get(self, "include_all_projects")

    @include_all_projects.setter
    def include_all_projects(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "include_all_projects", value)

    @_builtins.property
    @pulumi.getter(name="includedProjects")
    def included_projects(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of projects on which you want this policy to run. To include repositories that are not assigned to any project, enter the project key `default`.

        ~>This setting is relevant only on the global level, for Platform Admins.
        """
        return pulumi.get(self, "included_projects")

    @included_projects.setter
    def included_projects(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_projects", value)

    @_builtins.property
    @pulumi.getter(name="releaseBundles")
    def release_bundles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ReleaseBundleV2CleanupPolicySearchCriteriaReleaseBundleArgs']]]]:
        """
        Specify the release bundles to include in the cleanup policy. The policy will only clean up the release bundles that match the specified criteria.
        """
        return pulumi.get(self, "release_bundles")

    @release_bundles.setter
    def release_bundles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ReleaseBundleV2CleanupPolicySearchCriteriaReleaseBundleArgs']]]]):
        pulumi.set(self, "release_bundles", value)


if not MYPY:
    class ReleaseBundleV2CleanupPolicySearchCriteriaReleaseBundleArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The name of the release bundle. Set `**` to include all bundles. Example: `name = "**"`
        """
        project_key: pulumi.Input[_builtins.str]
        """
        The project identifier associated with the release bundle. This key is obtained from the Project Settings screen. Leave the field blank to apply at a global level.
        """
elif False:
    ReleaseBundleV2CleanupPolicySearchCriteriaReleaseBundleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReleaseBundleV2CleanupPolicySearchCriteriaReleaseBundleArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 project_key: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: The name of the release bundle. Set `**` to include all bundles. Example: `name = "**"`
        :param pulumi.Input[_builtins.str] project_key: The project identifier associated with the release bundle. This key is obtained from the Project Settings screen. Leave the field blank to apply at a global level.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project_key", project_key)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the release bundle. Set `**` to include all bundles. Example: `name = "**"`
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="projectKey")
    def project_key(self) -> pulumi.Input[_builtins.str]:
        """
        The project identifier associated with the release bundle. This key is obtained from the Project Settings screen. Leave the field blank to apply at a global level.
        """
        return pulumi.get(self, "project_key")

    @project_key.setter
    def project_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "project_key", value)


if not MYPY:
    class ReleaseBundleV2CustomWebhookCriteriaArgsDict(TypedDict):
        any_release_bundle: pulumi.Input[_builtins.bool]
        """
        Trigger on any release bundle.
        """
        exclude_patterns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Simple wildcard patterns for Release Bundle names.
        Ant-style path expressions are supported (*, **, ?).
        For example: `product_*`
        """
        include_patterns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Simple wildcard patterns for Release Bundle names.
        Ant-style path expressions are supported (*, **, ?).
        For example: `product_*`
        """
        selected_release_bundles: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Trigger on this list of release bundle names.
        """
elif False:
    ReleaseBundleV2CustomWebhookCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReleaseBundleV2CustomWebhookCriteriaArgs:
    def __init__(__self__, *,
                 any_release_bundle: pulumi.Input[_builtins.bool],
                 exclude_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 include_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 selected_release_bundles: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.bool] any_release_bundle: Trigger on any release bundle.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] exclude_patterns: Simple wildcard patterns for Release Bundle names.
               Ant-style path expressions are supported (*, **, ?).
               For example: `product_*`
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] include_patterns: Simple wildcard patterns for Release Bundle names.
               Ant-style path expressions are supported (*, **, ?).
               For example: `product_*`
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] selected_release_bundles: Trigger on this list of release bundle names.
        """
        pulumi.set(__self__, "any_release_bundle", any_release_bundle)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)
        if selected_release_bundles is not None:
            pulumi.set(__self__, "selected_release_bundles", selected_release_bundles)

    @_builtins.property
    @pulumi.getter(name="anyReleaseBundle")
    def any_release_bundle(self) -> pulumi.Input[_builtins.bool]:
        """
        Trigger on any release bundle.
        """
        return pulumi.get(self, "any_release_bundle")

    @any_release_bundle.setter
    def any_release_bundle(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "any_release_bundle", value)

    @_builtins.property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Simple wildcard patterns for Release Bundle names.
        Ant-style path expressions are supported (*, **, ?).
        For example: `product_*`
        """
        return pulumi.get(self, "exclude_patterns")

    @exclude_patterns.setter
    def exclude_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exclude_patterns", value)

    @_builtins.property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Simple wildcard patterns for Release Bundle names.
        Ant-style path expressions are supported (*, **, ?).
        For example: `product_*`
        """
        return pulumi.get(self, "include_patterns")

    @include_patterns.setter
    def include_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "include_patterns", value)

    @_builtins.property
    @pulumi.getter(name="selectedReleaseBundles")
    def selected_release_bundles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Trigger on this list of release bundle names.
        """
        return pulumi.get(self, "selected_release_bundles")

    @selected_release_bundles.setter
    def selected_release_bundles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "selected_release_bundles", value)


if not MYPY:
    class ReleaseBundleV2CustomWebhookHandlerArgsDict(TypedDict):
        url: pulumi.Input[_builtins.str]
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        http_headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        """
        method: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the HTTP method for the URL that the Webhook invokes. Allowed values are: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`.
        """
        payload: NotRequired[pulumi.Input[_builtins.str]]
        """
        This attribute is used to build the request body. Used in custom webhooks
        """
        proxy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        secrets: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
elif False:
    ReleaseBundleV2CustomWebhookHandlerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReleaseBundleV2CustomWebhookHandlerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[_builtins.str],
                 http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 method: Optional[pulumi.Input[_builtins.str]] = None,
                 payload: Optional[pulumi.Input[_builtins.str]] = None,
                 proxy: Optional[pulumi.Input[_builtins.str]] = None,
                 secrets: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] http_headers: HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        :param pulumi.Input[_builtins.str] method: Specifies the HTTP method for the URL that the Webhook invokes. Allowed values are: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`.
        :param pulumi.Input[_builtins.str] payload: This attribute is used to build the request body. Used in custom webhooks
        :param pulumi.Input[_builtins.str] proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] secrets: Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
        pulumi.set(__self__, "url", url)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        """
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "http_headers", value)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the HTTP method for the URL that the Webhook invokes. Allowed values are: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        This attribute is used to build the request body. Used in custom webhooks
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "payload", value)

    @_builtins.property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy", value)

    @_builtins.property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "secrets", value)


if not MYPY:
    class ReleaseBundleV2PromotionCustomWebhookCriteriaArgsDict(TypedDict):
        selected_environments: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Trigger on this list of environment names.
        """
        exclude_patterns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        include_patterns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    ReleaseBundleV2PromotionCustomWebhookCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReleaseBundleV2PromotionCustomWebhookCriteriaArgs:
    def __init__(__self__, *,
                 selected_environments: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 exclude_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 include_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] selected_environments: Trigger on this list of environment names.
        """
        pulumi.set(__self__, "selected_environments", selected_environments)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @_builtins.property
    @pulumi.getter(name="selectedEnvironments")
    def selected_environments(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Trigger on this list of environment names.
        """
        return pulumi.get(self, "selected_environments")

    @selected_environments.setter
    def selected_environments(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "selected_environments", value)

    @_builtins.property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "exclude_patterns")

    @exclude_patterns.setter
    def exclude_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exclude_patterns", value)

    @_builtins.property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "include_patterns")

    @include_patterns.setter
    def include_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "include_patterns", value)


if not MYPY:
    class ReleaseBundleV2PromotionCustomWebhookHandlerArgsDict(TypedDict):
        url: pulumi.Input[_builtins.str]
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        http_headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        """
        method: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the HTTP method for the URL that the Webhook invokes. Allowed values are: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`.
        """
        payload: NotRequired[pulumi.Input[_builtins.str]]
        """
        This attribute is used to build the request body. Used in custom webhooks
        """
        proxy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        secrets: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
elif False:
    ReleaseBundleV2PromotionCustomWebhookHandlerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReleaseBundleV2PromotionCustomWebhookHandlerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[_builtins.str],
                 http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 method: Optional[pulumi.Input[_builtins.str]] = None,
                 payload: Optional[pulumi.Input[_builtins.str]] = None,
                 proxy: Optional[pulumi.Input[_builtins.str]] = None,
                 secrets: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] http_headers: HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        :param pulumi.Input[_builtins.str] method: Specifies the HTTP method for the URL that the Webhook invokes. Allowed values are: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`.
        :param pulumi.Input[_builtins.str] payload: This attribute is used to build the request body. Used in custom webhooks
        :param pulumi.Input[_builtins.str] proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] secrets: Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
        pulumi.set(__self__, "url", url)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        """
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "http_headers", value)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the HTTP method for the URL that the Webhook invokes. Allowed values are: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        This attribute is used to build the request body. Used in custom webhooks
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "payload", value)

    @_builtins.property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy", value)

    @_builtins.property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "secrets", value)


if not MYPY:
    class ReleaseBundleV2PromotionWebhookCriteriaArgsDict(TypedDict):
        selected_environments: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Trigger on this list of environment names.
        """
        exclude_patterns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        include_patterns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    ReleaseBundleV2PromotionWebhookCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReleaseBundleV2PromotionWebhookCriteriaArgs:
    def __init__(__self__, *,
                 selected_environments: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 exclude_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 include_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] selected_environments: Trigger on this list of environment names.
        """
        pulumi.set(__self__, "selected_environments", selected_environments)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)

    @_builtins.property
    @pulumi.getter(name="selectedEnvironments")
    def selected_environments(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Trigger on this list of environment names.
        """
        return pulumi.get(self, "selected_environments")

    @selected_environments.setter
    def selected_environments(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "selected_environments", value)

    @_builtins.property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "exclude_patterns")

    @exclude_patterns.setter
    def exclude_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exclude_patterns", value)

    @_builtins.property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "include_patterns")

    @include_patterns.setter
    def include_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "include_patterns", value)


if not MYPY:
    class ReleaseBundleV2PromotionWebhookHandlerArgsDict(TypedDict):
        url: pulumi.Input[_builtins.str]
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        custom_http_headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        proxy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        use_secret_for_signing: NotRequired[pulumi.Input[_builtins.bool]]
        """
        When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
elif False:
    ReleaseBundleV2PromotionWebhookHandlerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReleaseBundleV2PromotionWebhookHandlerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[_builtins.str],
                 custom_http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 proxy: Optional[pulumi.Input[_builtins.str]] = None,
                 secret: Optional[pulumi.Input[_builtins.str]] = None,
                 use_secret_for_signing: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] custom_http_headers: Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        :param pulumi.Input[_builtins.str] proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param pulumi.Input[_builtins.str] secret: Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        :param pulumi.Input[_builtins.bool] use_secret_for_signing: When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        pulumi.set(__self__, "url", url)
        if custom_http_headers is not None:
            pulumi.set(__self__, "custom_http_headers", custom_http_headers)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if use_secret_for_signing is not None:
            pulumi.set(__self__, "use_secret_for_signing", use_secret_for_signing)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="customHttpHeaders")
    def custom_http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        return pulumi.get(self, "custom_http_headers")

    @custom_http_headers.setter
    def custom_http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "custom_http_headers", value)

    @_builtins.property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret", value)

    @_builtins.property
    @pulumi.getter(name="useSecretForSigning")
    def use_secret_for_signing(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        return pulumi.get(self, "use_secret_for_signing")

    @use_secret_for_signing.setter
    def use_secret_for_signing(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_secret_for_signing", value)


if not MYPY:
    class ReleaseBundleV2SourceArgsDict(TypedDict):
        aql: NotRequired[pulumi.Input[_builtins.str]]
        """
        The contents of the AQL query.
        """
        artifacts: NotRequired[pulumi.Input[Sequence[pulumi.Input['ReleaseBundleV2SourceArtifactArgsDict']]]]
        """
        Source type to create a Release Bundle v2 version by collecting source artifacts from a list of path/checksum pairs.
        """
        builds: NotRequired[pulumi.Input[Sequence[pulumi.Input['ReleaseBundleV2SourceBuildArgsDict']]]]
        """
        Source type to create a Release Bundle v2 version by collecting source artifacts from one or multiple builds (also known as build-info).
        """
        release_bundles: NotRequired[pulumi.Input[Sequence[pulumi.Input['ReleaseBundleV2SourceReleaseBundleArgsDict']]]]
        """
        Source type to create a Release Bundle v2 version by collecting source artifacts from existing Release Bundle versions. Must match `source_type` attribute value.
        """
elif False:
    ReleaseBundleV2SourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReleaseBundleV2SourceArgs:
    def __init__(__self__, *,
                 aql: Optional[pulumi.Input[_builtins.str]] = None,
                 artifacts: Optional[pulumi.Input[Sequence[pulumi.Input['ReleaseBundleV2SourceArtifactArgs']]]] = None,
                 builds: Optional[pulumi.Input[Sequence[pulumi.Input['ReleaseBundleV2SourceBuildArgs']]]] = None,
                 release_bundles: Optional[pulumi.Input[Sequence[pulumi.Input['ReleaseBundleV2SourceReleaseBundleArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] aql: The contents of the AQL query.
        :param pulumi.Input[Sequence[pulumi.Input['ReleaseBundleV2SourceArtifactArgs']]] artifacts: Source type to create a Release Bundle v2 version by collecting source artifacts from a list of path/checksum pairs.
        :param pulumi.Input[Sequence[pulumi.Input['ReleaseBundleV2SourceBuildArgs']]] builds: Source type to create a Release Bundle v2 version by collecting source artifacts from one or multiple builds (also known as build-info).
        :param pulumi.Input[Sequence[pulumi.Input['ReleaseBundleV2SourceReleaseBundleArgs']]] release_bundles: Source type to create a Release Bundle v2 version by collecting source artifacts from existing Release Bundle versions. Must match `source_type` attribute value.
        """
        if aql is not None:
            pulumi.set(__self__, "aql", aql)
        if artifacts is not None:
            pulumi.set(__self__, "artifacts", artifacts)
        if builds is not None:
            pulumi.set(__self__, "builds", builds)
        if release_bundles is not None:
            pulumi.set(__self__, "release_bundles", release_bundles)

    @_builtins.property
    @pulumi.getter
    def aql(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The contents of the AQL query.
        """
        return pulumi.get(self, "aql")

    @aql.setter
    def aql(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "aql", value)

    @_builtins.property
    @pulumi.getter
    def artifacts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ReleaseBundleV2SourceArtifactArgs']]]]:
        """
        Source type to create a Release Bundle v2 version by collecting source artifacts from a list of path/checksum pairs.
        """
        return pulumi.get(self, "artifacts")

    @artifacts.setter
    def artifacts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ReleaseBundleV2SourceArtifactArgs']]]]):
        pulumi.set(self, "artifacts", value)

    @_builtins.property
    @pulumi.getter
    def builds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ReleaseBundleV2SourceBuildArgs']]]]:
        """
        Source type to create a Release Bundle v2 version by collecting source artifacts from one or multiple builds (also known as build-info).
        """
        return pulumi.get(self, "builds")

    @builds.setter
    def builds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ReleaseBundleV2SourceBuildArgs']]]]):
        pulumi.set(self, "builds", value)

    @_builtins.property
    @pulumi.getter(name="releaseBundles")
    def release_bundles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ReleaseBundleV2SourceReleaseBundleArgs']]]]:
        """
        Source type to create a Release Bundle v2 version by collecting source artifacts from existing Release Bundle versions. Must match `source_type` attribute value.
        """
        return pulumi.get(self, "release_bundles")

    @release_bundles.setter
    def release_bundles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ReleaseBundleV2SourceReleaseBundleArgs']]]]):
        pulumi.set(self, "release_bundles", value)


if not MYPY:
    class ReleaseBundleV2SourceArtifactArgsDict(TypedDict):
        path: pulumi.Input[_builtins.str]
        """
        The path for the artifact
        """
        sha256: NotRequired[pulumi.Input[_builtins.str]]
        """
        The SHA256 for the artifact
        """
elif False:
    ReleaseBundleV2SourceArtifactArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReleaseBundleV2SourceArtifactArgs:
    def __init__(__self__, *,
                 path: pulumi.Input[_builtins.str],
                 sha256: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] path: The path for the artifact
        :param pulumi.Input[_builtins.str] sha256: The SHA256 for the artifact
        """
        pulumi.set(__self__, "path", path)
        if sha256 is not None:
            pulumi.set(__self__, "sha256", sha256)

    @_builtins.property
    @pulumi.getter
    def path(self) -> pulumi.Input[_builtins.str]:
        """
        The path for the artifact
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def sha256(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The SHA256 for the artifact
        """
        return pulumi.get(self, "sha256")

    @sha256.setter
    def sha256(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sha256", value)


if not MYPY:
    class ReleaseBundleV2SourceBuildArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name of the build.
        """
        number: pulumi.Input[_builtins.str]
        """
        Number (run) of the build.
        """
        include_dependencies: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Determines whether to include build dependencies in the Release Bundle. The default value is `false`.
        """
        repository: NotRequired[pulumi.Input[_builtins.str]]
        """
        The repository key of the build. If omitted, the system uses the default built-in repository, `artifactory-build-info`.
        """
        started: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timestamp when the build was created. If omitted, the system uses the latest build run, as identified by the `name` and `number` combination. The timestamp is provided according to the ISO 8601 standard.
        """
elif False:
    ReleaseBundleV2SourceBuildArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReleaseBundleV2SourceBuildArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 number: pulumi.Input[_builtins.str],
                 include_dependencies: Optional[pulumi.Input[_builtins.bool]] = None,
                 repository: Optional[pulumi.Input[_builtins.str]] = None,
                 started: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name of the build.
        :param pulumi.Input[_builtins.str] number: Number (run) of the build.
        :param pulumi.Input[_builtins.bool] include_dependencies: Determines whether to include build dependencies in the Release Bundle. The default value is `false`.
        :param pulumi.Input[_builtins.str] repository: The repository key of the build. If omitted, the system uses the default built-in repository, `artifactory-build-info`.
        :param pulumi.Input[_builtins.str] started: Timestamp when the build was created. If omitted, the system uses the latest build run, as identified by the `name` and `number` combination. The timestamp is provided according to the ISO 8601 standard.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "number", number)
        if include_dependencies is not None:
            pulumi.set(__self__, "include_dependencies", include_dependencies)
        if repository is not None:
            pulumi.set(__self__, "repository", repository)
        if started is not None:
            pulumi.set(__self__, "started", started)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the build.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def number(self) -> pulumi.Input[_builtins.str]:
        """
        Number (run) of the build.
        """
        return pulumi.get(self, "number")

    @number.setter
    def number(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "number", value)

    @_builtins.property
    @pulumi.getter(name="includeDependencies")
    def include_dependencies(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Determines whether to include build dependencies in the Release Bundle. The default value is `false`.
        """
        return pulumi.get(self, "include_dependencies")

    @include_dependencies.setter
    def include_dependencies(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "include_dependencies", value)

    @_builtins.property
    @pulumi.getter
    def repository(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The repository key of the build. If omitted, the system uses the default built-in repository, `artifactory-build-info`.
        """
        return pulumi.get(self, "repository")

    @repository.setter
    def repository(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "repository", value)

    @_builtins.property
    @pulumi.getter
    def started(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timestamp when the build was created. If omitted, the system uses the latest build run, as identified by the `name` and `number` combination. The timestamp is provided according to the ISO 8601 standard.
        """
        return pulumi.get(self, "started")

    @started.setter
    def started(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "started", value)


if not MYPY:
    class ReleaseBundleV2SourceReleaseBundleArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The name of the release bundle.
        """
        version: pulumi.Input[_builtins.str]
        """
        The version of the release bundle.
        """
        project_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Project key of the release bundle.
        """
        repository_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The key of the release bundle repository.
        """
elif False:
    ReleaseBundleV2SourceReleaseBundleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReleaseBundleV2SourceReleaseBundleArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 version: pulumi.Input[_builtins.str],
                 project_key: Optional[pulumi.Input[_builtins.str]] = None,
                 repository_key: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the release bundle.
        :param pulumi.Input[_builtins.str] version: The version of the release bundle.
        :param pulumi.Input[_builtins.str] project_key: Project key of the release bundle.
        :param pulumi.Input[_builtins.str] repository_key: The key of the release bundle repository.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "version", version)
        if project_key is not None:
            pulumi.set(__self__, "project_key", project_key)
        if repository_key is not None:
            pulumi.set(__self__, "repository_key", repository_key)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the release bundle.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> pulumi.Input[_builtins.str]:
        """
        The version of the release bundle.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "version", value)

    @_builtins.property
    @pulumi.getter(name="projectKey")
    def project_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Project key of the release bundle.
        """
        return pulumi.get(self, "project_key")

    @project_key.setter
    def project_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "project_key", value)

    @_builtins.property
    @pulumi.getter(name="repositoryKey")
    def repository_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The key of the release bundle repository.
        """
        return pulumi.get(self, "repository_key")

    @repository_key.setter
    def repository_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "repository_key", value)


if not MYPY:
    class ReleaseBundleV2WebhookCriteriaArgsDict(TypedDict):
        any_release_bundle: pulumi.Input[_builtins.bool]
        """
        Trigger on any release bundle.
        """
        exclude_patterns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Simple wildcard patterns for Release Bundle names.
        Ant-style path expressions are supported (*, **, ?).
        For example: `product_*`
        """
        include_patterns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Simple wildcard patterns for Release Bundle names.
        Ant-style path expressions are supported (*, **, ?).
        For example: `product_*`
        """
        selected_release_bundles: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Trigger on this list of release bundle names.
        """
elif False:
    ReleaseBundleV2WebhookCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReleaseBundleV2WebhookCriteriaArgs:
    def __init__(__self__, *,
                 any_release_bundle: pulumi.Input[_builtins.bool],
                 exclude_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 include_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 selected_release_bundles: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.bool] any_release_bundle: Trigger on any release bundle.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] exclude_patterns: Simple wildcard patterns for Release Bundle names.
               Ant-style path expressions are supported (*, **, ?).
               For example: `product_*`
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] include_patterns: Simple wildcard patterns for Release Bundle names.
               Ant-style path expressions are supported (*, **, ?).
               For example: `product_*`
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] selected_release_bundles: Trigger on this list of release bundle names.
        """
        pulumi.set(__self__, "any_release_bundle", any_release_bundle)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)
        if selected_release_bundles is not None:
            pulumi.set(__self__, "selected_release_bundles", selected_release_bundles)

    @_builtins.property
    @pulumi.getter(name="anyReleaseBundle")
    def any_release_bundle(self) -> pulumi.Input[_builtins.bool]:
        """
        Trigger on any release bundle.
        """
        return pulumi.get(self, "any_release_bundle")

    @any_release_bundle.setter
    def any_release_bundle(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "any_release_bundle", value)

    @_builtins.property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Simple wildcard patterns for Release Bundle names.
        Ant-style path expressions are supported (*, **, ?).
        For example: `product_*`
        """
        return pulumi.get(self, "exclude_patterns")

    @exclude_patterns.setter
    def exclude_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exclude_patterns", value)

    @_builtins.property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Simple wildcard patterns for Release Bundle names.
        Ant-style path expressions are supported (*, **, ?).
        For example: `product_*`
        """
        return pulumi.get(self, "include_patterns")

    @include_patterns.setter
    def include_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "include_patterns", value)

    @_builtins.property
    @pulumi.getter(name="selectedReleaseBundles")
    def selected_release_bundles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Trigger on this list of release bundle names.
        """
        return pulumi.get(self, "selected_release_bundles")

    @selected_release_bundles.setter
    def selected_release_bundles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "selected_release_bundles", value)


if not MYPY:
    class ReleaseBundleV2WebhookHandlerArgsDict(TypedDict):
        url: pulumi.Input[_builtins.str]
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        custom_http_headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        proxy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        use_secret_for_signing: NotRequired[pulumi.Input[_builtins.bool]]
        """
        When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
elif False:
    ReleaseBundleV2WebhookHandlerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReleaseBundleV2WebhookHandlerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[_builtins.str],
                 custom_http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 proxy: Optional[pulumi.Input[_builtins.str]] = None,
                 secret: Optional[pulumi.Input[_builtins.str]] = None,
                 use_secret_for_signing: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] custom_http_headers: Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        :param pulumi.Input[_builtins.str] proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param pulumi.Input[_builtins.str] secret: Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        :param pulumi.Input[_builtins.bool] use_secret_for_signing: When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        pulumi.set(__self__, "url", url)
        if custom_http_headers is not None:
            pulumi.set(__self__, "custom_http_headers", custom_http_headers)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if use_secret_for_signing is not None:
            pulumi.set(__self__, "use_secret_for_signing", use_secret_for_signing)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="customHttpHeaders")
    def custom_http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        return pulumi.get(self, "custom_http_headers")

    @custom_http_headers.setter
    def custom_http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "custom_http_headers", value)

    @_builtins.property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret", value)

    @_builtins.property
    @pulumi.getter(name="useSecretForSigning")
    def use_secret_for_signing(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        return pulumi.get(self, "use_secret_for_signing")

    @use_secret_for_signing.setter
    def use_secret_for_signing(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_secret_for_signing", value)


if not MYPY:
    class ReleaseBundleWebhookCriteriaArgsDict(TypedDict):
        any_release_bundle: pulumi.Input[_builtins.bool]
        """
        Trigger on any release bundle.
        """
        exclude_patterns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: "org/apache/**".
        """
        include_patterns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: "org/apache/**".
        """
        registered_release_bundle_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Trigger on this list of release bundle names.
        """
elif False:
    ReleaseBundleWebhookCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReleaseBundleWebhookCriteriaArgs:
    def __init__(__self__, *,
                 any_release_bundle: pulumi.Input[_builtins.bool],
                 exclude_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 include_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 registered_release_bundle_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.bool] any_release_bundle: Trigger on any release bundle.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] exclude_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: "org/apache/**".
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] include_patterns: Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: "org/apache/**".
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] registered_release_bundle_names: Trigger on this list of release bundle names.
        """
        pulumi.set(__self__, "any_release_bundle", any_release_bundle)
        if exclude_patterns is not None:
            pulumi.set(__self__, "exclude_patterns", exclude_patterns)
        if include_patterns is not None:
            pulumi.set(__self__, "include_patterns", include_patterns)
        if registered_release_bundle_names is not None:
            pulumi.set(__self__, "registered_release_bundle_names", registered_release_bundle_names)

    @_builtins.property
    @pulumi.getter(name="anyReleaseBundle")
    def any_release_bundle(self) -> pulumi.Input[_builtins.bool]:
        """
        Trigger on any release bundle.
        """
        return pulumi.get(self, "any_release_bundle")

    @any_release_bundle.setter
    def any_release_bundle(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "any_release_bundle", value)

    @_builtins.property
    @pulumi.getter(name="excludePatterns")
    def exclude_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: "org/apache/**".
        """
        return pulumi.get(self, "exclude_patterns")

    @exclude_patterns.setter
    def exclude_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exclude_patterns", value)

    @_builtins.property
    @pulumi.getter(name="includePatterns")
    def include_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, *\\*, ?). For example: "org/apache/**".
        """
        return pulumi.get(self, "include_patterns")

    @include_patterns.setter
    def include_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "include_patterns", value)

    @_builtins.property
    @pulumi.getter(name="registeredReleaseBundleNames")
    def registered_release_bundle_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Trigger on this list of release bundle names.
        """
        return pulumi.get(self, "registered_release_bundle_names")

    @registered_release_bundle_names.setter
    def registered_release_bundle_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "registered_release_bundle_names", value)


if not MYPY:
    class ReleaseBundleWebhookHandlerArgsDict(TypedDict):
        url: pulumi.Input[_builtins.str]
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        custom_http_headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        proxy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        use_secret_for_signing: NotRequired[pulumi.Input[_builtins.bool]]
        """
        When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
elif False:
    ReleaseBundleWebhookHandlerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReleaseBundleWebhookHandlerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[_builtins.str],
                 custom_http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 proxy: Optional[pulumi.Input[_builtins.str]] = None,
                 secret: Optional[pulumi.Input[_builtins.str]] = None,
                 use_secret_for_signing: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] custom_http_headers: Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        :param pulumi.Input[_builtins.str] proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param pulumi.Input[_builtins.str] secret: Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        :param pulumi.Input[_builtins.bool] use_secret_for_signing: When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        pulumi.set(__self__, "url", url)
        if custom_http_headers is not None:
            pulumi.set(__self__, "custom_http_headers", custom_http_headers)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if use_secret_for_signing is not None:
            pulumi.set(__self__, "use_secret_for_signing", use_secret_for_signing)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="customHttpHeaders")
    def custom_http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        return pulumi.get(self, "custom_http_headers")

    @custom_http_headers.setter
    def custom_http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "custom_http_headers", value)

    @_builtins.property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret", value)

    @_builtins.property
    @pulumi.getter(name="useSecretForSigning")
    def use_secret_for_signing(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        return pulumi.get(self, "use_secret_for_signing")

    @use_secret_for_signing.setter
    def use_secret_for_signing(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_secret_for_signing", value)


if not MYPY:
    class RemoteAlpineRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    RemoteAlpineRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RemoteAlpineRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 properties_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[_builtins.bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[_builtins.bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class RemoteAnsibleRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    RemoteAnsibleRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RemoteAnsibleRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 properties_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[_builtins.bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[_builtins.bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class RemoteBowerRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    RemoteBowerRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RemoteBowerRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 properties_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[_builtins.bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[_builtins.bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class RemoteCargoRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    RemoteCargoRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RemoteCargoRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 properties_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[_builtins.bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[_builtins.bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class RemoteChefRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    RemoteChefRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RemoteChefRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 properties_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[_builtins.bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[_builtins.bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class RemoteCocoapodsRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    RemoteCocoapodsRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RemoteCocoapodsRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 properties_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[_builtins.bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[_builtins.bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class RemoteComposerRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    RemoteComposerRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RemoteComposerRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 properties_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[_builtins.bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[_builtins.bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class RemoteConanRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    RemoteConanRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RemoteConanRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 properties_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[_builtins.bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[_builtins.bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class RemoteCondaRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    RemoteCondaRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RemoteCondaRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 properties_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[_builtins.bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[_builtins.bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class RemoteCranRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    RemoteCranRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RemoteCranRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 properties_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[_builtins.bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[_builtins.bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class RemoteDebianRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    RemoteDebianRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RemoteDebianRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 properties_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[_builtins.bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[_builtins.bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class RemoteDockerRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    RemoteDockerRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RemoteDockerRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 properties_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[_builtins.bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[_builtins.bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class RemoteGemsRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    RemoteGemsRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RemoteGemsRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 properties_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[_builtins.bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[_builtins.bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class RemoteGenericRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    RemoteGenericRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RemoteGenericRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 properties_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[_builtins.bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[_builtins.bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class RemoteGitlfsRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    RemoteGitlfsRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RemoteGitlfsRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 properties_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[_builtins.bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[_builtins.bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class RemoteGoRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    RemoteGoRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RemoteGoRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 properties_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[_builtins.bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[_builtins.bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class RemoteGradleRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    RemoteGradleRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RemoteGradleRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 properties_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[_builtins.bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[_builtins.bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class RemoteHelmRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    RemoteHelmRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RemoteHelmRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 properties_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[_builtins.bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[_builtins.bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class RemoteHelmociRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    RemoteHelmociRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RemoteHelmociRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 properties_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[_builtins.bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[_builtins.bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class RemoteHexRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    RemoteHexRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RemoteHexRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 properties_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[_builtins.bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[_builtins.bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class RemoteHuggingfacemlRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    RemoteHuggingfacemlRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RemoteHuggingfacemlRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 properties_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[_builtins.bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[_builtins.bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class RemoteIvyRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    RemoteIvyRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RemoteIvyRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 properties_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[_builtins.bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[_builtins.bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class RemoteMavenRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    RemoteMavenRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RemoteMavenRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 properties_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[_builtins.bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[_builtins.bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class RemoteNpmRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    RemoteNpmRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RemoteNpmRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 properties_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[_builtins.bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[_builtins.bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class RemoteNugetRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    RemoteNugetRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RemoteNugetRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 properties_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[_builtins.bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[_builtins.bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class RemoteOciRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    RemoteOciRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RemoteOciRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 properties_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[_builtins.bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[_builtins.bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class RemoteOpkgRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    RemoteOpkgRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RemoteOpkgRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 properties_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[_builtins.bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[_builtins.bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class RemoteP2RepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    RemoteP2RepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RemoteP2RepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 properties_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[_builtins.bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[_builtins.bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class RemotePubRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    RemotePubRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RemotePubRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 properties_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[_builtins.bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[_builtins.bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class RemotePuppetRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    RemotePuppetRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RemotePuppetRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 properties_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[_builtins.bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[_builtins.bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class RemotePypiRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    RemotePypiRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RemotePypiRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 properties_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[_builtins.bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[_builtins.bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class RemoteRpmRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    RemoteRpmRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RemoteRpmRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 properties_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[_builtins.bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[_builtins.bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class RemoteSbtRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    RemoteSbtRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RemoteSbtRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 properties_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[_builtins.bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[_builtins.bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class RemoteSwiftRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    RemoteSwiftRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RemoteSwiftRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 properties_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[_builtins.bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[_builtins.bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class RemoteTerraformRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    RemoteTerraformRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RemoteTerraformRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 properties_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[_builtins.bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[_builtins.bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class RemoteVcsRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    RemoteVcsRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RemoteVcsRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 properties_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 source_origin_absence_detection: Optional[pulumi.Input[_builtins.bool]] = None,
                 statistics_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param pulumi.Input[_builtins.bool] source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param pulumi.Input[_builtins.bool] statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class UnmanagedUserPasswordPolicyArgsDict(TypedDict):
        digit: NotRequired[pulumi.Input[_builtins.int]]
        """
        Minimum number of digits that the password must contain
        """
        length: NotRequired[pulumi.Input[_builtins.int]]
        """
        Minimum length of the password
        """
        lowercase: NotRequired[pulumi.Input[_builtins.int]]
        """
        Minimum number of lowercase letters that the password must contain
        """
        special_char: NotRequired[pulumi.Input[_builtins.int]]
        """
        Minimum number of special char that the password must contain. Special chars list: ``!"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~``
        """
        uppercase: NotRequired[pulumi.Input[_builtins.int]]
        """
        Minimum number of uppercase letters that the password must contain
        """
elif False:
    UnmanagedUserPasswordPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UnmanagedUserPasswordPolicyArgs:
    def __init__(__self__, *,
                 digit: Optional[pulumi.Input[_builtins.int]] = None,
                 length: Optional[pulumi.Input[_builtins.int]] = None,
                 lowercase: Optional[pulumi.Input[_builtins.int]] = None,
                 special_char: Optional[pulumi.Input[_builtins.int]] = None,
                 uppercase: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] digit: Minimum number of digits that the password must contain
        :param pulumi.Input[_builtins.int] length: Minimum length of the password
        :param pulumi.Input[_builtins.int] lowercase: Minimum number of lowercase letters that the password must contain
        :param pulumi.Input[_builtins.int] special_char: Minimum number of special char that the password must contain. Special chars list: ``!"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~``
        :param pulumi.Input[_builtins.int] uppercase: Minimum number of uppercase letters that the password must contain
        """
        if digit is not None:
            pulumi.set(__self__, "digit", digit)
        if length is not None:
            pulumi.set(__self__, "length", length)
        if lowercase is not None:
            pulumi.set(__self__, "lowercase", lowercase)
        if special_char is not None:
            pulumi.set(__self__, "special_char", special_char)
        if uppercase is not None:
            pulumi.set(__self__, "uppercase", uppercase)

    @_builtins.property
    @pulumi.getter
    def digit(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Minimum number of digits that the password must contain
        """
        return pulumi.get(self, "digit")

    @digit.setter
    def digit(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "digit", value)

    @_builtins.property
    @pulumi.getter
    def length(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Minimum length of the password
        """
        return pulumi.get(self, "length")

    @length.setter
    def length(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "length", value)

    @_builtins.property
    @pulumi.getter
    def lowercase(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Minimum number of lowercase letters that the password must contain
        """
        return pulumi.get(self, "lowercase")

    @lowercase.setter
    def lowercase(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "lowercase", value)

    @_builtins.property
    @pulumi.getter(name="specialChar")
    def special_char(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Minimum number of special char that the password must contain. Special chars list: ``!"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~``
        """
        return pulumi.get(self, "special_char")

    @special_char.setter
    def special_char(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "special_char", value)

    @_builtins.property
    @pulumi.getter
    def uppercase(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Minimum number of uppercase letters that the password must contain
        """
        return pulumi.get(self, "uppercase")

    @uppercase.setter
    def uppercase(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "uppercase", value)


if not MYPY:
    class UserCustomWebhookHandlerArgsDict(TypedDict):
        url: pulumi.Input[_builtins.str]
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send a request to.
        """
        http_headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        """
        method: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the HTTP method for the URL that the Webhook invokes. Allowed values are: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`.
        """
        payload: NotRequired[pulumi.Input[_builtins.str]]
        """
        This attribute is used to build the request body. Used in custom webhooks
        """
        proxy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        secrets: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
elif False:
    UserCustomWebhookHandlerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserCustomWebhookHandlerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[_builtins.str],
                 http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 method: Optional[pulumi.Input[_builtins.str]] = None,
                 payload: Optional[pulumi.Input[_builtins.str]] = None,
                 proxy: Optional[pulumi.Input[_builtins.str]] = None,
                 secrets: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send a request to.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] http_headers: HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        :param pulumi.Input[_builtins.str] method: Specifies the HTTP method for the URL that the Webhook invokes. Allowed values are: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`.
        :param pulumi.Input[_builtins.str] payload: This attribute is used to build the request body. Used in custom webhooks
        :param pulumi.Input[_builtins.str] proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] secrets: Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
        pulumi.set(__self__, "url", url)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send a request to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        HTTP headers you wish to use to invoke the Webhook, comprise key/value pair.
        """
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "http_headers", value)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the HTTP method for the URL that the Webhook invokes. Allowed values are: `GET`, `POST`, `PUT`, `PATCH`, `DELETE`.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        This attribute is used to build the request body. Used in custom webhooks
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "payload", value)

    @_builtins.property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy", value)

    @_builtins.property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Defines a set of sensitive values (such as, tokens and passwords) that can be injected in the headers and/or payload.Secrets values are encrypted. In the header/payload, the value can be invoked using the `{{.secrets.token}}` format, where token is the name provided for the secret value. Comprise key/value pair. **Note:** if multiple handlers are used, same secret name and different secret value for the same url won't work. Example:
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "secrets", value)


if not MYPY:
    class UserPasswordPolicyArgsDict(TypedDict):
        digit: NotRequired[pulumi.Input[_builtins.int]]
        """
        Minimum number of digits that the password must contain
        """
        length: NotRequired[pulumi.Input[_builtins.int]]
        """
        Minimum length of the password
        """
        lowercase: NotRequired[pulumi.Input[_builtins.int]]
        """
        Minimum number of lowercase letters that the password must contain
        """
        special_char: NotRequired[pulumi.Input[_builtins.int]]
        """
        Minimum number of special char that the password must contain. Special chars list: `!"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~`
        """
        uppercase: NotRequired[pulumi.Input[_builtins.int]]
        """
        Minimum number of uppercase letters that the password must contain
        """
elif False:
    UserPasswordPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserPasswordPolicyArgs:
    def __init__(__self__, *,
                 digit: Optional[pulumi.Input[_builtins.int]] = None,
                 length: Optional[pulumi.Input[_builtins.int]] = None,
                 lowercase: Optional[pulumi.Input[_builtins.int]] = None,
                 special_char: Optional[pulumi.Input[_builtins.int]] = None,
                 uppercase: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] digit: Minimum number of digits that the password must contain
        :param pulumi.Input[_builtins.int] length: Minimum length of the password
        :param pulumi.Input[_builtins.int] lowercase: Minimum number of lowercase letters that the password must contain
        :param pulumi.Input[_builtins.int] special_char: Minimum number of special char that the password must contain. Special chars list: `!"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~`
        :param pulumi.Input[_builtins.int] uppercase: Minimum number of uppercase letters that the password must contain
        """
        if digit is not None:
            pulumi.set(__self__, "digit", digit)
        if length is not None:
            pulumi.set(__self__, "length", length)
        if lowercase is not None:
            pulumi.set(__self__, "lowercase", lowercase)
        if special_char is not None:
            pulumi.set(__self__, "special_char", special_char)
        if uppercase is not None:
            pulumi.set(__self__, "uppercase", uppercase)

    @_builtins.property
    @pulumi.getter
    def digit(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Minimum number of digits that the password must contain
        """
        return pulumi.get(self, "digit")

    @digit.setter
    def digit(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "digit", value)

    @_builtins.property
    @pulumi.getter
    def length(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Minimum length of the password
        """
        return pulumi.get(self, "length")

    @length.setter
    def length(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "length", value)

    @_builtins.property
    @pulumi.getter
    def lowercase(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Minimum number of lowercase letters that the password must contain
        """
        return pulumi.get(self, "lowercase")

    @lowercase.setter
    def lowercase(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "lowercase", value)

    @_builtins.property
    @pulumi.getter(name="specialChar")
    def special_char(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Minimum number of special char that the password must contain. Special chars list: `!"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~`
        """
        return pulumi.get(self, "special_char")

    @special_char.setter
    def special_char(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "special_char", value)

    @_builtins.property
    @pulumi.getter
    def uppercase(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Minimum number of uppercase letters that the password must contain
        """
        return pulumi.get(self, "uppercase")

    @uppercase.setter
    def uppercase(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "uppercase", value)


if not MYPY:
    class UserWebhookHandlerArgsDict(TypedDict):
        url: pulumi.Input[_builtins.str]
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        custom_http_headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        proxy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        use_secret_for_signing: NotRequired[pulumi.Input[_builtins.bool]]
        """
        When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
elif False:
    UserWebhookHandlerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserWebhookHandlerArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[_builtins.str],
                 custom_http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 proxy: Optional[pulumi.Input[_builtins.str]] = None,
                 secret: Optional[pulumi.Input[_builtins.str]] = None,
                 use_secret_for_signing: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] url: Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] custom_http_headers: Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        :param pulumi.Input[_builtins.str] proxy: Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        :param pulumi.Input[_builtins.str] secret: Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        :param pulumi.Input[_builtins.bool] use_secret_for_signing: When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        pulumi.set(__self__, "url", url)
        if custom_http_headers is not None:
            pulumi.set(__self__, "custom_http_headers", custom_http_headers)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if use_secret_for_signing is not None:
            pulumi.set(__self__, "use_secret_for_signing", use_secret_for_signing)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies the URL that the Webhook invokes. This will be the URL that Artifactory will send an HTTP POST request to.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="customHttpHeaders")
    def custom_http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Custom HTTP headers you wish to use to invoke the Webhook, comprise of key/value pair.
        """
        return pulumi.get(self, "custom_http_headers")

    @custom_http_headers.setter
    def custom_http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "custom_http_headers", value)

    @_builtins.property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Proxy key from Artifactory UI (Administration > Proxies > Configuration).
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "proxy", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Secret authentication token that will be sent to the configured URL. The value will be sent as `x-jfrog-event-auth` header.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret", value)

    @_builtins.property
    @pulumi.getter(name="useSecretForSigning")
    def use_secret_for_signing(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When set to `true`, the secret will be used to sign the event payload, allowing the target to validate that the payload content has not been changed and will not be passed as part of the event. If left unset or set to `false`, the secret is passed through the `X-JFrog-Event-Auth` HTTP header.
        """
        return pulumi.get(self, "use_secret_for_signing")

    @use_secret_for_signing.setter
    def use_secret_for_signing(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_secret_for_signing", value)


if not MYPY:
    class VaultConfigurationConfigArgsDict(TypedDict):
        auth: pulumi.Input['VaultConfigurationConfigAuthArgsDict']
        mounts: pulumi.Input[Sequence[pulumi.Input['VaultConfigurationConfigMountArgsDict']]]
        url: pulumi.Input[_builtins.str]
        """
        The base URL of the Vault server.
        """
elif False:
    VaultConfigurationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VaultConfigurationConfigArgs:
    def __init__(__self__, *,
                 auth: pulumi.Input['VaultConfigurationConfigAuthArgs'],
                 mounts: pulumi.Input[Sequence[pulumi.Input['VaultConfigurationConfigMountArgs']]],
                 url: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] url: The base URL of the Vault server.
        """
        pulumi.set(__self__, "auth", auth)
        pulumi.set(__self__, "mounts", mounts)
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def auth(self) -> pulumi.Input['VaultConfigurationConfigAuthArgs']:
        return pulumi.get(self, "auth")

    @auth.setter
    def auth(self, value: pulumi.Input['VaultConfigurationConfigAuthArgs']):
        pulumi.set(self, "auth", value)

    @_builtins.property
    @pulumi.getter
    def mounts(self) -> pulumi.Input[Sequence[pulumi.Input['VaultConfigurationConfigMountArgs']]]:
        return pulumi.get(self, "mounts")

    @mounts.setter
    def mounts(self, value: pulumi.Input[Sequence[pulumi.Input['VaultConfigurationConfigMountArgs']]]):
        pulumi.set(self, "mounts", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        The base URL of the Vault server.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)


if not MYPY:
    class VaultConfigurationConfigAuthArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        certificate: NotRequired[pulumi.Input[_builtins.str]]
        """
        Client certificate (in PEM format) for `Certificate` type.
        """
        certificate_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Private key (in PEM format) for `Certificate` type.
        """
        role_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Role ID for `AppRole` type
        """
        secret_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Secret ID for `AppRole` type
        """
elif False:
    VaultConfigurationConfigAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VaultConfigurationConfigAuthArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 certificate: Optional[pulumi.Input[_builtins.str]] = None,
                 certificate_key: Optional[pulumi.Input[_builtins.str]] = None,
                 role_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] certificate: Client certificate (in PEM format) for `Certificate` type.
        :param pulumi.Input[_builtins.str] certificate_key: Private key (in PEM format) for `Certificate` type.
        :param pulumi.Input[_builtins.str] role_id: Role ID for `AppRole` type
        :param pulumi.Input[_builtins.str] secret_id: Secret ID for `AppRole` type
        """
        pulumi.set(__self__, "type", type)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if certificate_key is not None:
            pulumi.set(__self__, "certificate_key", certificate_key)
        if role_id is not None:
            pulumi.set(__self__, "role_id", role_id)
        if secret_id is not None:
            pulumi.set(__self__, "secret_id", secret_id)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Client certificate (in PEM format) for `Certificate` type.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate", value)

    @_builtins.property
    @pulumi.getter(name="certificateKey")
    def certificate_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Private key (in PEM format) for `Certificate` type.
        """
        return pulumi.get(self, "certificate_key")

    @certificate_key.setter
    def certificate_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_key", value)

    @_builtins.property
    @pulumi.getter(name="roleId")
    def role_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Role ID for `AppRole` type
        """
        return pulumi.get(self, "role_id")

    @role_id.setter
    def role_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_id", value)

    @_builtins.property
    @pulumi.getter(name="secretId")
    def secret_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Secret ID for `AppRole` type
        """
        return pulumi.get(self, "secret_id")

    @secret_id.setter
    def secret_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_id", value)


if not MYPY:
    class VaultConfigurationConfigMountArgsDict(TypedDict):
        path: pulumi.Input[_builtins.str]
        """
        Vault secret engine path
        """
        type: pulumi.Input[_builtins.str]
        """
        Vault supports several secret engines, each one has different capabilities. The supported secret engine types are: `KV1` and `KV2`.
        """
elif False:
    VaultConfigurationConfigMountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VaultConfigurationConfigMountArgs:
    def __init__(__self__, *,
                 path: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] path: Vault secret engine path
        :param pulumi.Input[_builtins.str] type: Vault supports several secret engines, each one has different capabilities. The supported secret engine types are: `KV1` and `KV2`.
        """
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def path(self) -> pulumi.Input[_builtins.str]:
        """
        Vault secret engine path
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Vault supports several secret engines, each one has different capabilities. The supported secret engine types are: `KV1` and `KV2`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class GetFederatedAlpineRepositoryMemberArgsDict(TypedDict):
        enabled: _builtins.bool
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: _builtins.str
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[_builtins.str]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    GetFederatedAlpineRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFederatedAlpineRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: _builtins.bool):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: _builtins.str):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[_builtins.str]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class GetFederatedAnsibleRepositoryMemberArgsDict(TypedDict):
        enabled: _builtins.bool
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: _builtins.str
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[_builtins.str]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    GetFederatedAnsibleRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFederatedAnsibleRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: _builtins.bool):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: _builtins.str):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[_builtins.str]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class GetFederatedBowerRepositoryMemberArgsDict(TypedDict):
        enabled: _builtins.bool
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: _builtins.str
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[_builtins.str]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    GetFederatedBowerRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFederatedBowerRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: _builtins.bool):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: _builtins.str):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[_builtins.str]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class GetFederatedCargoRepositoryMemberArgsDict(TypedDict):
        enabled: _builtins.bool
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: _builtins.str
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[_builtins.str]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    GetFederatedCargoRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFederatedCargoRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: _builtins.bool):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: _builtins.str):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[_builtins.str]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class GetFederatedChefRepositoryMemberArgsDict(TypedDict):
        enabled: _builtins.bool
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: _builtins.str
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[_builtins.str]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    GetFederatedChefRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFederatedChefRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: _builtins.bool):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: _builtins.str):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[_builtins.str]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class GetFederatedCocoapodsRepositoryMemberArgsDict(TypedDict):
        enabled: _builtins.bool
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: _builtins.str
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[_builtins.str]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    GetFederatedCocoapodsRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFederatedCocoapodsRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: _builtins.bool):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: _builtins.str):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[_builtins.str]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class GetFederatedComposerRepositoryMemberArgsDict(TypedDict):
        enabled: _builtins.bool
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: _builtins.str
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[_builtins.str]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    GetFederatedComposerRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFederatedComposerRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: _builtins.bool):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: _builtins.str):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[_builtins.str]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class GetFederatedConanRepositoryMemberArgsDict(TypedDict):
        enabled: _builtins.bool
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: _builtins.str
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[_builtins.str]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    GetFederatedConanRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFederatedConanRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: _builtins.bool):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: _builtins.str):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[_builtins.str]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class GetFederatedCondaRepositoryMemberArgsDict(TypedDict):
        enabled: _builtins.bool
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: _builtins.str
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[_builtins.str]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    GetFederatedCondaRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFederatedCondaRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: _builtins.bool):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: _builtins.str):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[_builtins.str]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class GetFederatedCranRepositoryMemberArgsDict(TypedDict):
        enabled: _builtins.bool
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: _builtins.str
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[_builtins.str]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    GetFederatedCranRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFederatedCranRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: _builtins.bool):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: _builtins.str):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[_builtins.str]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class GetFederatedDebianRepositoryMemberArgsDict(TypedDict):
        enabled: _builtins.bool
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: _builtins.str
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[_builtins.str]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    GetFederatedDebianRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFederatedDebianRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: _builtins.bool):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: _builtins.str):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[_builtins.str]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class GetFederatedDockerRepositoryMemberArgsDict(TypedDict):
        enabled: _builtins.bool
        """
        Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        """
        url: _builtins.str
        """
        Full URL to ending with the repositoryName
        """
        access_token: NotRequired[_builtins.str]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    GetFederatedDockerRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFederatedDockerRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repositoryName
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: _builtins.bool):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repositoryName
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: _builtins.str):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[_builtins.str]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class GetFederatedDockerV1RepositoryMemberArgsDict(TypedDict):
        enabled: _builtins.bool
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: _builtins.str
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[_builtins.str]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    GetFederatedDockerV1RepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFederatedDockerV1RepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: _builtins.bool):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: _builtins.str):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[_builtins.str]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class GetFederatedDockerV2RepositoryMemberArgsDict(TypedDict):
        enabled: _builtins.bool
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: _builtins.str
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[_builtins.str]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    GetFederatedDockerV2RepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFederatedDockerV2RepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: _builtins.bool):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: _builtins.str):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[_builtins.str]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class GetFederatedGemsRepositoryMemberArgsDict(TypedDict):
        enabled: _builtins.bool
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: _builtins.str
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[_builtins.str]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    GetFederatedGemsRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFederatedGemsRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: _builtins.bool):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: _builtins.str):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[_builtins.str]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class GetFederatedGenericRepositoryMemberArgsDict(TypedDict):
        enabled: _builtins.bool
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: _builtins.str
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[_builtins.str]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    GetFederatedGenericRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFederatedGenericRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: _builtins.bool):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: _builtins.str):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[_builtins.str]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class GetFederatedGitlfsRepositoryMemberArgsDict(TypedDict):
        enabled: _builtins.bool
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: _builtins.str
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[_builtins.str]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    GetFederatedGitlfsRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFederatedGitlfsRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: _builtins.bool):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: _builtins.str):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[_builtins.str]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class GetFederatedGoRepositoryMemberArgsDict(TypedDict):
        enabled: _builtins.bool
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: _builtins.str
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[_builtins.str]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    GetFederatedGoRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFederatedGoRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: _builtins.bool):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: _builtins.str):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[_builtins.str]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class GetFederatedGradleRepositoryMemberArgsDict(TypedDict):
        enabled: _builtins.bool
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: _builtins.str
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[_builtins.str]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    GetFederatedGradleRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFederatedGradleRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: _builtins.bool):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: _builtins.str):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[_builtins.str]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class GetFederatedHelmRepositoryMemberArgsDict(TypedDict):
        enabled: _builtins.bool
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: _builtins.str
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[_builtins.str]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    GetFederatedHelmRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFederatedHelmRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: _builtins.bool):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: _builtins.str):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[_builtins.str]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class GetFederatedHelmociRepositoryMemberArgsDict(TypedDict):
        enabled: _builtins.bool
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: _builtins.str
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[_builtins.str]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    GetFederatedHelmociRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFederatedHelmociRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: _builtins.bool):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: _builtins.str):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[_builtins.str]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class GetFederatedHuggingfacemlRepositoryMemberArgsDict(TypedDict):
        enabled: _builtins.bool
        """
        Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        """
        url: _builtins.str
        """
        Full URL to ending with the repositoryName
        """
        access_token: NotRequired[_builtins.str]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    GetFederatedHuggingfacemlRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFederatedHuggingfacemlRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repositoryName
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: _builtins.bool):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repositoryName
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: _builtins.str):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[_builtins.str]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class GetFederatedIvyRepositoryMemberArgsDict(TypedDict):
        enabled: _builtins.bool
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: _builtins.str
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[_builtins.str]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    GetFederatedIvyRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFederatedIvyRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: _builtins.bool):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: _builtins.str):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[_builtins.str]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class GetFederatedMavenRepositoryMemberArgsDict(TypedDict):
        enabled: _builtins.bool
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: _builtins.str
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[_builtins.str]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    GetFederatedMavenRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFederatedMavenRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: _builtins.bool):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: _builtins.str):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[_builtins.str]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class GetFederatedNpmRepositoryMemberArgsDict(TypedDict):
        enabled: _builtins.bool
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: _builtins.str
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[_builtins.str]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    GetFederatedNpmRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFederatedNpmRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: _builtins.bool):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: _builtins.str):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[_builtins.str]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class GetFederatedNugetRepositoryMemberArgsDict(TypedDict):
        enabled: _builtins.bool
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: _builtins.str
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[_builtins.str]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    GetFederatedNugetRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFederatedNugetRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: _builtins.bool):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: _builtins.str):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[_builtins.str]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class GetFederatedOciRepositoryMemberArgsDict(TypedDict):
        enabled: _builtins.bool
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: _builtins.str
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[_builtins.str]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    GetFederatedOciRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFederatedOciRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: _builtins.bool):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: _builtins.str):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[_builtins.str]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class GetFederatedOpkgRepositoryMemberArgsDict(TypedDict):
        enabled: _builtins.bool
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: _builtins.str
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[_builtins.str]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    GetFederatedOpkgRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFederatedOpkgRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: _builtins.bool):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: _builtins.str):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[_builtins.str]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class GetFederatedPuppetRepositoryMemberArgsDict(TypedDict):
        enabled: _builtins.bool
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: _builtins.str
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[_builtins.str]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    GetFederatedPuppetRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFederatedPuppetRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: _builtins.bool):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: _builtins.str):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[_builtins.str]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class GetFederatedPypiRepositoryMemberArgsDict(TypedDict):
        enabled: _builtins.bool
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: _builtins.str
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[_builtins.str]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    GetFederatedPypiRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFederatedPypiRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: _builtins.bool):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: _builtins.str):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[_builtins.str]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class GetFederatedReleasebundlesRepositoryMemberArgsDict(TypedDict):
        enabled: _builtins.bool
        """
        Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        """
        url: _builtins.str
        """
        Full URL to ending with the repositoryName
        """
        access_token: NotRequired[_builtins.str]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    GetFederatedReleasebundlesRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFederatedReleasebundlesRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repositoryName
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: _builtins.bool):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repositoryName
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: _builtins.str):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[_builtins.str]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class GetFederatedRpmRepositoryMemberArgsDict(TypedDict):
        enabled: _builtins.bool
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: _builtins.str
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[_builtins.str]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    GetFederatedRpmRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFederatedRpmRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: _builtins.bool):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: _builtins.str):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[_builtins.str]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class GetFederatedSbtRepositoryMemberArgsDict(TypedDict):
        enabled: _builtins.bool
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: _builtins.str
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[_builtins.str]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    GetFederatedSbtRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFederatedSbtRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: _builtins.bool):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: _builtins.str):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[_builtins.str]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class GetFederatedSwiftRepositoryMemberArgsDict(TypedDict):
        enabled: _builtins.bool
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: _builtins.str
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[_builtins.str]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    GetFederatedSwiftRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFederatedSwiftRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: _builtins.bool):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: _builtins.str):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[_builtins.str]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class GetFederatedTerraformModuleRepositoryMemberArgsDict(TypedDict):
        enabled: _builtins.bool
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: _builtins.str
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[_builtins.str]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    GetFederatedTerraformModuleRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFederatedTerraformModuleRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: _builtins.bool):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: _builtins.str):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[_builtins.str]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class GetFederatedTerraformProviderRepositoryMemberArgsDict(TypedDict):
        enabled: _builtins.bool
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: _builtins.str
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[_builtins.str]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    GetFederatedTerraformProviderRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFederatedTerraformProviderRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: _builtins.bool):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: _builtins.str):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[_builtins.str]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class GetFederatedVagrantRepositoryMemberArgsDict(TypedDict):
        enabled: _builtins.bool
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        url: _builtins.str
        """
        Full URL to ending with the repository name.
        """
        access_token: NotRequired[_builtins.str]
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
elif False:
    GetFederatedVagrantRepositoryMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFederatedVagrantRepositoryMemberArgs:
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 url: _builtins.str,
                 access_token: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Represents the active state of the federated member. It is supported to change the enabled
               status of my own member. The config will be updated on the other federated members automatically.
        :param _builtins.str url: Full URL to ending with the repository name.
        :param _builtins.str access_token: Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "url", url)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Represents the active state of the federated member. It is supported to change the enabled
        status of my own member. The config will be updated on the other federated members automatically.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: _builtins.bool):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Full URL to ending with the repository name.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: _builtins.str):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Admin access token for this member Artifactory instance. Used in conjunction with `cleanup_on_delete` attribute when Access Federation for access tokens is not enabled.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[_builtins.str]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class GetPermissionTargetBuildArgsDict(TypedDict):
        repositories: Sequence[_builtins.str]
        """
        List of repositories this permission target is applicable for. You can specify the
        name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote
        repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        """
        actions: NotRequired['GetPermissionTargetBuildActionsArgsDict']
        excludes_patterns: NotRequired[Sequence[_builtins.str]]
        """
        Pattern of artifacts to exclude.
        """
        includes_patterns: NotRequired[Sequence[_builtins.str]]
        """
        Pattern of artifacts to include.
        """
elif False:
    GetPermissionTargetBuildArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPermissionTargetBuildArgs:
    def __init__(__self__, *,
                 repositories: Sequence[_builtins.str],
                 actions: Optional['GetPermissionTargetBuildActionsArgs'] = None,
                 excludes_patterns: Optional[Sequence[_builtins.str]] = None,
                 includes_patterns: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] repositories: List of repositories this permission target is applicable for. You can specify the
               name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote
               repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        :param Sequence[_builtins.str] excludes_patterns: Pattern of artifacts to exclude.
        :param Sequence[_builtins.str] includes_patterns: Pattern of artifacts to include.
        """
        pulumi.set(__self__, "repositories", repositories)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if excludes_patterns is not None:
            pulumi.set(__self__, "excludes_patterns", excludes_patterns)
        if includes_patterns is not None:
            pulumi.set(__self__, "includes_patterns", includes_patterns)

    @_builtins.property
    @pulumi.getter
    def repositories(self) -> Sequence[_builtins.str]:
        """
        List of repositories this permission target is applicable for. You can specify the
        name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote
        repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        """
        return pulumi.get(self, "repositories")

    @repositories.setter
    def repositories(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "repositories", value)

    @_builtins.property
    @pulumi.getter
    def actions(self) -> Optional['GetPermissionTargetBuildActionsArgs']:
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional['GetPermissionTargetBuildActionsArgs']):
        pulumi.set(self, "actions", value)

    @_builtins.property
    @pulumi.getter(name="excludesPatterns")
    def excludes_patterns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Pattern of artifacts to exclude.
        """
        return pulumi.get(self, "excludes_patterns")

    @excludes_patterns.setter
    def excludes_patterns(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "excludes_patterns", value)

    @_builtins.property
    @pulumi.getter(name="includesPatterns")
    def includes_patterns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Pattern of artifacts to include.
        """
        return pulumi.get(self, "includes_patterns")

    @includes_patterns.setter
    def includes_patterns(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "includes_patterns", value)


if not MYPY:
    class GetPermissionTargetBuildActionsArgsDict(TypedDict):
        groups: NotRequired[Sequence['GetPermissionTargetBuildActionsGroupArgsDict']]
        """
        Groups this permission applies for.
        """
        users: NotRequired[Sequence['GetPermissionTargetBuildActionsUserArgsDict']]
        """
        Users this permission target applies for.
        """
elif False:
    GetPermissionTargetBuildActionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPermissionTargetBuildActionsArgs:
    def __init__(__self__, *,
                 groups: Optional[Sequence['GetPermissionTargetBuildActionsGroupArgs']] = None,
                 users: Optional[Sequence['GetPermissionTargetBuildActionsUserArgs']] = None):
        """
        :param Sequence['GetPermissionTargetBuildActionsGroupArgs'] groups: Groups this permission applies for.
        :param Sequence['GetPermissionTargetBuildActionsUserArgs'] users: Users this permission target applies for.
        """
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @_builtins.property
    @pulumi.getter
    def groups(self) -> Optional[Sequence['GetPermissionTargetBuildActionsGroupArgs']]:
        """
        Groups this permission applies for.
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[Sequence['GetPermissionTargetBuildActionsGroupArgs']]):
        pulumi.set(self, "groups", value)

    @_builtins.property
    @pulumi.getter
    def users(self) -> Optional[Sequence['GetPermissionTargetBuildActionsUserArgs']]:
        """
        Users this permission target applies for.
        """
        return pulumi.get(self, "users")

    @users.setter
    def users(self, value: Optional[Sequence['GetPermissionTargetBuildActionsUserArgs']]):
        pulumi.set(self, "users", value)


if not MYPY:
    class GetPermissionTargetBuildActionsGroupArgsDict(TypedDict):
        name: _builtins.str
        """
        Name of the permission target.
        """
        permissions: Sequence[_builtins.str]
elif False:
    GetPermissionTargetBuildActionsGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPermissionTargetBuildActionsGroupArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 permissions: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Name of the permission target.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the permission target.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def permissions(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "permissions", value)


if not MYPY:
    class GetPermissionTargetBuildActionsUserArgsDict(TypedDict):
        name: _builtins.str
        """
        Name of the permission target.
        """
        permissions: Sequence[_builtins.str]
elif False:
    GetPermissionTargetBuildActionsUserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPermissionTargetBuildActionsUserArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 permissions: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Name of the permission target.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the permission target.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def permissions(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "permissions", value)


if not MYPY:
    class GetPermissionTargetReleaseBundleArgsDict(TypedDict):
        repositories: Sequence[_builtins.str]
        """
        List of repositories this permission target is applicable for. You can specify the
        name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote
        repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        """
        actions: NotRequired['GetPermissionTargetReleaseBundleActionsArgsDict']
        excludes_patterns: NotRequired[Sequence[_builtins.str]]
        """
        Pattern of artifacts to exclude.
        """
        includes_patterns: NotRequired[Sequence[_builtins.str]]
        """
        Pattern of artifacts to include.
        """
elif False:
    GetPermissionTargetReleaseBundleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPermissionTargetReleaseBundleArgs:
    def __init__(__self__, *,
                 repositories: Sequence[_builtins.str],
                 actions: Optional['GetPermissionTargetReleaseBundleActionsArgs'] = None,
                 excludes_patterns: Optional[Sequence[_builtins.str]] = None,
                 includes_patterns: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] repositories: List of repositories this permission target is applicable for. You can specify the
               name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote
               repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        :param Sequence[_builtins.str] excludes_patterns: Pattern of artifacts to exclude.
        :param Sequence[_builtins.str] includes_patterns: Pattern of artifacts to include.
        """
        pulumi.set(__self__, "repositories", repositories)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if excludes_patterns is not None:
            pulumi.set(__self__, "excludes_patterns", excludes_patterns)
        if includes_patterns is not None:
            pulumi.set(__self__, "includes_patterns", includes_patterns)

    @_builtins.property
    @pulumi.getter
    def repositories(self) -> Sequence[_builtins.str]:
        """
        List of repositories this permission target is applicable for. You can specify the
        name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote
        repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        """
        return pulumi.get(self, "repositories")

    @repositories.setter
    def repositories(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "repositories", value)

    @_builtins.property
    @pulumi.getter
    def actions(self) -> Optional['GetPermissionTargetReleaseBundleActionsArgs']:
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional['GetPermissionTargetReleaseBundleActionsArgs']):
        pulumi.set(self, "actions", value)

    @_builtins.property
    @pulumi.getter(name="excludesPatterns")
    def excludes_patterns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Pattern of artifacts to exclude.
        """
        return pulumi.get(self, "excludes_patterns")

    @excludes_patterns.setter
    def excludes_patterns(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "excludes_patterns", value)

    @_builtins.property
    @pulumi.getter(name="includesPatterns")
    def includes_patterns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Pattern of artifacts to include.
        """
        return pulumi.get(self, "includes_patterns")

    @includes_patterns.setter
    def includes_patterns(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "includes_patterns", value)


if not MYPY:
    class GetPermissionTargetReleaseBundleActionsArgsDict(TypedDict):
        groups: NotRequired[Sequence['GetPermissionTargetReleaseBundleActionsGroupArgsDict']]
        """
        Groups this permission applies for.
        """
        users: NotRequired[Sequence['GetPermissionTargetReleaseBundleActionsUserArgsDict']]
        """
        Users this permission target applies for.
        """
elif False:
    GetPermissionTargetReleaseBundleActionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPermissionTargetReleaseBundleActionsArgs:
    def __init__(__self__, *,
                 groups: Optional[Sequence['GetPermissionTargetReleaseBundleActionsGroupArgs']] = None,
                 users: Optional[Sequence['GetPermissionTargetReleaseBundleActionsUserArgs']] = None):
        """
        :param Sequence['GetPermissionTargetReleaseBundleActionsGroupArgs'] groups: Groups this permission applies for.
        :param Sequence['GetPermissionTargetReleaseBundleActionsUserArgs'] users: Users this permission target applies for.
        """
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @_builtins.property
    @pulumi.getter
    def groups(self) -> Optional[Sequence['GetPermissionTargetReleaseBundleActionsGroupArgs']]:
        """
        Groups this permission applies for.
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[Sequence['GetPermissionTargetReleaseBundleActionsGroupArgs']]):
        pulumi.set(self, "groups", value)

    @_builtins.property
    @pulumi.getter
    def users(self) -> Optional[Sequence['GetPermissionTargetReleaseBundleActionsUserArgs']]:
        """
        Users this permission target applies for.
        """
        return pulumi.get(self, "users")

    @users.setter
    def users(self, value: Optional[Sequence['GetPermissionTargetReleaseBundleActionsUserArgs']]):
        pulumi.set(self, "users", value)


if not MYPY:
    class GetPermissionTargetReleaseBundleActionsGroupArgsDict(TypedDict):
        name: _builtins.str
        """
        Name of the permission target.
        """
        permissions: Sequence[_builtins.str]
elif False:
    GetPermissionTargetReleaseBundleActionsGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPermissionTargetReleaseBundleActionsGroupArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 permissions: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Name of the permission target.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the permission target.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def permissions(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "permissions", value)


if not MYPY:
    class GetPermissionTargetReleaseBundleActionsUserArgsDict(TypedDict):
        name: _builtins.str
        """
        Name of the permission target.
        """
        permissions: Sequence[_builtins.str]
elif False:
    GetPermissionTargetReleaseBundleActionsUserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPermissionTargetReleaseBundleActionsUserArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 permissions: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Name of the permission target.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the permission target.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def permissions(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "permissions", value)


if not MYPY:
    class GetPermissionTargetRepoArgsDict(TypedDict):
        repositories: Sequence[_builtins.str]
        """
        List of repositories this permission target is applicable for. You can specify the
        name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote
        repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        """
        actions: NotRequired['GetPermissionTargetRepoActionsArgsDict']
        excludes_patterns: NotRequired[Sequence[_builtins.str]]
        """
        Pattern of artifacts to exclude.
        """
        includes_patterns: NotRequired[Sequence[_builtins.str]]
        """
        Pattern of artifacts to include.
        """
elif False:
    GetPermissionTargetRepoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPermissionTargetRepoArgs:
    def __init__(__self__, *,
                 repositories: Sequence[_builtins.str],
                 actions: Optional['GetPermissionTargetRepoActionsArgs'] = None,
                 excludes_patterns: Optional[Sequence[_builtins.str]] = None,
                 includes_patterns: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] repositories: List of repositories this permission target is applicable for. You can specify the
               name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote
               repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        :param Sequence[_builtins.str] excludes_patterns: Pattern of artifacts to exclude.
        :param Sequence[_builtins.str] includes_patterns: Pattern of artifacts to include.
        """
        pulumi.set(__self__, "repositories", repositories)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if excludes_patterns is not None:
            pulumi.set(__self__, "excludes_patterns", excludes_patterns)
        if includes_patterns is not None:
            pulumi.set(__self__, "includes_patterns", includes_patterns)

    @_builtins.property
    @pulumi.getter
    def repositories(self) -> Sequence[_builtins.str]:
        """
        List of repositories this permission target is applicable for. You can specify the
        name `ANY` in the repositories section in order to apply to all repositories, `ANY REMOTE` for all remote
        repositories and `ANY LOCAL` for all local repositories. The default value will be `[]` if nothing is specified.
        """
        return pulumi.get(self, "repositories")

    @repositories.setter
    def repositories(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "repositories", value)

    @_builtins.property
    @pulumi.getter
    def actions(self) -> Optional['GetPermissionTargetRepoActionsArgs']:
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional['GetPermissionTargetRepoActionsArgs']):
        pulumi.set(self, "actions", value)

    @_builtins.property
    @pulumi.getter(name="excludesPatterns")
    def excludes_patterns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Pattern of artifacts to exclude.
        """
        return pulumi.get(self, "excludes_patterns")

    @excludes_patterns.setter
    def excludes_patterns(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "excludes_patterns", value)

    @_builtins.property
    @pulumi.getter(name="includesPatterns")
    def includes_patterns(self) -> Optional[Sequence[_builtins.str]]:
        """
        Pattern of artifacts to include.
        """
        return pulumi.get(self, "includes_patterns")

    @includes_patterns.setter
    def includes_patterns(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "includes_patterns", value)


if not MYPY:
    class GetPermissionTargetRepoActionsArgsDict(TypedDict):
        groups: NotRequired[Sequence['GetPermissionTargetRepoActionsGroupArgsDict']]
        """
        Groups this permission applies for.
        """
        users: NotRequired[Sequence['GetPermissionTargetRepoActionsUserArgsDict']]
        """
        Users this permission target applies for.
        """
elif False:
    GetPermissionTargetRepoActionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPermissionTargetRepoActionsArgs:
    def __init__(__self__, *,
                 groups: Optional[Sequence['GetPermissionTargetRepoActionsGroupArgs']] = None,
                 users: Optional[Sequence['GetPermissionTargetRepoActionsUserArgs']] = None):
        """
        :param Sequence['GetPermissionTargetRepoActionsGroupArgs'] groups: Groups this permission applies for.
        :param Sequence['GetPermissionTargetRepoActionsUserArgs'] users: Users this permission target applies for.
        """
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @_builtins.property
    @pulumi.getter
    def groups(self) -> Optional[Sequence['GetPermissionTargetRepoActionsGroupArgs']]:
        """
        Groups this permission applies for.
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[Sequence['GetPermissionTargetRepoActionsGroupArgs']]):
        pulumi.set(self, "groups", value)

    @_builtins.property
    @pulumi.getter
    def users(self) -> Optional[Sequence['GetPermissionTargetRepoActionsUserArgs']]:
        """
        Users this permission target applies for.
        """
        return pulumi.get(self, "users")

    @users.setter
    def users(self, value: Optional[Sequence['GetPermissionTargetRepoActionsUserArgs']]):
        pulumi.set(self, "users", value)


if not MYPY:
    class GetPermissionTargetRepoActionsGroupArgsDict(TypedDict):
        name: _builtins.str
        """
        Name of the permission target.
        """
        permissions: Sequence[_builtins.str]
elif False:
    GetPermissionTargetRepoActionsGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPermissionTargetRepoActionsGroupArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 permissions: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Name of the permission target.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the permission target.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def permissions(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "permissions", value)


if not MYPY:
    class GetPermissionTargetRepoActionsUserArgsDict(TypedDict):
        name: _builtins.str
        """
        Name of the permission target.
        """
        permissions: Sequence[_builtins.str]
elif False:
    GetPermissionTargetRepoActionsUserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPermissionTargetRepoActionsUserArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 permissions: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Name of the permission target.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "permissions", permissions)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the permission target.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def permissions(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "permissions", value)


if not MYPY:
    class GetRemoteAlpineRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[_builtins.bool]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[_builtins.bool]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[_builtins.bool]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[_builtins.bool]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    GetRemoteAlpineRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRemoteAlpineRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class GetRemoteAnsibleRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[_builtins.bool]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[_builtins.bool]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[_builtins.bool]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[_builtins.bool]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    GetRemoteAnsibleRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRemoteAnsibleRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class GetRemoteBowerRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[_builtins.bool]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[_builtins.bool]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[_builtins.bool]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[_builtins.bool]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    GetRemoteBowerRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRemoteBowerRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class GetRemoteCargoRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[_builtins.bool]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[_builtins.bool]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[_builtins.bool]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[_builtins.bool]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    GetRemoteCargoRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRemoteCargoRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class GetRemoteChefRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[_builtins.bool]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[_builtins.bool]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[_builtins.bool]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[_builtins.bool]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    GetRemoteChefRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRemoteChefRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class GetRemoteCocoapodsRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[_builtins.bool]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[_builtins.bool]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[_builtins.bool]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[_builtins.bool]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    GetRemoteCocoapodsRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRemoteCocoapodsRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class GetRemoteComposerRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[_builtins.bool]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[_builtins.bool]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[_builtins.bool]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[_builtins.bool]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    GetRemoteComposerRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRemoteComposerRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class GetRemoteConanRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[_builtins.bool]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[_builtins.bool]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[_builtins.bool]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[_builtins.bool]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    GetRemoteConanRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRemoteConanRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class GetRemoteCondaRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[_builtins.bool]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[_builtins.bool]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[_builtins.bool]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[_builtins.bool]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    GetRemoteCondaRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRemoteCondaRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class GetRemoteCranRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[_builtins.bool]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[_builtins.bool]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[_builtins.bool]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[_builtins.bool]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    GetRemoteCranRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRemoteCranRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class GetRemoteDebianRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[_builtins.bool]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[_builtins.bool]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[_builtins.bool]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[_builtins.bool]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    GetRemoteDebianRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRemoteDebianRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class GetRemoteDockerRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[_builtins.bool]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[_builtins.bool]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[_builtins.bool]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[_builtins.bool]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    GetRemoteDockerRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRemoteDockerRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class GetRemoteGenericRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[_builtins.bool]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[_builtins.bool]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[_builtins.bool]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[_builtins.bool]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    GetRemoteGenericRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRemoteGenericRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class GetRemoteGitlfsRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[_builtins.bool]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[_builtins.bool]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[_builtins.bool]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[_builtins.bool]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    GetRemoteGitlfsRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRemoteGitlfsRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class GetRemoteGoRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[_builtins.bool]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[_builtins.bool]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[_builtins.bool]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[_builtins.bool]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    GetRemoteGoRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRemoteGoRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class GetRemoteGradleRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[_builtins.bool]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[_builtins.bool]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[_builtins.bool]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[_builtins.bool]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    GetRemoteGradleRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRemoteGradleRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class GetRemoteHelmRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[_builtins.bool]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[_builtins.bool]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[_builtins.bool]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[_builtins.bool]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    GetRemoteHelmRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRemoteHelmRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class GetRemoteHelmociRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[_builtins.bool]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[_builtins.bool]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[_builtins.bool]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[_builtins.bool]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    GetRemoteHelmociRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRemoteHelmociRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class GetRemoteIvyRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[_builtins.bool]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[_builtins.bool]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[_builtins.bool]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[_builtins.bool]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    GetRemoteIvyRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRemoteIvyRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class GetRemoteMavenRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[_builtins.bool]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[_builtins.bool]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[_builtins.bool]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[_builtins.bool]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    GetRemoteMavenRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRemoteMavenRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class GetRemoteNpmRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[_builtins.bool]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[_builtins.bool]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[_builtins.bool]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[_builtins.bool]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    GetRemoteNpmRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRemoteNpmRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class GetRemoteNugetRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[_builtins.bool]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[_builtins.bool]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[_builtins.bool]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[_builtins.bool]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    GetRemoteNugetRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRemoteNugetRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class GetRemoteOciRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[_builtins.bool]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[_builtins.bool]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[_builtins.bool]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[_builtins.bool]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    GetRemoteOciRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRemoteOciRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class GetRemoteOpkgRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[_builtins.bool]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[_builtins.bool]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[_builtins.bool]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[_builtins.bool]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    GetRemoteOpkgRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRemoteOpkgRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class GetRemoteP2RepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[_builtins.bool]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[_builtins.bool]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[_builtins.bool]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[_builtins.bool]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    GetRemoteP2RepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRemoteP2RepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class GetRemotePubRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[_builtins.bool]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[_builtins.bool]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[_builtins.bool]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[_builtins.bool]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    GetRemotePubRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRemotePubRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class GetRemotePuppetRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[_builtins.bool]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[_builtins.bool]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[_builtins.bool]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[_builtins.bool]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    GetRemotePuppetRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRemotePuppetRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class GetRemotePypiRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[_builtins.bool]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[_builtins.bool]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[_builtins.bool]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[_builtins.bool]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    GetRemotePypiRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRemotePypiRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class GetRemoteRpmRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[_builtins.bool]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[_builtins.bool]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[_builtins.bool]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[_builtins.bool]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    GetRemoteRpmRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRemoteRpmRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class GetRemoteSbtRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[_builtins.bool]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[_builtins.bool]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[_builtins.bool]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[_builtins.bool]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    GetRemoteSbtRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRemoteSbtRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class GetRemoteSwiftRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[_builtins.bool]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[_builtins.bool]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[_builtins.bool]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[_builtins.bool]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    GetRemoteSwiftRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRemoteSwiftRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class GetRemoteTerraformRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[_builtins.bool]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[_builtins.bool]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[_builtins.bool]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[_builtins.bool]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    GetRemoteTerraformRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRemoteTerraformRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "statistics_enabled", value)


if not MYPY:
    class GetRemoteVcsRepositoryContentSynchronisationArgsDict(TypedDict):
        enabled: NotRequired[_builtins.bool]
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        properties_enabled: NotRequired[_builtins.bool]
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        source_origin_absence_detection: NotRequired[_builtins.bool]
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        statistics_enabled: NotRequired[_builtins.bool]
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
elif False:
    GetRemoteVcsRepositoryContentSynchronisationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRemoteVcsRepositoryContentSynchronisationArgs:
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 properties_enabled: Optional[_builtins.bool] = None,
                 source_origin_absence_detection: Optional[_builtins.bool] = None,
                 statistics_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        :param _builtins.bool properties_enabled: If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        :param _builtins.bool source_origin_absence_detection: If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        :param _builtins.bool statistics_enabled: If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if properties_enabled is not None:
            pulumi.set(__self__, "properties_enabled", properties_enabled)
        if source_origin_absence_detection is not None:
            pulumi.set(__self__, "source_origin_absence_detection", source_origin_absence_detection)
        if statistics_enabled is not None:
            pulumi.set(__self__, "statistics_enabled", statistics_enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Remote repository proxies a local or remote repository from another instance of Artifactory. Default value is 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="propertiesEnabled")
    def properties_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, properties for artifacts that have been cached in this repository will be updated if they are modified in the artifact hosted at the remote Artifactory instance. The trigger to synchronize the properties is download of the artifact from the remote repository cache of the local Artifactory instance. Default value is 'false'.
        """
        return pulumi.get(self, "properties_enabled")

    @properties_enabled.setter
    def properties_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "properties_enabled", value)

    @_builtins.property
    @pulumi.getter(name="sourceOriginAbsenceDetection")
    def source_origin_absence_detection(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory displays an indication on cached items if they have been deleted from the corresponding repository in the remote Artifactory instance. Default value is 'false'
        """
        return pulumi.get(self, "source_origin_absence_detection")

    @source_origin_absence_detection.setter
    def source_origin_absence_detection(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "source_origin_absence_detection", value)

    @_builtins.property
    @pulumi.getter(name="statisticsEnabled")
    def statistics_enabled(self) -> Optional[_builtins.bool]:
        """
        If set, Artifactory will notify the remote instance whenever an artifact in the Smart Remote Repository is downloaded locally so that it can update its download counter. Note that if this option is not set, there may be a discrepancy between the number of artifacts reported to have been downloaded in the different Artifactory instances of the proxy chain. Default value is 'false'.
        """
        return pulumi.get(self, "statistics_enabled")

    @statistics_enabled.setter
    def statistics_enabled(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "statistics_enabled", value)


