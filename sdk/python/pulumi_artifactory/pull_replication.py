# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities

__all__ = ['PullReplicationArgs', 'PullReplication']

@pulumi.input_type
class PullReplicationArgs:
    def __init__(__self__, *,
                 repo_key: pulumi.Input[str],
                 check_binary_existence_in_filestore: Optional[pulumi.Input[bool]] = None,
                 cron_exp: Optional[pulumi.Input[str]] = None,
                 enable_event_replication: Optional[pulumi.Input[bool]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 path_prefix: Optional[pulumi.Input[str]] = None,
                 proxy: Optional[pulumi.Input[str]] = None,
                 socket_timeout_millis: Optional[pulumi.Input[int]] = None,
                 sync_deletes: Optional[pulumi.Input[bool]] = None,
                 sync_properties: Optional[pulumi.Input[bool]] = None,
                 sync_statistics: Optional[pulumi.Input[bool]] = None,
                 url: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        The set of arguments for constructing a PullReplication resource.
        :param pulumi.Input[str] repo_key: Repository name.
        :param pulumi.Input[bool] check_binary_existence_in_filestore: When true, enables distributed checksum storage. For more information, see
               [Optimizing Repository Replication with Checksum-Based Storage](https://www.jfrog.com/confluence/display/JFROG/Repository+Replication#RepositoryReplication-OptimizingRepositoryReplicationUsingStorageLevelSynchronizationOptions).
        :param pulumi.Input[str] cron_exp: A valid CRON expression that you can use to control replication frequency. Eg: `0 0 12 * * ? *`, `0 0 2 ? * MON-SAT *`. Note: use 6 or 7 parts format - Seconds, Minutes Hours, Day Of Month, Month, Day Of Week, Year (optional). Specifying both a day-of-week AND a day-of-month parameter is not supported. One of them should be replaced by `?`. Incorrect: `* 5,7,9 14/2 * * WED,SAT *`, correct: `* 5,7,9 14/2 ? * WED,SAT *`. See details in [Cron Trigger Tutorial](http://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html).
        :param pulumi.Input[bool] enable_event_replication: When set, each event will trigger replication of the artifacts changed in this event. This can be any type of event on artifact, e.g. added, deleted or property change.
        :param pulumi.Input[bool] enabled: When set, this replication will be enabled when saved.
        :param pulumi.Input[str] password: Required for local repository, but not needed for remote repository.
        :param pulumi.Input[str] path_prefix: Only artifacts that located in path that matches the subpath within the remote repository will be replicated.
        :param pulumi.Input[str] proxy: Proxy key from Artifactory Proxies setting
        :param pulumi.Input[bool] sync_deletes: When set, items that were deleted locally should also be deleted remotely (also applies to properties metadata).
        :param pulumi.Input[bool] sync_properties: When set, the task also synchronizes the properties of replicated artifacts.
        :param pulumi.Input[bool] sync_statistics: When set, artifact download statistics will also be replicated. Set to avoid inadvertent cleanup at the target instance when setting up replication for disaster recovery.
        :param pulumi.Input[str] url: The URL of the target local repository on a remote Artifactory server. For some package types, you need to prefix the repository key in the URL with api/<pkg>. 
               For a list of package types where this is required, see the [note](https://www.jfrog.com/confluence/display/JFROG/Repository+Replication#RepositoryReplication-anchorPREFIX).
               Required for local repository, but not needed for remote repository.
        :param pulumi.Input[str] username: Required for local repository, but not needed for remote repository.
        """
        pulumi.set(__self__, "repo_key", repo_key)
        if check_binary_existence_in_filestore is not None:
            pulumi.set(__self__, "check_binary_existence_in_filestore", check_binary_existence_in_filestore)
        if cron_exp is not None:
            pulumi.set(__self__, "cron_exp", cron_exp)
        if enable_event_replication is not None:
            pulumi.set(__self__, "enable_event_replication", enable_event_replication)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if path_prefix is not None:
            pulumi.set(__self__, "path_prefix", path_prefix)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if socket_timeout_millis is not None:
            pulumi.set(__self__, "socket_timeout_millis", socket_timeout_millis)
        if sync_deletes is not None:
            pulumi.set(__self__, "sync_deletes", sync_deletes)
        if sync_properties is not None:
            pulumi.set(__self__, "sync_properties", sync_properties)
        if sync_statistics is not None:
            pulumi.set(__self__, "sync_statistics", sync_statistics)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="repoKey")
    def repo_key(self) -> pulumi.Input[str]:
        """
        Repository name.
        """
        return pulumi.get(self, "repo_key")

    @repo_key.setter
    def repo_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "repo_key", value)

    @property
    @pulumi.getter(name="checkBinaryExistenceInFilestore")
    def check_binary_existence_in_filestore(self) -> Optional[pulumi.Input[bool]]:
        """
        When true, enables distributed checksum storage. For more information, see
        [Optimizing Repository Replication with Checksum-Based Storage](https://www.jfrog.com/confluence/display/JFROG/Repository+Replication#RepositoryReplication-OptimizingRepositoryReplicationUsingStorageLevelSynchronizationOptions).
        """
        return pulumi.get(self, "check_binary_existence_in_filestore")

    @check_binary_existence_in_filestore.setter
    def check_binary_existence_in_filestore(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "check_binary_existence_in_filestore", value)

    @property
    @pulumi.getter(name="cronExp")
    def cron_exp(self) -> Optional[pulumi.Input[str]]:
        """
        A valid CRON expression that you can use to control replication frequency. Eg: `0 0 12 * * ? *`, `0 0 2 ? * MON-SAT *`. Note: use 6 or 7 parts format - Seconds, Minutes Hours, Day Of Month, Month, Day Of Week, Year (optional). Specifying both a day-of-week AND a day-of-month parameter is not supported. One of them should be replaced by `?`. Incorrect: `* 5,7,9 14/2 * * WED,SAT *`, correct: `* 5,7,9 14/2 ? * WED,SAT *`. See details in [Cron Trigger Tutorial](http://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html).
        """
        return pulumi.get(self, "cron_exp")

    @cron_exp.setter
    def cron_exp(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cron_exp", value)

    @property
    @pulumi.getter(name="enableEventReplication")
    def enable_event_replication(self) -> Optional[pulumi.Input[bool]]:
        """
        When set, each event will trigger replication of the artifacts changed in this event. This can be any type of event on artifact, e.g. added, deleted or property change.
        """
        return pulumi.get(self, "enable_event_replication")

    @enable_event_replication.setter
    def enable_event_replication(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_event_replication", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        When set, this replication will be enabled when saved.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        Required for local repository, but not needed for remote repository.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="pathPrefix")
    def path_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Only artifacts that located in path that matches the subpath within the remote repository will be replicated.
        """
        return pulumi.get(self, "path_prefix")

    @path_prefix.setter
    def path_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path_prefix", value)

    @property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[str]]:
        """
        Proxy key from Artifactory Proxies setting
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy", value)

    @property
    @pulumi.getter(name="socketTimeoutMillis")
    def socket_timeout_millis(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "socket_timeout_millis")

    @socket_timeout_millis.setter
    def socket_timeout_millis(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "socket_timeout_millis", value)

    @property
    @pulumi.getter(name="syncDeletes")
    def sync_deletes(self) -> Optional[pulumi.Input[bool]]:
        """
        When set, items that were deleted locally should also be deleted remotely (also applies to properties metadata).
        """
        return pulumi.get(self, "sync_deletes")

    @sync_deletes.setter
    def sync_deletes(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sync_deletes", value)

    @property
    @pulumi.getter(name="syncProperties")
    def sync_properties(self) -> Optional[pulumi.Input[bool]]:
        """
        When set, the task also synchronizes the properties of replicated artifacts.
        """
        return pulumi.get(self, "sync_properties")

    @sync_properties.setter
    def sync_properties(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sync_properties", value)

    @property
    @pulumi.getter(name="syncStatistics")
    def sync_statistics(self) -> Optional[pulumi.Input[bool]]:
        """
        When set, artifact download statistics will also be replicated. Set to avoid inadvertent cleanup at the target instance when setting up replication for disaster recovery.
        """
        return pulumi.get(self, "sync_statistics")

    @sync_statistics.setter
    def sync_statistics(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sync_statistics", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the target local repository on a remote Artifactory server. For some package types, you need to prefix the repository key in the URL with api/<pkg>. 
        For a list of package types where this is required, see the [note](https://www.jfrog.com/confluence/display/JFROG/Repository+Replication#RepositoryReplication-anchorPREFIX).
        Required for local repository, but not needed for remote repository.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        Required for local repository, but not needed for remote repository.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class _PullReplicationState:
    def __init__(__self__, *,
                 check_binary_existence_in_filestore: Optional[pulumi.Input[bool]] = None,
                 cron_exp: Optional[pulumi.Input[str]] = None,
                 enable_event_replication: Optional[pulumi.Input[bool]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 path_prefix: Optional[pulumi.Input[str]] = None,
                 proxy: Optional[pulumi.Input[str]] = None,
                 repo_key: Optional[pulumi.Input[str]] = None,
                 socket_timeout_millis: Optional[pulumi.Input[int]] = None,
                 sync_deletes: Optional[pulumi.Input[bool]] = None,
                 sync_properties: Optional[pulumi.Input[bool]] = None,
                 sync_statistics: Optional[pulumi.Input[bool]] = None,
                 url: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        Input properties used for looking up and filtering PullReplication resources.
        :param pulumi.Input[bool] check_binary_existence_in_filestore: When true, enables distributed checksum storage. For more information, see
               [Optimizing Repository Replication with Checksum-Based Storage](https://www.jfrog.com/confluence/display/JFROG/Repository+Replication#RepositoryReplication-OptimizingRepositoryReplicationUsingStorageLevelSynchronizationOptions).
        :param pulumi.Input[str] cron_exp: A valid CRON expression that you can use to control replication frequency. Eg: `0 0 12 * * ? *`, `0 0 2 ? * MON-SAT *`. Note: use 6 or 7 parts format - Seconds, Minutes Hours, Day Of Month, Month, Day Of Week, Year (optional). Specifying both a day-of-week AND a day-of-month parameter is not supported. One of them should be replaced by `?`. Incorrect: `* 5,7,9 14/2 * * WED,SAT *`, correct: `* 5,7,9 14/2 ? * WED,SAT *`. See details in [Cron Trigger Tutorial](http://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html).
        :param pulumi.Input[bool] enable_event_replication: When set, each event will trigger replication of the artifacts changed in this event. This can be any type of event on artifact, e.g. added, deleted or property change.
        :param pulumi.Input[bool] enabled: When set, this replication will be enabled when saved.
        :param pulumi.Input[str] password: Required for local repository, but not needed for remote repository.
        :param pulumi.Input[str] path_prefix: Only artifacts that located in path that matches the subpath within the remote repository will be replicated.
        :param pulumi.Input[str] proxy: Proxy key from Artifactory Proxies setting
        :param pulumi.Input[str] repo_key: Repository name.
        :param pulumi.Input[bool] sync_deletes: When set, items that were deleted locally should also be deleted remotely (also applies to properties metadata).
        :param pulumi.Input[bool] sync_properties: When set, the task also synchronizes the properties of replicated artifacts.
        :param pulumi.Input[bool] sync_statistics: When set, artifact download statistics will also be replicated. Set to avoid inadvertent cleanup at the target instance when setting up replication for disaster recovery.
        :param pulumi.Input[str] url: The URL of the target local repository on a remote Artifactory server. For some package types, you need to prefix the repository key in the URL with api/<pkg>. 
               For a list of package types where this is required, see the [note](https://www.jfrog.com/confluence/display/JFROG/Repository+Replication#RepositoryReplication-anchorPREFIX).
               Required for local repository, but not needed for remote repository.
        :param pulumi.Input[str] username: Required for local repository, but not needed for remote repository.
        """
        if check_binary_existence_in_filestore is not None:
            pulumi.set(__self__, "check_binary_existence_in_filestore", check_binary_existence_in_filestore)
        if cron_exp is not None:
            pulumi.set(__self__, "cron_exp", cron_exp)
        if enable_event_replication is not None:
            pulumi.set(__self__, "enable_event_replication", enable_event_replication)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if path_prefix is not None:
            pulumi.set(__self__, "path_prefix", path_prefix)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if repo_key is not None:
            pulumi.set(__self__, "repo_key", repo_key)
        if socket_timeout_millis is not None:
            pulumi.set(__self__, "socket_timeout_millis", socket_timeout_millis)
        if sync_deletes is not None:
            pulumi.set(__self__, "sync_deletes", sync_deletes)
        if sync_properties is not None:
            pulumi.set(__self__, "sync_properties", sync_properties)
        if sync_statistics is not None:
            pulumi.set(__self__, "sync_statistics", sync_statistics)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="checkBinaryExistenceInFilestore")
    def check_binary_existence_in_filestore(self) -> Optional[pulumi.Input[bool]]:
        """
        When true, enables distributed checksum storage. For more information, see
        [Optimizing Repository Replication with Checksum-Based Storage](https://www.jfrog.com/confluence/display/JFROG/Repository+Replication#RepositoryReplication-OptimizingRepositoryReplicationUsingStorageLevelSynchronizationOptions).
        """
        return pulumi.get(self, "check_binary_existence_in_filestore")

    @check_binary_existence_in_filestore.setter
    def check_binary_existence_in_filestore(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "check_binary_existence_in_filestore", value)

    @property
    @pulumi.getter(name="cronExp")
    def cron_exp(self) -> Optional[pulumi.Input[str]]:
        """
        A valid CRON expression that you can use to control replication frequency. Eg: `0 0 12 * * ? *`, `0 0 2 ? * MON-SAT *`. Note: use 6 or 7 parts format - Seconds, Minutes Hours, Day Of Month, Month, Day Of Week, Year (optional). Specifying both a day-of-week AND a day-of-month parameter is not supported. One of them should be replaced by `?`. Incorrect: `* 5,7,9 14/2 * * WED,SAT *`, correct: `* 5,7,9 14/2 ? * WED,SAT *`. See details in [Cron Trigger Tutorial](http://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html).
        """
        return pulumi.get(self, "cron_exp")

    @cron_exp.setter
    def cron_exp(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cron_exp", value)

    @property
    @pulumi.getter(name="enableEventReplication")
    def enable_event_replication(self) -> Optional[pulumi.Input[bool]]:
        """
        When set, each event will trigger replication of the artifacts changed in this event. This can be any type of event on artifact, e.g. added, deleted or property change.
        """
        return pulumi.get(self, "enable_event_replication")

    @enable_event_replication.setter
    def enable_event_replication(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_event_replication", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        When set, this replication will be enabled when saved.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        Required for local repository, but not needed for remote repository.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="pathPrefix")
    def path_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Only artifacts that located in path that matches the subpath within the remote repository will be replicated.
        """
        return pulumi.get(self, "path_prefix")

    @path_prefix.setter
    def path_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path_prefix", value)

    @property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[str]]:
        """
        Proxy key from Artifactory Proxies setting
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy", value)

    @property
    @pulumi.getter(name="repoKey")
    def repo_key(self) -> Optional[pulumi.Input[str]]:
        """
        Repository name.
        """
        return pulumi.get(self, "repo_key")

    @repo_key.setter
    def repo_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo_key", value)

    @property
    @pulumi.getter(name="socketTimeoutMillis")
    def socket_timeout_millis(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "socket_timeout_millis")

    @socket_timeout_millis.setter
    def socket_timeout_millis(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "socket_timeout_millis", value)

    @property
    @pulumi.getter(name="syncDeletes")
    def sync_deletes(self) -> Optional[pulumi.Input[bool]]:
        """
        When set, items that were deleted locally should also be deleted remotely (also applies to properties metadata).
        """
        return pulumi.get(self, "sync_deletes")

    @sync_deletes.setter
    def sync_deletes(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sync_deletes", value)

    @property
    @pulumi.getter(name="syncProperties")
    def sync_properties(self) -> Optional[pulumi.Input[bool]]:
        """
        When set, the task also synchronizes the properties of replicated artifacts.
        """
        return pulumi.get(self, "sync_properties")

    @sync_properties.setter
    def sync_properties(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sync_properties", value)

    @property
    @pulumi.getter(name="syncStatistics")
    def sync_statistics(self) -> Optional[pulumi.Input[bool]]:
        """
        When set, artifact download statistics will also be replicated. Set to avoid inadvertent cleanup at the target instance when setting up replication for disaster recovery.
        """
        return pulumi.get(self, "sync_statistics")

    @sync_statistics.setter
    def sync_statistics(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sync_statistics", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the target local repository on a remote Artifactory server. For some package types, you need to prefix the repository key in the URL with api/<pkg>. 
        For a list of package types where this is required, see the [note](https://www.jfrog.com/confluence/display/JFROG/Repository+Replication#RepositoryReplication-anchorPREFIX).
        Required for local repository, but not needed for remote repository.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        Required for local repository, but not needed for remote repository.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


class PullReplication(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 check_binary_existence_in_filestore: Optional[pulumi.Input[bool]] = None,
                 cron_exp: Optional[pulumi.Input[str]] = None,
                 enable_event_replication: Optional[pulumi.Input[bool]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 path_prefix: Optional[pulumi.Input[str]] = None,
                 proxy: Optional[pulumi.Input[str]] = None,
                 repo_key: Optional[pulumi.Input[str]] = None,
                 socket_timeout_millis: Optional[pulumi.Input[int]] = None,
                 sync_deletes: Optional[pulumi.Input[bool]] = None,
                 sync_properties: Optional[pulumi.Input[bool]] = None,
                 sync_statistics: Optional[pulumi.Input[bool]] = None,
                 url: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None,
                 __props__=None):
        """
        > This resource is deprecated and replaced by `RemoteRepositoryReplication` for clarity.

        Provides an Artifactory pull replication resource. This can be used to create and manage pull replication in Artifactory for a local or remote repo. Pull replication provides a convenient way to proactively populate a remote cache, and is very useful when waiting for new artifacts to arrive on demand (when first requested) is not desirable due to network latency.

        See the [Official Documentation](https://www.jfrog.com/confluence/display/JFROG/Repository+Replication#RepositoryReplication-PullReplication).

        ## Example Usage

        <!--Start PulumiCodeChooser -->
        ```python
        import pulumi
        import pulumi_artifactory as artifactory

        # Create a replication between two artifactory local repositories
        provider_test_source = artifactory.LocalMavenRepository("providerTestSource", key="provider_test_source")
        provider_test_dest = artifactory.RemoteMavenRepository("providerTestDest",
            key="provider_test_dest",
            password="bar",
            url=f"https://example.com/artifactory/{artifactory_local_maven_repository['artifactory_local_maven_repository']['key']}",
            username="foo")
        remote_rep = artifactory.PullReplication("remote-rep",
            cron_exp="0 0 * * * ?",
            enable_event_replication=True,
            repo_key=provider_test_dest.key)
        ```
        <!--End PulumiCodeChooser -->

        ## Import

        Pull replication config can be imported using its repo key, e.g.

        ```sh
        $ pulumi import artifactory:index/pullReplication:PullReplication foo-rep repository-key
        ```

        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[bool] check_binary_existence_in_filestore: When true, enables distributed checksum storage. For more information, see
               [Optimizing Repository Replication with Checksum-Based Storage](https://www.jfrog.com/confluence/display/JFROG/Repository+Replication#RepositoryReplication-OptimizingRepositoryReplicationUsingStorageLevelSynchronizationOptions).
        :param pulumi.Input[str] cron_exp: A valid CRON expression that you can use to control replication frequency. Eg: `0 0 12 * * ? *`, `0 0 2 ? * MON-SAT *`. Note: use 6 or 7 parts format - Seconds, Minutes Hours, Day Of Month, Month, Day Of Week, Year (optional). Specifying both a day-of-week AND a day-of-month parameter is not supported. One of them should be replaced by `?`. Incorrect: `* 5,7,9 14/2 * * WED,SAT *`, correct: `* 5,7,9 14/2 ? * WED,SAT *`. See details in [Cron Trigger Tutorial](http://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html).
        :param pulumi.Input[bool] enable_event_replication: When set, each event will trigger replication of the artifacts changed in this event. This can be any type of event on artifact, e.g. added, deleted or property change.
        :param pulumi.Input[bool] enabled: When set, this replication will be enabled when saved.
        :param pulumi.Input[str] password: Required for local repository, but not needed for remote repository.
        :param pulumi.Input[str] path_prefix: Only artifacts that located in path that matches the subpath within the remote repository will be replicated.
        :param pulumi.Input[str] proxy: Proxy key from Artifactory Proxies setting
        :param pulumi.Input[str] repo_key: Repository name.
        :param pulumi.Input[bool] sync_deletes: When set, items that were deleted locally should also be deleted remotely (also applies to properties metadata).
        :param pulumi.Input[bool] sync_properties: When set, the task also synchronizes the properties of replicated artifacts.
        :param pulumi.Input[bool] sync_statistics: When set, artifact download statistics will also be replicated. Set to avoid inadvertent cleanup at the target instance when setting up replication for disaster recovery.
        :param pulumi.Input[str] url: The URL of the target local repository on a remote Artifactory server. For some package types, you need to prefix the repository key in the URL with api/<pkg>. 
               For a list of package types where this is required, see the [note](https://www.jfrog.com/confluence/display/JFROG/Repository+Replication#RepositoryReplication-anchorPREFIX).
               Required for local repository, but not needed for remote repository.
        :param pulumi.Input[str] username: Required for local repository, but not needed for remote repository.
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: PullReplicationArgs,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        > This resource is deprecated and replaced by `RemoteRepositoryReplication` for clarity.

        Provides an Artifactory pull replication resource. This can be used to create and manage pull replication in Artifactory for a local or remote repo. Pull replication provides a convenient way to proactively populate a remote cache, and is very useful when waiting for new artifacts to arrive on demand (when first requested) is not desirable due to network latency.

        See the [Official Documentation](https://www.jfrog.com/confluence/display/JFROG/Repository+Replication#RepositoryReplication-PullReplication).

        ## Example Usage

        <!--Start PulumiCodeChooser -->
        ```python
        import pulumi
        import pulumi_artifactory as artifactory

        # Create a replication between two artifactory local repositories
        provider_test_source = artifactory.LocalMavenRepository("providerTestSource", key="provider_test_source")
        provider_test_dest = artifactory.RemoteMavenRepository("providerTestDest",
            key="provider_test_dest",
            password="bar",
            url=f"https://example.com/artifactory/{artifactory_local_maven_repository['artifactory_local_maven_repository']['key']}",
            username="foo")
        remote_rep = artifactory.PullReplication("remote-rep",
            cron_exp="0 0 * * * ?",
            enable_event_replication=True,
            repo_key=provider_test_dest.key)
        ```
        <!--End PulumiCodeChooser -->

        ## Import

        Pull replication config can be imported using its repo key, e.g.

        ```sh
        $ pulumi import artifactory:index/pullReplication:PullReplication foo-rep repository-key
        ```

        :param str resource_name: The name of the resource.
        :param PullReplicationArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(PullReplicationArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 check_binary_existence_in_filestore: Optional[pulumi.Input[bool]] = None,
                 cron_exp: Optional[pulumi.Input[str]] = None,
                 enable_event_replication: Optional[pulumi.Input[bool]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 path_prefix: Optional[pulumi.Input[str]] = None,
                 proxy: Optional[pulumi.Input[str]] = None,
                 repo_key: Optional[pulumi.Input[str]] = None,
                 socket_timeout_millis: Optional[pulumi.Input[int]] = None,
                 sync_deletes: Optional[pulumi.Input[bool]] = None,
                 sync_properties: Optional[pulumi.Input[bool]] = None,
                 sync_statistics: Optional[pulumi.Input[bool]] = None,
                 url: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = PullReplicationArgs.__new__(PullReplicationArgs)

            __props__.__dict__["check_binary_existence_in_filestore"] = check_binary_existence_in_filestore
            __props__.__dict__["cron_exp"] = cron_exp
            __props__.__dict__["enable_event_replication"] = enable_event_replication
            __props__.__dict__["enabled"] = enabled
            __props__.__dict__["password"] = None if password is None else pulumi.Output.secret(password)
            __props__.__dict__["path_prefix"] = path_prefix
            __props__.__dict__["proxy"] = proxy
            if repo_key is None and not opts.urn:
                raise TypeError("Missing required property 'repo_key'")
            __props__.__dict__["repo_key"] = repo_key
            __props__.__dict__["socket_timeout_millis"] = socket_timeout_millis
            __props__.__dict__["sync_deletes"] = sync_deletes
            __props__.__dict__["sync_properties"] = sync_properties
            __props__.__dict__["sync_statistics"] = sync_statistics
            __props__.__dict__["url"] = url
            __props__.__dict__["username"] = username
        secret_opts = pulumi.ResourceOptions(additional_secret_outputs=["password"])
        opts = pulumi.ResourceOptions.merge(opts, secret_opts)
        super(PullReplication, __self__).__init__(
            'artifactory:index/pullReplication:PullReplication',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            check_binary_existence_in_filestore: Optional[pulumi.Input[bool]] = None,
            cron_exp: Optional[pulumi.Input[str]] = None,
            enable_event_replication: Optional[pulumi.Input[bool]] = None,
            enabled: Optional[pulumi.Input[bool]] = None,
            password: Optional[pulumi.Input[str]] = None,
            path_prefix: Optional[pulumi.Input[str]] = None,
            proxy: Optional[pulumi.Input[str]] = None,
            repo_key: Optional[pulumi.Input[str]] = None,
            socket_timeout_millis: Optional[pulumi.Input[int]] = None,
            sync_deletes: Optional[pulumi.Input[bool]] = None,
            sync_properties: Optional[pulumi.Input[bool]] = None,
            sync_statistics: Optional[pulumi.Input[bool]] = None,
            url: Optional[pulumi.Input[str]] = None,
            username: Optional[pulumi.Input[str]] = None) -> 'PullReplication':
        """
        Get an existing PullReplication resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[bool] check_binary_existence_in_filestore: When true, enables distributed checksum storage. For more information, see
               [Optimizing Repository Replication with Checksum-Based Storage](https://www.jfrog.com/confluence/display/JFROG/Repository+Replication#RepositoryReplication-OptimizingRepositoryReplicationUsingStorageLevelSynchronizationOptions).
        :param pulumi.Input[str] cron_exp: A valid CRON expression that you can use to control replication frequency. Eg: `0 0 12 * * ? *`, `0 0 2 ? * MON-SAT *`. Note: use 6 or 7 parts format - Seconds, Minutes Hours, Day Of Month, Month, Day Of Week, Year (optional). Specifying both a day-of-week AND a day-of-month parameter is not supported. One of them should be replaced by `?`. Incorrect: `* 5,7,9 14/2 * * WED,SAT *`, correct: `* 5,7,9 14/2 ? * WED,SAT *`. See details in [Cron Trigger Tutorial](http://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html).
        :param pulumi.Input[bool] enable_event_replication: When set, each event will trigger replication of the artifacts changed in this event. This can be any type of event on artifact, e.g. added, deleted or property change.
        :param pulumi.Input[bool] enabled: When set, this replication will be enabled when saved.
        :param pulumi.Input[str] password: Required for local repository, but not needed for remote repository.
        :param pulumi.Input[str] path_prefix: Only artifacts that located in path that matches the subpath within the remote repository will be replicated.
        :param pulumi.Input[str] proxy: Proxy key from Artifactory Proxies setting
        :param pulumi.Input[str] repo_key: Repository name.
        :param pulumi.Input[bool] sync_deletes: When set, items that were deleted locally should also be deleted remotely (also applies to properties metadata).
        :param pulumi.Input[bool] sync_properties: When set, the task also synchronizes the properties of replicated artifacts.
        :param pulumi.Input[bool] sync_statistics: When set, artifact download statistics will also be replicated. Set to avoid inadvertent cleanup at the target instance when setting up replication for disaster recovery.
        :param pulumi.Input[str] url: The URL of the target local repository on a remote Artifactory server. For some package types, you need to prefix the repository key in the URL with api/<pkg>. 
               For a list of package types where this is required, see the [note](https://www.jfrog.com/confluence/display/JFROG/Repository+Replication#RepositoryReplication-anchorPREFIX).
               Required for local repository, but not needed for remote repository.
        :param pulumi.Input[str] username: Required for local repository, but not needed for remote repository.
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _PullReplicationState.__new__(_PullReplicationState)

        __props__.__dict__["check_binary_existence_in_filestore"] = check_binary_existence_in_filestore
        __props__.__dict__["cron_exp"] = cron_exp
        __props__.__dict__["enable_event_replication"] = enable_event_replication
        __props__.__dict__["enabled"] = enabled
        __props__.__dict__["password"] = password
        __props__.__dict__["path_prefix"] = path_prefix
        __props__.__dict__["proxy"] = proxy
        __props__.__dict__["repo_key"] = repo_key
        __props__.__dict__["socket_timeout_millis"] = socket_timeout_millis
        __props__.__dict__["sync_deletes"] = sync_deletes
        __props__.__dict__["sync_properties"] = sync_properties
        __props__.__dict__["sync_statistics"] = sync_statistics
        __props__.__dict__["url"] = url
        __props__.__dict__["username"] = username
        return PullReplication(resource_name, opts=opts, __props__=__props__)

    @property
    @pulumi.getter(name="checkBinaryExistenceInFilestore")
    def check_binary_existence_in_filestore(self) -> pulumi.Output[Optional[bool]]:
        """
        When true, enables distributed checksum storage. For more information, see
        [Optimizing Repository Replication with Checksum-Based Storage](https://www.jfrog.com/confluence/display/JFROG/Repository+Replication#RepositoryReplication-OptimizingRepositoryReplicationUsingStorageLevelSynchronizationOptions).
        """
        return pulumi.get(self, "check_binary_existence_in_filestore")

    @property
    @pulumi.getter(name="cronExp")
    def cron_exp(self) -> pulumi.Output[Optional[str]]:
        """
        A valid CRON expression that you can use to control replication frequency. Eg: `0 0 12 * * ? *`, `0 0 2 ? * MON-SAT *`. Note: use 6 or 7 parts format - Seconds, Minutes Hours, Day Of Month, Month, Day Of Week, Year (optional). Specifying both a day-of-week AND a day-of-month parameter is not supported. One of them should be replaced by `?`. Incorrect: `* 5,7,9 14/2 * * WED,SAT *`, correct: `* 5,7,9 14/2 ? * WED,SAT *`. See details in [Cron Trigger Tutorial](http://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html).
        """
        return pulumi.get(self, "cron_exp")

    @property
    @pulumi.getter(name="enableEventReplication")
    def enable_event_replication(self) -> pulumi.Output[Optional[bool]]:
        """
        When set, each event will trigger replication of the artifacts changed in this event. This can be any type of event on artifact, e.g. added, deleted or property change.
        """
        return pulumi.get(self, "enable_event_replication")

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Output[bool]:
        """
        When set, this replication will be enabled when saved.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def password(self) -> pulumi.Output[Optional[str]]:
        """
        Required for local repository, but not needed for remote repository.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="pathPrefix")
    def path_prefix(self) -> pulumi.Output[Optional[str]]:
        """
        Only artifacts that located in path that matches the subpath within the remote repository will be replicated.
        """
        return pulumi.get(self, "path_prefix")

    @property
    @pulumi.getter
    def proxy(self) -> pulumi.Output[Optional[str]]:
        """
        Proxy key from Artifactory Proxies setting
        """
        return pulumi.get(self, "proxy")

    @property
    @pulumi.getter(name="repoKey")
    def repo_key(self) -> pulumi.Output[str]:
        """
        Repository name.
        """
        return pulumi.get(self, "repo_key")

    @property
    @pulumi.getter(name="socketTimeoutMillis")
    def socket_timeout_millis(self) -> pulumi.Output[int]:
        return pulumi.get(self, "socket_timeout_millis")

    @property
    @pulumi.getter(name="syncDeletes")
    def sync_deletes(self) -> pulumi.Output[bool]:
        """
        When set, items that were deleted locally should also be deleted remotely (also applies to properties metadata).
        """
        return pulumi.get(self, "sync_deletes")

    @property
    @pulumi.getter(name="syncProperties")
    def sync_properties(self) -> pulumi.Output[bool]:
        """
        When set, the task also synchronizes the properties of replicated artifacts.
        """
        return pulumi.get(self, "sync_properties")

    @property
    @pulumi.getter(name="syncStatistics")
    def sync_statistics(self) -> pulumi.Output[bool]:
        """
        When set, artifact download statistics will also be replicated. Set to avoid inadvertent cleanup at the target instance when setting up replication for disaster recovery.
        """
        return pulumi.get(self, "sync_statistics")

    @property
    @pulumi.getter
    def url(self) -> pulumi.Output[Optional[str]]:
        """
        The URL of the target local repository on a remote Artifactory server. For some package types, you need to prefix the repository key in the URL with api/<pkg>. 
        For a list of package types where this is required, see the [note](https://www.jfrog.com/confluence/display/JFROG/Repository+Replication#RepositoryReplication-anchorPREFIX).
        Required for local repository, but not needed for remote repository.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def username(self) -> pulumi.Output[Optional[str]]:
        """
        Required for local repository, but not needed for remote repository.
        """
        return pulumi.get(self, "username")

