# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs
from ._inputs import *

__all__ = ['PackageCleanupPolicyArgs', 'PackageCleanupPolicy']

@pulumi.input_type
class PackageCleanupPolicyArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 search_criteria: pulumi.Input['PackageCleanupPolicySearchCriteriaArgs'],
                 cron_expression: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 duration_in_minutes: Optional[pulumi.Input[_builtins.int]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 project_key: Optional[pulumi.Input[_builtins.str]] = None,
                 skip_trashcan: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        The set of arguments for constructing a PackageCleanupPolicy resource.
        :param pulumi.Input[_builtins.str] key: An ID that is used to identify the cleanup policy. A minimum of three characters is required and can include letters, numbers, underscore and hyphen.
        :param pulumi.Input[_builtins.str] cron_expression: The cron expression that determines when the policy is run, However if left empty the policy will not run automatically and can only be triggered manually.
        :param pulumi.Input[_builtins.int] duration_in_minutes: The maximum duration (in minutes) for policy execution, after which the policy will stop running even if not completed. While setting a maximum run duration for a policy is useful for adhering to a strict cleanup schedule, it can cause the policy to stop before completion.
        :param pulumi.Input[_builtins.bool] enabled: A cleanup policy must be created inactive. But if used it must be set to `false`. If set to `true` when calling this API, the API call will fail and an error message is received. Defaults to `true`
        :param pulumi.Input[_builtins.str] project_key: This attribute is used only for project-level cleanup policies, it is not used for global-level policies. When specified, the policy will be scoped to the specified project. Note: The policy `key` must start with this project key value as a prefix (e.g., if `project_key` is `"myproj"`, the `key` should be `"myproj-policy-name"`).
        :param pulumi.Input[_builtins.bool] skip_trashcan: A true value means that when this policy is executed, packages will be permanently deleted. false means that when the policy is executed packages will be deleted to the Trash Can. Defaults to `false`.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "search_criteria", search_criteria)
        if cron_expression is not None:
            pulumi.set(__self__, "cron_expression", cron_expression)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if duration_in_minutes is not None:
            pulumi.set(__self__, "duration_in_minutes", duration_in_minutes)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if project_key is not None:
            pulumi.set(__self__, "project_key", project_key)
        if skip_trashcan is not None:
            pulumi.set(__self__, "skip_trashcan", skip_trashcan)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        An ID that is used to identify the cleanup policy. A minimum of three characters is required and can include letters, numbers, underscore and hyphen.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="searchCriteria")
    def search_criteria(self) -> pulumi.Input['PackageCleanupPolicySearchCriteriaArgs']:
        return pulumi.get(self, "search_criteria")

    @search_criteria.setter
    def search_criteria(self, value: pulumi.Input['PackageCleanupPolicySearchCriteriaArgs']):
        pulumi.set(self, "search_criteria", value)

    @_builtins.property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The cron expression that determines when the policy is run, However if left empty the policy will not run automatically and can only be triggered manually.
        """
        return pulumi.get(self, "cron_expression")

    @cron_expression.setter
    def cron_expression(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cron_expression", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="durationInMinutes")
    def duration_in_minutes(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum duration (in minutes) for policy execution, after which the policy will stop running even if not completed. While setting a maximum run duration for a policy is useful for adhering to a strict cleanup schedule, it can cause the policy to stop before completion.
        """
        return pulumi.get(self, "duration_in_minutes")

    @duration_in_minutes.setter
    def duration_in_minutes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "duration_in_minutes", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        A cleanup policy must be created inactive. But if used it must be set to `false`. If set to `true` when calling this API, the API call will fail and an error message is received. Defaults to `true`
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="projectKey")
    def project_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        This attribute is used only for project-level cleanup policies, it is not used for global-level policies. When specified, the policy will be scoped to the specified project. Note: The policy `key` must start with this project key value as a prefix (e.g., if `project_key` is `"myproj"`, the `key` should be `"myproj-policy-name"`).
        """
        return pulumi.get(self, "project_key")

    @project_key.setter
    def project_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "project_key", value)

    @_builtins.property
    @pulumi.getter(name="skipTrashcan")
    def skip_trashcan(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        A true value means that when this policy is executed, packages will be permanently deleted. false means that when the policy is executed packages will be deleted to the Trash Can. Defaults to `false`.
        """
        return pulumi.get(self, "skip_trashcan")

    @skip_trashcan.setter
    def skip_trashcan(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "skip_trashcan", value)


@pulumi.input_type
class _PackageCleanupPolicyState:
    def __init__(__self__, *,
                 cron_expression: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 duration_in_minutes: Optional[pulumi.Input[_builtins.int]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 project_key: Optional[pulumi.Input[_builtins.str]] = None,
                 search_criteria: Optional[pulumi.Input['PackageCleanupPolicySearchCriteriaArgs']] = None,
                 skip_trashcan: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        Input properties used for looking up and filtering PackageCleanupPolicy resources.
        :param pulumi.Input[_builtins.str] cron_expression: The cron expression that determines when the policy is run, However if left empty the policy will not run automatically and can only be triggered manually.
        :param pulumi.Input[_builtins.int] duration_in_minutes: The maximum duration (in minutes) for policy execution, after which the policy will stop running even if not completed. While setting a maximum run duration for a policy is useful for adhering to a strict cleanup schedule, it can cause the policy to stop before completion.
        :param pulumi.Input[_builtins.bool] enabled: A cleanup policy must be created inactive. But if used it must be set to `false`. If set to `true` when calling this API, the API call will fail and an error message is received. Defaults to `true`
        :param pulumi.Input[_builtins.str] key: An ID that is used to identify the cleanup policy. A minimum of three characters is required and can include letters, numbers, underscore and hyphen.
        :param pulumi.Input[_builtins.str] project_key: This attribute is used only for project-level cleanup policies, it is not used for global-level policies. When specified, the policy will be scoped to the specified project. Note: The policy `key` must start with this project key value as a prefix (e.g., if `project_key` is `"myproj"`, the `key` should be `"myproj-policy-name"`).
        :param pulumi.Input[_builtins.bool] skip_trashcan: A true value means that when this policy is executed, packages will be permanently deleted. false means that when the policy is executed packages will be deleted to the Trash Can. Defaults to `false`.
        """
        if cron_expression is not None:
            pulumi.set(__self__, "cron_expression", cron_expression)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if duration_in_minutes is not None:
            pulumi.set(__self__, "duration_in_minutes", duration_in_minutes)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if project_key is not None:
            pulumi.set(__self__, "project_key", project_key)
        if search_criteria is not None:
            pulumi.set(__self__, "search_criteria", search_criteria)
        if skip_trashcan is not None:
            pulumi.set(__self__, "skip_trashcan", skip_trashcan)

    @_builtins.property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The cron expression that determines when the policy is run, However if left empty the policy will not run automatically and can only be triggered manually.
        """
        return pulumi.get(self, "cron_expression")

    @cron_expression.setter
    def cron_expression(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cron_expression", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="durationInMinutes")
    def duration_in_minutes(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum duration (in minutes) for policy execution, after which the policy will stop running even if not completed. While setting a maximum run duration for a policy is useful for adhering to a strict cleanup schedule, it can cause the policy to stop before completion.
        """
        return pulumi.get(self, "duration_in_minutes")

    @duration_in_minutes.setter
    def duration_in_minutes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "duration_in_minutes", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        A cleanup policy must be created inactive. But if used it must be set to `false`. If set to `true` when calling this API, the API call will fail and an error message is received. Defaults to `true`
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An ID that is used to identify the cleanup policy. A minimum of three characters is required and can include letters, numbers, underscore and hyphen.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="projectKey")
    def project_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        This attribute is used only for project-level cleanup policies, it is not used for global-level policies. When specified, the policy will be scoped to the specified project. Note: The policy `key` must start with this project key value as a prefix (e.g., if `project_key` is `"myproj"`, the `key` should be `"myproj-policy-name"`).
        """
        return pulumi.get(self, "project_key")

    @project_key.setter
    def project_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "project_key", value)

    @_builtins.property
    @pulumi.getter(name="searchCriteria")
    def search_criteria(self) -> Optional[pulumi.Input['PackageCleanupPolicySearchCriteriaArgs']]:
        return pulumi.get(self, "search_criteria")

    @search_criteria.setter
    def search_criteria(self, value: Optional[pulumi.Input['PackageCleanupPolicySearchCriteriaArgs']]):
        pulumi.set(self, "search_criteria", value)

    @_builtins.property
    @pulumi.getter(name="skipTrashcan")
    def skip_trashcan(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        A true value means that when this policy is executed, packages will be permanently deleted. false means that when the policy is executed packages will be deleted to the Trash Can. Defaults to `false`.
        """
        return pulumi.get(self, "skip_trashcan")

    @skip_trashcan.setter
    def skip_trashcan(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "skip_trashcan", value)


@pulumi.type_token("artifactory:index/packageCleanupPolicy:PackageCleanupPolicy")
class PackageCleanupPolicy(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 cron_expression: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 duration_in_minutes: Optional[pulumi.Input[_builtins.int]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 project_key: Optional[pulumi.Input[_builtins.str]] = None,
                 search_criteria: Optional[pulumi.Input[Union['PackageCleanupPolicySearchCriteriaArgs', 'PackageCleanupPolicySearchCriteriaArgsDict']]] = None,
                 skip_trashcan: Optional[pulumi.Input[_builtins.bool]] = None,
                 __props__=None):
        """
        Provides an Artifactory Package Cleanup Policy resource. This resource enable system administrators to define and customize policies based on specific criteria for removing unused binaries from across their JFrog platform. Package cleanup policies are supported on the Cloud (7.98.2) and Self-Hosted (7.98.7) platforms, with an Enterprise+ license. See [Cleanup Policies](https://jfrog.com/help/r/jfrog-platform-administration-documentation/cleanup-policies) for more details.

        ## Example Usage

        ### Time-based Cleanup Policy (Days)

        ```python
        import pulumi
        import pulumi_artifactory as artifactory

        my_cleanup_policy = artifactory.PackageCleanupPolicy("my-cleanup-policy",
            key="my-cleanup-policy",
            description="My cleanup policy",
            cron_expression="0 0 2 ? * MON-SAT *",
            duration_in_minutes=60,
            enabled=True,
            skip_trashcan=False,
            search_criteria={
                "package_types": [
                    "docker",
                    "gradle",
                    "maven",
                ],
                "repos": ["**"],
                "include_all_projects": True,
                "included_projects": [],
                "included_packages": ["**"],
                "excluded_packages": ["com/jfrog/latest"],
                "created_before_in_days": 30,
                "last_downloaded_before_in_days": 60,
            })
        ```

        ### Version-based Cleanup Policy

        ```python
        import pulumi
        import pulumi_artifactory as artifactory

        my_version_policy = artifactory.PackageCleanupPolicy("my-version-policy",
            key="my-version-policy",
            description="Keep only latest versions",
            cron_expression="0 0 2 ? * MON-SAT *",
            duration_in_minutes=60,
            enabled=True,
            skip_trashcan=False,
            search_criteria={
                "package_types": ["maven"],
                "repos": ["**"],
                "include_all_projects": True,
                "included_projects": [],
                "included_packages": ["**"],
                "excluded_packages": ["com/jfrog/latest"],
                "keep_last_n_versions": 5,
            })
        ```

        ### Properties-based Cleanup Policy

        ```python
        import pulumi
        import pulumi_artifactory as artifactory

        my_properties_policy = artifactory.PackageCleanupPolicy("my-properties-policy",
            key="my-properties-policy",
            description="Cleanup based on properties",
            cron_expression="0 0 2 ? * MON-SAT *",
            duration_in_minutes=60,
            enabled=True,
            skip_trashcan=False,
            search_criteria={
                "package_types": ["docker"],
                "repos": ["**"],
                "include_all_projects": True,
                "included_projects": [],
                "included_packages": ["**"],
                "excluded_packages": ["com/jfrog/latest"],
                "included_properties": {
                    "build.name": ["my-app"],
                },
            })
        ```

        ### Using Variables for Condition Fields

        You can use Terraform variables for condition fields (`created_before_in_days`, `last_downloaded_before_in_days`, `created_before_in_months`, `last_downloaded_before_in_months`, `keep_last_n_versions`, `included_properties`) and `duration_in_minutes`. The validator will skip validation when values are unknown (variables), allowing `terraform validate` to pass without requiring variable values.

        **Example with variables:**

        ```python
        import pulumi
        import pulumi_artifactory as artifactory

        config = pulumi.Config()
        cleanup_policy_last_downloaded_before_in_days = config.get_float("cleanupPolicyLastDownloadedBeforeInDays")
        if cleanup_policy_last_downloaded_before_in_days is None:
            cleanup_policy_last_downloaded_before_in_days = 60
        cleanup_policy_duration_in_minutes = config.get_float("cleanupPolicyDurationInMinutes")
        if cleanup_policy_duration_in_minutes is None:
            cleanup_policy_duration_in_minutes = 120
        my_cleanup_policy = artifactory.PackageCleanupPolicy("my-cleanup-policy",
            key="my-cleanup-policy",
            description="My cleanup policy with variables",
            cron_expression="0 0 2 ? * MON-SAT *",
            duration_in_minutes=cleanup_policy_duration_in_minutes,
            enabled=True,
            skip_trashcan=False,
            search_criteria={
                "package_types": [
                    "docker",
                    "generic",
                    "helm",
                    "helmoci",
                    "nuget",
                    "terraform",
                ],
                "repos": ["**"],
                "include_all_projects": False,
                "included_projects": ["default"],
                "included_packages": ["**"],
                "excluded_packages": ["com/jfrog/latest"],
                "last_downloaded_before_in_days": cleanup_policy_last_downloaded_before_in_days,
            })
        ```

        **Important Notes:**
        - Variables with default values allow `terraform validate` to pass without requiring variable values
        - Variables without default values will require values to be provided during `pulumi preview` or `pulumi up`
        - The validator automatically skips validation when condition field values are unknown (variables), preventing false validation errors during `terraform validate`

        ## Validation Rules

        The cleanup policy resource enforces the following validation rules:

        1. **Condition Types**: A policy must use exactly one of the following condition types:
           - Time-based conditions (`days-based`)
           - Version-based condition (`keep_last_n_versions`)
           - Properties-based condition (`included_properties`)

        2. **Mutual Exclusivity**: Cannot use multiple condition types together.

        3. **Zero Values**: Time-based and version-based conditions must have values greater than 0.

        4. **Days vs Months**: Cannot use both days-based conditions (`created_before_in_days`, `last_downloaded_before_in_days`) and months-based conditions (`created_before_in_months`, `last_downloaded_before_in_months`) together.

        5. **Properties Validation**: Properties-based conditions must have exactly one key with exactly one string value.

        6. **Project Configuration**: When `include_all_projects` is set to `true`, the `included_projects` field can be empty array. When `include_all_projects` is `false`, `included_projects` must contain at least one project key.

        7. **Project-level Policy Constraints**: When `project_key` is specified (project-level policy):
           - `include_all_projects` must be set to `false`
           - `included_projects` should be empty array `[]`
           - Policy `key` must start with the project key value as a prefix followed by a hyphen
             - ✅ Valid: `project_key = "myproj"` → `key = "myproj-cleanup-policy"`
             - ❌ Invalid: `project_key = "myproj"` → `key = "cleanup-policy"` (missing prefix)
             - ❌ Invalid: `project_key = "myproj"` → `key = "other-cleanup-policy"` (wrong prefix)

        ## Supported Package Types

        The following package types are supported for cleanup policies with their respective minimum Artifactory versions:

        - **alpine** - Alpine Linux packages (supported from 7.108.0)
        - **ansible** - Ansible collections and roles (supported from 7.104.2)
        - **cargo** - Rust Cargo packages (supported from 7.102.0)
        - **chef** - Chef cookbooks (supported from 7.112.0)
        - **cocoapods** - CocoaPods packages (supported from 7.99.1)
        - **composer** - PHP Composer packages (supported from 7.116.0)
        - **conan** - Conan C/C++ packages (supported from 7.98.2)
        - **conda** - Conda packages (supported from 7.105.2)
        - **debian** - Debian packages (supported from 7.98.2)
        - **docker** - Docker images (supported from 7.98.2, version-based condition (keep_last_n_versions) from 7.115.1)
        - **gems** - Ruby gems (supported from 7.96.3)
        - **generic** - Generic packages (supported from 7.98.2, version-based conditions is not supported)
        - **go** - Go modules (supported from 7.98.2)
        - **gradle** - Gradle packages (supported from 7.98.2)
        - **helm** - Helm charts (supported from 7.98.2)
        - **helmoci** - Helm OCI charts (supported from 7.102.0, version-based conditions (keep_last_n_versions) from 7.115.1)
        - **huggingfaceml** - Hugging Face ML models (supported from 7.100.0)
        - **machinelearning** - Machine learning models (supported from 7.104.2)
        - **maven** - Maven packages (supported from 7.98.2)
        - **npm** - Node.js packages (supported from 7.98.2)
        - **nuget** - .NET NuGet packages (supported from 7.98.2)
        - **oci** - OCI images (supported from 7.90.1, version-based conditions (keep_last_n_versions) from 7.115.1)
        - **puppet** - Puppet modules (supported from 7.112.0)
        - **pypi** - Python packages (supported from 7.98.2)
        - **rpm|yum** - RPM packages (supported from 7.98.2)
        - **sbt** - Scala SBT packages (supported from 7.108.0)
        - **swift** - Swift packages
        - **terraform** - Terraform modules (supported from 7.99.1)
        - **terraformbackend** - Terraform backend configurations (supported from 7.103.0)

        ## Version Compatibility

        - The `created_before_in_days` and `last_downloaded_before_in_days` attributes are only supported in Artifactory 7.111.2 and later. For earlier versions, use `created_before_in_months` and `last_downloaded_before_in_months`.

        ## Import

        ```sh
        $ pulumi import artifactory:index/packageCleanupPolicy:PackageCleanupPolicy my-cleanup-policy my-policy

        $ pulumi import artifactory:index/packageCleanupPolicy:PackageCleanupPolicy my-cleanup-policy my-policy:myproj
        ```

        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[_builtins.str] cron_expression: The cron expression that determines when the policy is run, However if left empty the policy will not run automatically and can only be triggered manually.
        :param pulumi.Input[_builtins.int] duration_in_minutes: The maximum duration (in minutes) for policy execution, after which the policy will stop running even if not completed. While setting a maximum run duration for a policy is useful for adhering to a strict cleanup schedule, it can cause the policy to stop before completion.
        :param pulumi.Input[_builtins.bool] enabled: A cleanup policy must be created inactive. But if used it must be set to `false`. If set to `true` when calling this API, the API call will fail and an error message is received. Defaults to `true`
        :param pulumi.Input[_builtins.str] key: An ID that is used to identify the cleanup policy. A minimum of three characters is required and can include letters, numbers, underscore and hyphen.
        :param pulumi.Input[_builtins.str] project_key: This attribute is used only for project-level cleanup policies, it is not used for global-level policies. When specified, the policy will be scoped to the specified project. Note: The policy `key` must start with this project key value as a prefix (e.g., if `project_key` is `"myproj"`, the `key` should be `"myproj-policy-name"`).
        :param pulumi.Input[_builtins.bool] skip_trashcan: A true value means that when this policy is executed, packages will be permanently deleted. false means that when the policy is executed packages will be deleted to the Trash Can. Defaults to `false`.
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: PackageCleanupPolicyArgs,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        Provides an Artifactory Package Cleanup Policy resource. This resource enable system administrators to define and customize policies based on specific criteria for removing unused binaries from across their JFrog platform. Package cleanup policies are supported on the Cloud (7.98.2) and Self-Hosted (7.98.7) platforms, with an Enterprise+ license. See [Cleanup Policies](https://jfrog.com/help/r/jfrog-platform-administration-documentation/cleanup-policies) for more details.

        ## Example Usage

        ### Time-based Cleanup Policy (Days)

        ```python
        import pulumi
        import pulumi_artifactory as artifactory

        my_cleanup_policy = artifactory.PackageCleanupPolicy("my-cleanup-policy",
            key="my-cleanup-policy",
            description="My cleanup policy",
            cron_expression="0 0 2 ? * MON-SAT *",
            duration_in_minutes=60,
            enabled=True,
            skip_trashcan=False,
            search_criteria={
                "package_types": [
                    "docker",
                    "gradle",
                    "maven",
                ],
                "repos": ["**"],
                "include_all_projects": True,
                "included_projects": [],
                "included_packages": ["**"],
                "excluded_packages": ["com/jfrog/latest"],
                "created_before_in_days": 30,
                "last_downloaded_before_in_days": 60,
            })
        ```

        ### Version-based Cleanup Policy

        ```python
        import pulumi
        import pulumi_artifactory as artifactory

        my_version_policy = artifactory.PackageCleanupPolicy("my-version-policy",
            key="my-version-policy",
            description="Keep only latest versions",
            cron_expression="0 0 2 ? * MON-SAT *",
            duration_in_minutes=60,
            enabled=True,
            skip_trashcan=False,
            search_criteria={
                "package_types": ["maven"],
                "repos": ["**"],
                "include_all_projects": True,
                "included_projects": [],
                "included_packages": ["**"],
                "excluded_packages": ["com/jfrog/latest"],
                "keep_last_n_versions": 5,
            })
        ```

        ### Properties-based Cleanup Policy

        ```python
        import pulumi
        import pulumi_artifactory as artifactory

        my_properties_policy = artifactory.PackageCleanupPolicy("my-properties-policy",
            key="my-properties-policy",
            description="Cleanup based on properties",
            cron_expression="0 0 2 ? * MON-SAT *",
            duration_in_minutes=60,
            enabled=True,
            skip_trashcan=False,
            search_criteria={
                "package_types": ["docker"],
                "repos": ["**"],
                "include_all_projects": True,
                "included_projects": [],
                "included_packages": ["**"],
                "excluded_packages": ["com/jfrog/latest"],
                "included_properties": {
                    "build.name": ["my-app"],
                },
            })
        ```

        ### Using Variables for Condition Fields

        You can use Terraform variables for condition fields (`created_before_in_days`, `last_downloaded_before_in_days`, `created_before_in_months`, `last_downloaded_before_in_months`, `keep_last_n_versions`, `included_properties`) and `duration_in_minutes`. The validator will skip validation when values are unknown (variables), allowing `terraform validate` to pass without requiring variable values.

        **Example with variables:**

        ```python
        import pulumi
        import pulumi_artifactory as artifactory

        config = pulumi.Config()
        cleanup_policy_last_downloaded_before_in_days = config.get_float("cleanupPolicyLastDownloadedBeforeInDays")
        if cleanup_policy_last_downloaded_before_in_days is None:
            cleanup_policy_last_downloaded_before_in_days = 60
        cleanup_policy_duration_in_minutes = config.get_float("cleanupPolicyDurationInMinutes")
        if cleanup_policy_duration_in_minutes is None:
            cleanup_policy_duration_in_minutes = 120
        my_cleanup_policy = artifactory.PackageCleanupPolicy("my-cleanup-policy",
            key="my-cleanup-policy",
            description="My cleanup policy with variables",
            cron_expression="0 0 2 ? * MON-SAT *",
            duration_in_minutes=cleanup_policy_duration_in_minutes,
            enabled=True,
            skip_trashcan=False,
            search_criteria={
                "package_types": [
                    "docker",
                    "generic",
                    "helm",
                    "helmoci",
                    "nuget",
                    "terraform",
                ],
                "repos": ["**"],
                "include_all_projects": False,
                "included_projects": ["default"],
                "included_packages": ["**"],
                "excluded_packages": ["com/jfrog/latest"],
                "last_downloaded_before_in_days": cleanup_policy_last_downloaded_before_in_days,
            })
        ```

        **Important Notes:**
        - Variables with default values allow `terraform validate` to pass without requiring variable values
        - Variables without default values will require values to be provided during `pulumi preview` or `pulumi up`
        - The validator automatically skips validation when condition field values are unknown (variables), preventing false validation errors during `terraform validate`

        ## Validation Rules

        The cleanup policy resource enforces the following validation rules:

        1. **Condition Types**: A policy must use exactly one of the following condition types:
           - Time-based conditions (`days-based`)
           - Version-based condition (`keep_last_n_versions`)
           - Properties-based condition (`included_properties`)

        2. **Mutual Exclusivity**: Cannot use multiple condition types together.

        3. **Zero Values**: Time-based and version-based conditions must have values greater than 0.

        4. **Days vs Months**: Cannot use both days-based conditions (`created_before_in_days`, `last_downloaded_before_in_days`) and months-based conditions (`created_before_in_months`, `last_downloaded_before_in_months`) together.

        5. **Properties Validation**: Properties-based conditions must have exactly one key with exactly one string value.

        6. **Project Configuration**: When `include_all_projects` is set to `true`, the `included_projects` field can be empty array. When `include_all_projects` is `false`, `included_projects` must contain at least one project key.

        7. **Project-level Policy Constraints**: When `project_key` is specified (project-level policy):
           - `include_all_projects` must be set to `false`
           - `included_projects` should be empty array `[]`
           - Policy `key` must start with the project key value as a prefix followed by a hyphen
             - ✅ Valid: `project_key = "myproj"` → `key = "myproj-cleanup-policy"`
             - ❌ Invalid: `project_key = "myproj"` → `key = "cleanup-policy"` (missing prefix)
             - ❌ Invalid: `project_key = "myproj"` → `key = "other-cleanup-policy"` (wrong prefix)

        ## Supported Package Types

        The following package types are supported for cleanup policies with their respective minimum Artifactory versions:

        - **alpine** - Alpine Linux packages (supported from 7.108.0)
        - **ansible** - Ansible collections and roles (supported from 7.104.2)
        - **cargo** - Rust Cargo packages (supported from 7.102.0)
        - **chef** - Chef cookbooks (supported from 7.112.0)
        - **cocoapods** - CocoaPods packages (supported from 7.99.1)
        - **composer** - PHP Composer packages (supported from 7.116.0)
        - **conan** - Conan C/C++ packages (supported from 7.98.2)
        - **conda** - Conda packages (supported from 7.105.2)
        - **debian** - Debian packages (supported from 7.98.2)
        - **docker** - Docker images (supported from 7.98.2, version-based condition (keep_last_n_versions) from 7.115.1)
        - **gems** - Ruby gems (supported from 7.96.3)
        - **generic** - Generic packages (supported from 7.98.2, version-based conditions is not supported)
        - **go** - Go modules (supported from 7.98.2)
        - **gradle** - Gradle packages (supported from 7.98.2)
        - **helm** - Helm charts (supported from 7.98.2)
        - **helmoci** - Helm OCI charts (supported from 7.102.0, version-based conditions (keep_last_n_versions) from 7.115.1)
        - **huggingfaceml** - Hugging Face ML models (supported from 7.100.0)
        - **machinelearning** - Machine learning models (supported from 7.104.2)
        - **maven** - Maven packages (supported from 7.98.2)
        - **npm** - Node.js packages (supported from 7.98.2)
        - **nuget** - .NET NuGet packages (supported from 7.98.2)
        - **oci** - OCI images (supported from 7.90.1, version-based conditions (keep_last_n_versions) from 7.115.1)
        - **puppet** - Puppet modules (supported from 7.112.0)
        - **pypi** - Python packages (supported from 7.98.2)
        - **rpm|yum** - RPM packages (supported from 7.98.2)
        - **sbt** - Scala SBT packages (supported from 7.108.0)
        - **swift** - Swift packages
        - **terraform** - Terraform modules (supported from 7.99.1)
        - **terraformbackend** - Terraform backend configurations (supported from 7.103.0)

        ## Version Compatibility

        - The `created_before_in_days` and `last_downloaded_before_in_days` attributes are only supported in Artifactory 7.111.2 and later. For earlier versions, use `created_before_in_months` and `last_downloaded_before_in_months`.

        ## Import

        ```sh
        $ pulumi import artifactory:index/packageCleanupPolicy:PackageCleanupPolicy my-cleanup-policy my-policy

        $ pulumi import artifactory:index/packageCleanupPolicy:PackageCleanupPolicy my-cleanup-policy my-policy:myproj
        ```

        :param str resource_name: The name of the resource.
        :param PackageCleanupPolicyArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(PackageCleanupPolicyArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 cron_expression: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 duration_in_minutes: Optional[pulumi.Input[_builtins.int]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 project_key: Optional[pulumi.Input[_builtins.str]] = None,
                 search_criteria: Optional[pulumi.Input[Union['PackageCleanupPolicySearchCriteriaArgs', 'PackageCleanupPolicySearchCriteriaArgsDict']]] = None,
                 skip_trashcan: Optional[pulumi.Input[_builtins.bool]] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = PackageCleanupPolicyArgs.__new__(PackageCleanupPolicyArgs)

            __props__.__dict__["cron_expression"] = cron_expression
            __props__.__dict__["description"] = description
            __props__.__dict__["duration_in_minutes"] = duration_in_minutes
            __props__.__dict__["enabled"] = enabled
            if key is None and not opts.urn:
                raise TypeError("Missing required property 'key'")
            __props__.__dict__["key"] = key
            __props__.__dict__["project_key"] = project_key
            if search_criteria is None and not opts.urn:
                raise TypeError("Missing required property 'search_criteria'")
            __props__.__dict__["search_criteria"] = search_criteria
            __props__.__dict__["skip_trashcan"] = skip_trashcan
        super(PackageCleanupPolicy, __self__).__init__(
            'artifactory:index/packageCleanupPolicy:PackageCleanupPolicy',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            cron_expression: Optional[pulumi.Input[_builtins.str]] = None,
            description: Optional[pulumi.Input[_builtins.str]] = None,
            duration_in_minutes: Optional[pulumi.Input[_builtins.int]] = None,
            enabled: Optional[pulumi.Input[_builtins.bool]] = None,
            key: Optional[pulumi.Input[_builtins.str]] = None,
            project_key: Optional[pulumi.Input[_builtins.str]] = None,
            search_criteria: Optional[pulumi.Input[Union['PackageCleanupPolicySearchCriteriaArgs', 'PackageCleanupPolicySearchCriteriaArgsDict']]] = None,
            skip_trashcan: Optional[pulumi.Input[_builtins.bool]] = None) -> 'PackageCleanupPolicy':
        """
        Get an existing PackageCleanupPolicy resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[_builtins.str] cron_expression: The cron expression that determines when the policy is run, However if left empty the policy will not run automatically and can only be triggered manually.
        :param pulumi.Input[_builtins.int] duration_in_minutes: The maximum duration (in minutes) for policy execution, after which the policy will stop running even if not completed. While setting a maximum run duration for a policy is useful for adhering to a strict cleanup schedule, it can cause the policy to stop before completion.
        :param pulumi.Input[_builtins.bool] enabled: A cleanup policy must be created inactive. But if used it must be set to `false`. If set to `true` when calling this API, the API call will fail and an error message is received. Defaults to `true`
        :param pulumi.Input[_builtins.str] key: An ID that is used to identify the cleanup policy. A minimum of three characters is required and can include letters, numbers, underscore and hyphen.
        :param pulumi.Input[_builtins.str] project_key: This attribute is used only for project-level cleanup policies, it is not used for global-level policies. When specified, the policy will be scoped to the specified project. Note: The policy `key` must start with this project key value as a prefix (e.g., if `project_key` is `"myproj"`, the `key` should be `"myproj-policy-name"`).
        :param pulumi.Input[_builtins.bool] skip_trashcan: A true value means that when this policy is executed, packages will be permanently deleted. false means that when the policy is executed packages will be deleted to the Trash Can. Defaults to `false`.
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _PackageCleanupPolicyState.__new__(_PackageCleanupPolicyState)

        __props__.__dict__["cron_expression"] = cron_expression
        __props__.__dict__["description"] = description
        __props__.__dict__["duration_in_minutes"] = duration_in_minutes
        __props__.__dict__["enabled"] = enabled
        __props__.__dict__["key"] = key
        __props__.__dict__["project_key"] = project_key
        __props__.__dict__["search_criteria"] = search_criteria
        __props__.__dict__["skip_trashcan"] = skip_trashcan
        return PackageCleanupPolicy(resource_name, opts=opts, __props__=__props__)

    @_builtins.property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> pulumi.Output[Optional[_builtins.str]]:
        """
        The cron expression that determines when the policy is run, However if left empty the policy will not run automatically and can only be triggered manually.
        """
        return pulumi.get(self, "cron_expression")

    @_builtins.property
    @pulumi.getter
    def description(self) -> pulumi.Output[Optional[_builtins.str]]:
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="durationInMinutes")
    def duration_in_minutes(self) -> pulumi.Output[_builtins.int]:
        """
        The maximum duration (in minutes) for policy execution, after which the policy will stop running even if not completed. While setting a maximum run duration for a policy is useful for adhering to a strict cleanup schedule, it can cause the policy to stop before completion.
        """
        return pulumi.get(self, "duration_in_minutes")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Output[_builtins.bool]:
        """
        A cleanup policy must be created inactive. But if used it must be set to `false`. If set to `true` when calling this API, the API call will fail and an error message is received. Defaults to `true`
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Output[_builtins.str]:
        """
        An ID that is used to identify the cleanup policy. A minimum of three characters is required and can include letters, numbers, underscore and hyphen.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter(name="projectKey")
    def project_key(self) -> pulumi.Output[Optional[_builtins.str]]:
        """
        This attribute is used only for project-level cleanup policies, it is not used for global-level policies. When specified, the policy will be scoped to the specified project. Note: The policy `key` must start with this project key value as a prefix (e.g., if `project_key` is `"myproj"`, the `key` should be `"myproj-policy-name"`).
        """
        return pulumi.get(self, "project_key")

    @_builtins.property
    @pulumi.getter(name="searchCriteria")
    def search_criteria(self) -> pulumi.Output['outputs.PackageCleanupPolicySearchCriteria']:
        return pulumi.get(self, "search_criteria")

    @_builtins.property
    @pulumi.getter(name="skipTrashcan")
    def skip_trashcan(self) -> pulumi.Output[_builtins.bool]:
        """
        A true value means that when this policy is executed, packages will be permanently deleted. false means that when the policy is executed packages will be deleted to the Trash Can. Defaults to `false`.
        """
        return pulumi.get(self, "skip_trashcan")

