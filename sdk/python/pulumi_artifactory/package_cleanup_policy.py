# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs
from ._inputs import *

__all__ = ['PackageCleanupPolicyArgs', 'PackageCleanupPolicy']

@pulumi.input_type
class PackageCleanupPolicyArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 search_criteria: pulumi.Input['PackageCleanupPolicySearchCriteriaArgs'],
                 cron_expression: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 duration_in_minutes: Optional[pulumi.Input[_builtins.int]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 skip_trashcan: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        The set of arguments for constructing a PackageCleanupPolicy resource.
        :param pulumi.Input[_builtins.str] key: An ID that is used to identify the cleanup policy. A minimum of three characters is required and can include letters, numbers, underscore and hyphen.
        :param pulumi.Input[_builtins.str] cron_expression: The cron expression that determines when the policy is run, However if left empty the policy will not run automatically and can only be triggered manually.
        :param pulumi.Input[_builtins.int] duration_in_minutes: The maximum duration (in minutes) for policy execution, after which the policy will stop running even if not completed. While setting a maximum run duration for a policy is useful for adhering to a strict cleanup schedule, it can cause the policy to stop before completion.
        :param pulumi.Input[_builtins.bool] enabled: A cleanup policy must be created inactive. But if used it must be set to `false`. If set to `true` when calling this API, the API call will fail and an error message is received. Defaults to `true`
        :param pulumi.Input[_builtins.bool] skip_trashcan: A true value means that when this policy is executed, packages will be permanently deleted. false means that when the policy is executed packages will be deleted to the Trash Can. Defaults to `false`.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "search_criteria", search_criteria)
        if cron_expression is not None:
            pulumi.set(__self__, "cron_expression", cron_expression)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if duration_in_minutes is not None:
            pulumi.set(__self__, "duration_in_minutes", duration_in_minutes)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if skip_trashcan is not None:
            pulumi.set(__self__, "skip_trashcan", skip_trashcan)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        An ID that is used to identify the cleanup policy. A minimum of three characters is required and can include letters, numbers, underscore and hyphen.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="searchCriteria")
    def search_criteria(self) -> pulumi.Input['PackageCleanupPolicySearchCriteriaArgs']:
        return pulumi.get(self, "search_criteria")

    @search_criteria.setter
    def search_criteria(self, value: pulumi.Input['PackageCleanupPolicySearchCriteriaArgs']):
        pulumi.set(self, "search_criteria", value)

    @_builtins.property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The cron expression that determines when the policy is run, However if left empty the policy will not run automatically and can only be triggered manually.
        """
        return pulumi.get(self, "cron_expression")

    @cron_expression.setter
    def cron_expression(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cron_expression", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="durationInMinutes")
    def duration_in_minutes(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum duration (in minutes) for policy execution, after which the policy will stop running even if not completed. While setting a maximum run duration for a policy is useful for adhering to a strict cleanup schedule, it can cause the policy to stop before completion.
        """
        return pulumi.get(self, "duration_in_minutes")

    @duration_in_minutes.setter
    def duration_in_minutes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "duration_in_minutes", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        A cleanup policy must be created inactive. But if used it must be set to `false`. If set to `true` when calling this API, the API call will fail and an error message is received. Defaults to `true`
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="skipTrashcan")
    def skip_trashcan(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        A true value means that when this policy is executed, packages will be permanently deleted. false means that when the policy is executed packages will be deleted to the Trash Can. Defaults to `false`.
        """
        return pulumi.get(self, "skip_trashcan")

    @skip_trashcan.setter
    def skip_trashcan(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "skip_trashcan", value)


@pulumi.input_type
class _PackageCleanupPolicyState:
    def __init__(__self__, *,
                 cron_expression: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 duration_in_minutes: Optional[pulumi.Input[_builtins.int]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 search_criteria: Optional[pulumi.Input['PackageCleanupPolicySearchCriteriaArgs']] = None,
                 skip_trashcan: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        Input properties used for looking up and filtering PackageCleanupPolicy resources.
        :param pulumi.Input[_builtins.str] cron_expression: The cron expression that determines when the policy is run, However if left empty the policy will not run automatically and can only be triggered manually.
        :param pulumi.Input[_builtins.int] duration_in_minutes: The maximum duration (in minutes) for policy execution, after which the policy will stop running even if not completed. While setting a maximum run duration for a policy is useful for adhering to a strict cleanup schedule, it can cause the policy to stop before completion.
        :param pulumi.Input[_builtins.bool] enabled: A cleanup policy must be created inactive. But if used it must be set to `false`. If set to `true` when calling this API, the API call will fail and an error message is received. Defaults to `true`
        :param pulumi.Input[_builtins.str] key: An ID that is used to identify the cleanup policy. A minimum of three characters is required and can include letters, numbers, underscore and hyphen.
        :param pulumi.Input[_builtins.bool] skip_trashcan: A true value means that when this policy is executed, packages will be permanently deleted. false means that when the policy is executed packages will be deleted to the Trash Can. Defaults to `false`.
        """
        if cron_expression is not None:
            pulumi.set(__self__, "cron_expression", cron_expression)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if duration_in_minutes is not None:
            pulumi.set(__self__, "duration_in_minutes", duration_in_minutes)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if search_criteria is not None:
            pulumi.set(__self__, "search_criteria", search_criteria)
        if skip_trashcan is not None:
            pulumi.set(__self__, "skip_trashcan", skip_trashcan)

    @_builtins.property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The cron expression that determines when the policy is run, However if left empty the policy will not run automatically and can only be triggered manually.
        """
        return pulumi.get(self, "cron_expression")

    @cron_expression.setter
    def cron_expression(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cron_expression", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="durationInMinutes")
    def duration_in_minutes(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum duration (in minutes) for policy execution, after which the policy will stop running even if not completed. While setting a maximum run duration for a policy is useful for adhering to a strict cleanup schedule, it can cause the policy to stop before completion.
        """
        return pulumi.get(self, "duration_in_minutes")

    @duration_in_minutes.setter
    def duration_in_minutes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "duration_in_minutes", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        A cleanup policy must be created inactive. But if used it must be set to `false`. If set to `true` when calling this API, the API call will fail and an error message is received. Defaults to `true`
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An ID that is used to identify the cleanup policy. A minimum of three characters is required and can include letters, numbers, underscore and hyphen.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="searchCriteria")
    def search_criteria(self) -> Optional[pulumi.Input['PackageCleanupPolicySearchCriteriaArgs']]:
        return pulumi.get(self, "search_criteria")

    @search_criteria.setter
    def search_criteria(self, value: Optional[pulumi.Input['PackageCleanupPolicySearchCriteriaArgs']]):
        pulumi.set(self, "search_criteria", value)

    @_builtins.property
    @pulumi.getter(name="skipTrashcan")
    def skip_trashcan(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        A true value means that when this policy is executed, packages will be permanently deleted. false means that when the policy is executed packages will be deleted to the Trash Can. Defaults to `false`.
        """
        return pulumi.get(self, "skip_trashcan")

    @skip_trashcan.setter
    def skip_trashcan(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "skip_trashcan", value)


@pulumi.type_token("artifactory:index/packageCleanupPolicy:PackageCleanupPolicy")
class PackageCleanupPolicy(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 cron_expression: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 duration_in_minutes: Optional[pulumi.Input[_builtins.int]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 search_criteria: Optional[pulumi.Input[Union['PackageCleanupPolicySearchCriteriaArgs', 'PackageCleanupPolicySearchCriteriaArgsDict']]] = None,
                 skip_trashcan: Optional[pulumi.Input[_builtins.bool]] = None,
                 __props__=None):
        """
        ## Import

        ```sh
        $ pulumi import artifactory:index/packageCleanupPolicy:PackageCleanupPolicy my-cleanup-policy my-policy
        ```

        ```sh
        $ pulumi import artifactory:index/packageCleanupPolicy:PackageCleanupPolicy my-cleanup-policy my-policy:myproj
        ```

        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[_builtins.str] cron_expression: The cron expression that determines when the policy is run, However if left empty the policy will not run automatically and can only be triggered manually.
        :param pulumi.Input[_builtins.int] duration_in_minutes: The maximum duration (in minutes) for policy execution, after which the policy will stop running even if not completed. While setting a maximum run duration for a policy is useful for adhering to a strict cleanup schedule, it can cause the policy to stop before completion.
        :param pulumi.Input[_builtins.bool] enabled: A cleanup policy must be created inactive. But if used it must be set to `false`. If set to `true` when calling this API, the API call will fail and an error message is received. Defaults to `true`
        :param pulumi.Input[_builtins.str] key: An ID that is used to identify the cleanup policy. A minimum of three characters is required and can include letters, numbers, underscore and hyphen.
        :param pulumi.Input[_builtins.bool] skip_trashcan: A true value means that when this policy is executed, packages will be permanently deleted. false means that when the policy is executed packages will be deleted to the Trash Can. Defaults to `false`.
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: PackageCleanupPolicyArgs,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        ## Import

        ```sh
        $ pulumi import artifactory:index/packageCleanupPolicy:PackageCleanupPolicy my-cleanup-policy my-policy
        ```

        ```sh
        $ pulumi import artifactory:index/packageCleanupPolicy:PackageCleanupPolicy my-cleanup-policy my-policy:myproj
        ```

        :param str resource_name: The name of the resource.
        :param PackageCleanupPolicyArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(PackageCleanupPolicyArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 cron_expression: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 duration_in_minutes: Optional[pulumi.Input[_builtins.int]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 search_criteria: Optional[pulumi.Input[Union['PackageCleanupPolicySearchCriteriaArgs', 'PackageCleanupPolicySearchCriteriaArgsDict']]] = None,
                 skip_trashcan: Optional[pulumi.Input[_builtins.bool]] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = PackageCleanupPolicyArgs.__new__(PackageCleanupPolicyArgs)

            __props__.__dict__["cron_expression"] = cron_expression
            __props__.__dict__["description"] = description
            __props__.__dict__["duration_in_minutes"] = duration_in_minutes
            __props__.__dict__["enabled"] = enabled
            if key is None and not opts.urn:
                raise TypeError("Missing required property 'key'")
            __props__.__dict__["key"] = key
            if search_criteria is None and not opts.urn:
                raise TypeError("Missing required property 'search_criteria'")
            __props__.__dict__["search_criteria"] = search_criteria
            __props__.__dict__["skip_trashcan"] = skip_trashcan
        super(PackageCleanupPolicy, __self__).__init__(
            'artifactory:index/packageCleanupPolicy:PackageCleanupPolicy',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            cron_expression: Optional[pulumi.Input[_builtins.str]] = None,
            description: Optional[pulumi.Input[_builtins.str]] = None,
            duration_in_minutes: Optional[pulumi.Input[_builtins.int]] = None,
            enabled: Optional[pulumi.Input[_builtins.bool]] = None,
            key: Optional[pulumi.Input[_builtins.str]] = None,
            search_criteria: Optional[pulumi.Input[Union['PackageCleanupPolicySearchCriteriaArgs', 'PackageCleanupPolicySearchCriteriaArgsDict']]] = None,
            skip_trashcan: Optional[pulumi.Input[_builtins.bool]] = None) -> 'PackageCleanupPolicy':
        """
        Get an existing PackageCleanupPolicy resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[_builtins.str] cron_expression: The cron expression that determines when the policy is run, However if left empty the policy will not run automatically and can only be triggered manually.
        :param pulumi.Input[_builtins.int] duration_in_minutes: The maximum duration (in minutes) for policy execution, after which the policy will stop running even if not completed. While setting a maximum run duration for a policy is useful for adhering to a strict cleanup schedule, it can cause the policy to stop before completion.
        :param pulumi.Input[_builtins.bool] enabled: A cleanup policy must be created inactive. But if used it must be set to `false`. If set to `true` when calling this API, the API call will fail and an error message is received. Defaults to `true`
        :param pulumi.Input[_builtins.str] key: An ID that is used to identify the cleanup policy. A minimum of three characters is required and can include letters, numbers, underscore and hyphen.
        :param pulumi.Input[_builtins.bool] skip_trashcan: A true value means that when this policy is executed, packages will be permanently deleted. false means that when the policy is executed packages will be deleted to the Trash Can. Defaults to `false`.
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _PackageCleanupPolicyState.__new__(_PackageCleanupPolicyState)

        __props__.__dict__["cron_expression"] = cron_expression
        __props__.__dict__["description"] = description
        __props__.__dict__["duration_in_minutes"] = duration_in_minutes
        __props__.__dict__["enabled"] = enabled
        __props__.__dict__["key"] = key
        __props__.__dict__["search_criteria"] = search_criteria
        __props__.__dict__["skip_trashcan"] = skip_trashcan
        return PackageCleanupPolicy(resource_name, opts=opts, __props__=__props__)

    @_builtins.property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> pulumi.Output[Optional[_builtins.str]]:
        """
        The cron expression that determines when the policy is run, However if left empty the policy will not run automatically and can only be triggered manually.
        """
        return pulumi.get(self, "cron_expression")

    @_builtins.property
    @pulumi.getter
    def description(self) -> pulumi.Output[Optional[_builtins.str]]:
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="durationInMinutes")
    def duration_in_minutes(self) -> pulumi.Output[Optional[_builtins.int]]:
        """
        The maximum duration (in minutes) for policy execution, after which the policy will stop running even if not completed. While setting a maximum run duration for a policy is useful for adhering to a strict cleanup schedule, it can cause the policy to stop before completion.
        """
        return pulumi.get(self, "duration_in_minutes")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Output[_builtins.bool]:
        """
        A cleanup policy must be created inactive. But if used it must be set to `false`. If set to `true` when calling this API, the API call will fail and an error message is received. Defaults to `true`
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Output[_builtins.str]:
        """
        An ID that is used to identify the cleanup policy. A minimum of three characters is required and can include letters, numbers, underscore and hyphen.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter(name="searchCriteria")
    def search_criteria(self) -> pulumi.Output['outputs.PackageCleanupPolicySearchCriteria']:
        return pulumi.get(self, "search_criteria")

    @_builtins.property
    @pulumi.getter(name="skipTrashcan")
    def skip_trashcan(self) -> pulumi.Output[_builtins.bool]:
        """
        A true value means that when this policy is executed, packages will be permanently deleted. false means that when the policy is executed packages will be deleted to the Trash Can. Defaults to `false`.
        """
        return pulumi.get(self, "skip_trashcan")

