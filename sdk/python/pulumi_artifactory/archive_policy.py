# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs
from ._inputs import *

__all__ = ['ArchivePolicyArgs', 'ArchivePolicy']

@pulumi.input_type
class ArchivePolicyArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 search_criteria: pulumi.Input['ArchivePolicySearchCriteriaArgs'],
                 cron_expression: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 duration_in_minutes: Optional[pulumi.Input[_builtins.int]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 project_key: Optional[pulumi.Input[_builtins.str]] = None,
                 skip_trashcan: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        The set of arguments for constructing a ArchivePolicy resource.
        :param pulumi.Input[_builtins.str] key: An ID that is used to identify the archive policy. A minimum of three characters is required and can include letters, numbers, underscore and hyphen.
        :param pulumi.Input[_builtins.str] cron_expression: The cron expression determines when the policy is run. This parameter is not mandatory, however if left empty the policy will not run automatically and can only be triggered manually.
        :param pulumi.Input[_builtins.int] duration_in_minutes: The maximum duration (in minutes) for policy execution, after which the policy will stop running even if not completed. While setting a maximum run duration for a policy is useful for adhering to a strict archive V2 schedule, it can cause the policy to stop before completion.
        :param pulumi.Input[_builtins.bool] enabled: Enables or disabled the package cleanup policy. This allows the user to run the policy manually. If a policy has a valid cron expression, then it will be scheduled for execution based on it. If a policy is disabled, its future executions will be unscheduled. Defaults to `true`
        :param pulumi.Input[_builtins.str] project_key: This attribute is used only for project-level archive V2 policies, it is not used for global-level policies.
        :param pulumi.Input[_builtins.bool] skip_trashcan: A `true` value means that when this policy is executed, packages will be permanently deleted. `false` means that when the policy is executed packages will be deleted to the Trash Can. Defaults to `false`.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "search_criteria", search_criteria)
        if cron_expression is not None:
            pulumi.set(__self__, "cron_expression", cron_expression)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if duration_in_minutes is not None:
            pulumi.set(__self__, "duration_in_minutes", duration_in_minutes)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if project_key is not None:
            pulumi.set(__self__, "project_key", project_key)
        if skip_trashcan is not None:
            pulumi.set(__self__, "skip_trashcan", skip_trashcan)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        An ID that is used to identify the archive policy. A minimum of three characters is required and can include letters, numbers, underscore and hyphen.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="searchCriteria")
    def search_criteria(self) -> pulumi.Input['ArchivePolicySearchCriteriaArgs']:
        return pulumi.get(self, "search_criteria")

    @search_criteria.setter
    def search_criteria(self, value: pulumi.Input['ArchivePolicySearchCriteriaArgs']):
        pulumi.set(self, "search_criteria", value)

    @_builtins.property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The cron expression determines when the policy is run. This parameter is not mandatory, however if left empty the policy will not run automatically and can only be triggered manually.
        """
        return pulumi.get(self, "cron_expression")

    @cron_expression.setter
    def cron_expression(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cron_expression", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="durationInMinutes")
    def duration_in_minutes(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum duration (in minutes) for policy execution, after which the policy will stop running even if not completed. While setting a maximum run duration for a policy is useful for adhering to a strict archive V2 schedule, it can cause the policy to stop before completion.
        """
        return pulumi.get(self, "duration_in_minutes")

    @duration_in_minutes.setter
    def duration_in_minutes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "duration_in_minutes", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enables or disabled the package cleanup policy. This allows the user to run the policy manually. If a policy has a valid cron expression, then it will be scheduled for execution based on it. If a policy is disabled, its future executions will be unscheduled. Defaults to `true`
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="projectKey")
    def project_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        This attribute is used only for project-level archive V2 policies, it is not used for global-level policies.
        """
        return pulumi.get(self, "project_key")

    @project_key.setter
    def project_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "project_key", value)

    @_builtins.property
    @pulumi.getter(name="skipTrashcan")
    def skip_trashcan(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        A `true` value means that when this policy is executed, packages will be permanently deleted. `false` means that when the policy is executed packages will be deleted to the Trash Can. Defaults to `false`.
        """
        return pulumi.get(self, "skip_trashcan")

    @skip_trashcan.setter
    def skip_trashcan(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "skip_trashcan", value)


@pulumi.input_type
class _ArchivePolicyState:
    def __init__(__self__, *,
                 cron_expression: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 duration_in_minutes: Optional[pulumi.Input[_builtins.int]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 project_key: Optional[pulumi.Input[_builtins.str]] = None,
                 search_criteria: Optional[pulumi.Input['ArchivePolicySearchCriteriaArgs']] = None,
                 skip_trashcan: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        Input properties used for looking up and filtering ArchivePolicy resources.
        :param pulumi.Input[_builtins.str] cron_expression: The cron expression determines when the policy is run. This parameter is not mandatory, however if left empty the policy will not run automatically and can only be triggered manually.
        :param pulumi.Input[_builtins.int] duration_in_minutes: The maximum duration (in minutes) for policy execution, after which the policy will stop running even if not completed. While setting a maximum run duration for a policy is useful for adhering to a strict archive V2 schedule, it can cause the policy to stop before completion.
        :param pulumi.Input[_builtins.bool] enabled: Enables or disabled the package cleanup policy. This allows the user to run the policy manually. If a policy has a valid cron expression, then it will be scheduled for execution based on it. If a policy is disabled, its future executions will be unscheduled. Defaults to `true`
        :param pulumi.Input[_builtins.str] key: An ID that is used to identify the archive policy. A minimum of three characters is required and can include letters, numbers, underscore and hyphen.
        :param pulumi.Input[_builtins.str] project_key: This attribute is used only for project-level archive V2 policies, it is not used for global-level policies.
        :param pulumi.Input[_builtins.bool] skip_trashcan: A `true` value means that when this policy is executed, packages will be permanently deleted. `false` means that when the policy is executed packages will be deleted to the Trash Can. Defaults to `false`.
        """
        if cron_expression is not None:
            pulumi.set(__self__, "cron_expression", cron_expression)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if duration_in_minutes is not None:
            pulumi.set(__self__, "duration_in_minutes", duration_in_minutes)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if project_key is not None:
            pulumi.set(__self__, "project_key", project_key)
        if search_criteria is not None:
            pulumi.set(__self__, "search_criteria", search_criteria)
        if skip_trashcan is not None:
            pulumi.set(__self__, "skip_trashcan", skip_trashcan)

    @_builtins.property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The cron expression determines when the policy is run. This parameter is not mandatory, however if left empty the policy will not run automatically and can only be triggered manually.
        """
        return pulumi.get(self, "cron_expression")

    @cron_expression.setter
    def cron_expression(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cron_expression", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="durationInMinutes")
    def duration_in_minutes(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum duration (in minutes) for policy execution, after which the policy will stop running even if not completed. While setting a maximum run duration for a policy is useful for adhering to a strict archive V2 schedule, it can cause the policy to stop before completion.
        """
        return pulumi.get(self, "duration_in_minutes")

    @duration_in_minutes.setter
    def duration_in_minutes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "duration_in_minutes", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enables or disabled the package cleanup policy. This allows the user to run the policy manually. If a policy has a valid cron expression, then it will be scheduled for execution based on it. If a policy is disabled, its future executions will be unscheduled. Defaults to `true`
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An ID that is used to identify the archive policy. A minimum of three characters is required and can include letters, numbers, underscore and hyphen.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="projectKey")
    def project_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        This attribute is used only for project-level archive V2 policies, it is not used for global-level policies.
        """
        return pulumi.get(self, "project_key")

    @project_key.setter
    def project_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "project_key", value)

    @_builtins.property
    @pulumi.getter(name="searchCriteria")
    def search_criteria(self) -> Optional[pulumi.Input['ArchivePolicySearchCriteriaArgs']]:
        return pulumi.get(self, "search_criteria")

    @search_criteria.setter
    def search_criteria(self, value: Optional[pulumi.Input['ArchivePolicySearchCriteriaArgs']]):
        pulumi.set(self, "search_criteria", value)

    @_builtins.property
    @pulumi.getter(name="skipTrashcan")
    def skip_trashcan(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        A `true` value means that when this policy is executed, packages will be permanently deleted. `false` means that when the policy is executed packages will be deleted to the Trash Can. Defaults to `false`.
        """
        return pulumi.get(self, "skip_trashcan")

    @skip_trashcan.setter
    def skip_trashcan(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "skip_trashcan", value)


@pulumi.type_token("artifactory:index/archivePolicy:ArchivePolicy")
class ArchivePolicy(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 cron_expression: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 duration_in_minutes: Optional[pulumi.Input[_builtins.int]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 project_key: Optional[pulumi.Input[_builtins.str]] = None,
                 search_criteria: Optional[pulumi.Input[Union['ArchivePolicySearchCriteriaArgs', 'ArchivePolicySearchCriteriaArgsDict']]] = None,
                 skip_trashcan: Optional[pulumi.Input[_builtins.bool]] = None,
                 __props__=None):
        """
        Provides an Artifactory Archive Policy resource. This resource enable system administrators to define and customize policies based on specific criteria for removing unused binaries from across their JFrog platform. See [Retention Policies](https://jfrog.com/help/r/jfrog-platform-administration-documentation/archive) for more details.

        ## Example Usage

        ### Time-based Archive Policy (Days)

        ```python
        import pulumi
        import pulumi_artifactory as artifactory

        my_archive_policy = artifactory.ArchivePolicy("my-archive-policy",
            key="my-archive-policy",
            description="My archive policy",
            cron_expression="0 0 2 ? * MON-SAT *",
            duration_in_minutes=60,
            enabled=True,
            skip_trashcan=False,
            search_criteria={
                "package_types": ["docker"],
                "repos": ["**"],
                "include_all_projects": True,
                "included_projects": [],
                "included_packages": ["**"],
                "excluded_packages": ["com/jfrog/latest"],
                "created_before_in_days": 30,
                "last_downloaded_before_in_days": 60,
            })
        ```

        ### Version-based Archive Policy

        ```python
        import pulumi
        import pulumi_artifactory as artifactory

        my_version_policy = artifactory.ArchivePolicy("my-version-policy",
            key="my-version-policy",
            description="Keep only latest versions",
            cron_expression="0 0 2 ? * MON-SAT *",
            duration_in_minutes=60,
            enabled=True,
            skip_trashcan=False,
            search_criteria={
                "package_types": ["docker"],
                "repos": ["**"],
                "include_all_projects": True,
                "included_projects": [],
                "included_packages": ["**"],
                "excluded_packages": ["com/jfrog/latest"],
                "keep_last_n_versions": 5,
            })
        ```

        ### Properties-based Archive Policy

        ```python
        import pulumi
        import pulumi_artifactory as artifactory

        my_properties_policy = artifactory.ArchivePolicy("my-properties-policy",
            key="my-properties-policy",
            description="Archive based on properties",
            cron_expression="0 0 2 ? * MON-SAT *",
            duration_in_minutes=60,
            enabled=True,
            skip_trashcan=False,
            search_criteria={
                "package_types": ["docker"],
                "repos": ["**"],
                "include_all_projects": True,
                "included_projects": [],
                "included_packages": ["**"],
                "excluded_packages": ["com/jfrog/latest"],
                "included_properties": {
                    "build.name": ["my-app"],
                },
            })
        ```

        ### Using Variables for Condition Fields

        You can use Terraform variables for condition fields (`created_before_in_days`, `last_downloaded_before_in_days`, `created_before_in_months`, `last_downloaded_before_in_months`, `keep_last_n_versions`, `included_properties`) and `duration_in_minutes`. The validator will skip validation when values are unknown (variables), allowing `terraform validate` to pass without requiring variable values.

        **Example with variables:**

        ```python
        import pulumi
        import pulumi_artifactory as artifactory

        config = pulumi.Config()
        archive_policy_last_downloaded_before_in_days = config.get_float("archivePolicyLastDownloadedBeforeInDays")
        if archive_policy_last_downloaded_before_in_days is None:
            archive_policy_last_downloaded_before_in_days = 30
        archive_policy_duration_in_minutes = config.get_float("archivePolicyDurationInMinutes")
        if archive_policy_duration_in_minutes is None:
            archive_policy_duration_in_minutes = 60
        my_archive_policy = artifactory.ArchivePolicy("my-archive-policy",
            key="my-archive-policy",
            description="My archive policy with variables",
            cron_expression="0 0 2 ? * MON-SAT *",
            duration_in_minutes=archive_policy_duration_in_minutes,
            enabled=True,
            skip_trashcan=False,
            search_criteria={
                "package_types": [
                    "docker",
                    "generic",
                    "helm",
                    "helmoci",
                    "nuget",
                    "terraform",
                ],
                "repos": ["**"],
                "include_all_projects": False,
                "included_projects": ["default"],
                "included_packages": ["**"],
                "excluded_packages": ["com/jfrog/latest"],
                "last_downloaded_before_in_days": archive_policy_last_downloaded_before_in_days,
            })
        ```

        **Important Notes:**
        - Variables with default values allow `terraform validate` to pass without requiring variable values
        - Variables without default values will require values to be provided during `pulumi preview` or `pulumi up`
        - The validator automatically skips validation when condition field values are unknown (variables), preventing false validation errors during `terraform validate`

        ## Validation Rules

        The archive policy resource enforces the following validation rules:

        1. **Condition Types**: A policy must use exactly one of the following condition types:
           - Time-based conditions (`days-based`)
           - Version-based condition (`keep_last_n_versions`)
           - Properties-based condition (`included_properties`)

        2. **Mutual Exclusivity**: Cannot use multiple condition types together.

        3. **Zero Values**: Time-based and version-based conditions must have values greater than 0.

        4. **Days vs Months**: Cannot use both days-based conditions (`created_before_in_days`, `last_downloaded_before_in_days`) and months-based conditions (`created_before_in_months`, `last_downloaded_before_in_months`) together.

        5. **Properties Validation**: Properties-based conditions must have exactly one key with exactly one string value.

        6. **Project Configuration**: When `include_all_projects` is set to `true`, the `included_projects` field can be empty array. When `include_all_projects` is `false`, `included_projects` must contain at least one project key.

        ## Supported Package Types

        The following package types are supported: alpine, ansible, cargo, chef, cocoapods, composer, conan, conda, debian, docker, gems, generic, go, gradle, helm, helmoci, huggingfaceml, maven, npm, nuget, oci, opkg, puppet, pypi, sbt, swift, terraform, terraformbackend, vagrant, yum.

        ## Version Compatibility

        - The `created_before_in_days` and `last_downloaded_before_in_days` attributes are only supported in Artifactory 7.111.2 and later. For earlier versions, use `created_before_in_months` and `last_downloaded_before_in_months`.

        ## Import

        ```sh
        $ pulumi import artifactory:index/archivePolicy:ArchivePolicy my-archive-policy my-policy

        $ pulumi import artifactory:index/archivePolicy:ArchivePolicy my-archive-policy my-policy:myproj
        ```

        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[_builtins.str] cron_expression: The cron expression determines when the policy is run. This parameter is not mandatory, however if left empty the policy will not run automatically and can only be triggered manually.
        :param pulumi.Input[_builtins.int] duration_in_minutes: The maximum duration (in minutes) for policy execution, after which the policy will stop running even if not completed. While setting a maximum run duration for a policy is useful for adhering to a strict archive V2 schedule, it can cause the policy to stop before completion.
        :param pulumi.Input[_builtins.bool] enabled: Enables or disabled the package cleanup policy. This allows the user to run the policy manually. If a policy has a valid cron expression, then it will be scheduled for execution based on it. If a policy is disabled, its future executions will be unscheduled. Defaults to `true`
        :param pulumi.Input[_builtins.str] key: An ID that is used to identify the archive policy. A minimum of three characters is required and can include letters, numbers, underscore and hyphen.
        :param pulumi.Input[_builtins.str] project_key: This attribute is used only for project-level archive V2 policies, it is not used for global-level policies.
        :param pulumi.Input[_builtins.bool] skip_trashcan: A `true` value means that when this policy is executed, packages will be permanently deleted. `false` means that when the policy is executed packages will be deleted to the Trash Can. Defaults to `false`.
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: ArchivePolicyArgs,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        Provides an Artifactory Archive Policy resource. This resource enable system administrators to define and customize policies based on specific criteria for removing unused binaries from across their JFrog platform. See [Retention Policies](https://jfrog.com/help/r/jfrog-platform-administration-documentation/archive) for more details.

        ## Example Usage

        ### Time-based Archive Policy (Days)

        ```python
        import pulumi
        import pulumi_artifactory as artifactory

        my_archive_policy = artifactory.ArchivePolicy("my-archive-policy",
            key="my-archive-policy",
            description="My archive policy",
            cron_expression="0 0 2 ? * MON-SAT *",
            duration_in_minutes=60,
            enabled=True,
            skip_trashcan=False,
            search_criteria={
                "package_types": ["docker"],
                "repos": ["**"],
                "include_all_projects": True,
                "included_projects": [],
                "included_packages": ["**"],
                "excluded_packages": ["com/jfrog/latest"],
                "created_before_in_days": 30,
                "last_downloaded_before_in_days": 60,
            })
        ```

        ### Version-based Archive Policy

        ```python
        import pulumi
        import pulumi_artifactory as artifactory

        my_version_policy = artifactory.ArchivePolicy("my-version-policy",
            key="my-version-policy",
            description="Keep only latest versions",
            cron_expression="0 0 2 ? * MON-SAT *",
            duration_in_minutes=60,
            enabled=True,
            skip_trashcan=False,
            search_criteria={
                "package_types": ["docker"],
                "repos": ["**"],
                "include_all_projects": True,
                "included_projects": [],
                "included_packages": ["**"],
                "excluded_packages": ["com/jfrog/latest"],
                "keep_last_n_versions": 5,
            })
        ```

        ### Properties-based Archive Policy

        ```python
        import pulumi
        import pulumi_artifactory as artifactory

        my_properties_policy = artifactory.ArchivePolicy("my-properties-policy",
            key="my-properties-policy",
            description="Archive based on properties",
            cron_expression="0 0 2 ? * MON-SAT *",
            duration_in_minutes=60,
            enabled=True,
            skip_trashcan=False,
            search_criteria={
                "package_types": ["docker"],
                "repos": ["**"],
                "include_all_projects": True,
                "included_projects": [],
                "included_packages": ["**"],
                "excluded_packages": ["com/jfrog/latest"],
                "included_properties": {
                    "build.name": ["my-app"],
                },
            })
        ```

        ### Using Variables for Condition Fields

        You can use Terraform variables for condition fields (`created_before_in_days`, `last_downloaded_before_in_days`, `created_before_in_months`, `last_downloaded_before_in_months`, `keep_last_n_versions`, `included_properties`) and `duration_in_minutes`. The validator will skip validation when values are unknown (variables), allowing `terraform validate` to pass without requiring variable values.

        **Example with variables:**

        ```python
        import pulumi
        import pulumi_artifactory as artifactory

        config = pulumi.Config()
        archive_policy_last_downloaded_before_in_days = config.get_float("archivePolicyLastDownloadedBeforeInDays")
        if archive_policy_last_downloaded_before_in_days is None:
            archive_policy_last_downloaded_before_in_days = 30
        archive_policy_duration_in_minutes = config.get_float("archivePolicyDurationInMinutes")
        if archive_policy_duration_in_minutes is None:
            archive_policy_duration_in_minutes = 60
        my_archive_policy = artifactory.ArchivePolicy("my-archive-policy",
            key="my-archive-policy",
            description="My archive policy with variables",
            cron_expression="0 0 2 ? * MON-SAT *",
            duration_in_minutes=archive_policy_duration_in_minutes,
            enabled=True,
            skip_trashcan=False,
            search_criteria={
                "package_types": [
                    "docker",
                    "generic",
                    "helm",
                    "helmoci",
                    "nuget",
                    "terraform",
                ],
                "repos": ["**"],
                "include_all_projects": False,
                "included_projects": ["default"],
                "included_packages": ["**"],
                "excluded_packages": ["com/jfrog/latest"],
                "last_downloaded_before_in_days": archive_policy_last_downloaded_before_in_days,
            })
        ```

        **Important Notes:**
        - Variables with default values allow `terraform validate` to pass without requiring variable values
        - Variables without default values will require values to be provided during `pulumi preview` or `pulumi up`
        - The validator automatically skips validation when condition field values are unknown (variables), preventing false validation errors during `terraform validate`

        ## Validation Rules

        The archive policy resource enforces the following validation rules:

        1. **Condition Types**: A policy must use exactly one of the following condition types:
           - Time-based conditions (`days-based`)
           - Version-based condition (`keep_last_n_versions`)
           - Properties-based condition (`included_properties`)

        2. **Mutual Exclusivity**: Cannot use multiple condition types together.

        3. **Zero Values**: Time-based and version-based conditions must have values greater than 0.

        4. **Days vs Months**: Cannot use both days-based conditions (`created_before_in_days`, `last_downloaded_before_in_days`) and months-based conditions (`created_before_in_months`, `last_downloaded_before_in_months`) together.

        5. **Properties Validation**: Properties-based conditions must have exactly one key with exactly one string value.

        6. **Project Configuration**: When `include_all_projects` is set to `true`, the `included_projects` field can be empty array. When `include_all_projects` is `false`, `included_projects` must contain at least one project key.

        ## Supported Package Types

        The following package types are supported: alpine, ansible, cargo, chef, cocoapods, composer, conan, conda, debian, docker, gems, generic, go, gradle, helm, helmoci, huggingfaceml, maven, npm, nuget, oci, opkg, puppet, pypi, sbt, swift, terraform, terraformbackend, vagrant, yum.

        ## Version Compatibility

        - The `created_before_in_days` and `last_downloaded_before_in_days` attributes are only supported in Artifactory 7.111.2 and later. For earlier versions, use `created_before_in_months` and `last_downloaded_before_in_months`.

        ## Import

        ```sh
        $ pulumi import artifactory:index/archivePolicy:ArchivePolicy my-archive-policy my-policy

        $ pulumi import artifactory:index/archivePolicy:ArchivePolicy my-archive-policy my-policy:myproj
        ```

        :param str resource_name: The name of the resource.
        :param ArchivePolicyArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(ArchivePolicyArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 cron_expression: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 duration_in_minutes: Optional[pulumi.Input[_builtins.int]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 project_key: Optional[pulumi.Input[_builtins.str]] = None,
                 search_criteria: Optional[pulumi.Input[Union['ArchivePolicySearchCriteriaArgs', 'ArchivePolicySearchCriteriaArgsDict']]] = None,
                 skip_trashcan: Optional[pulumi.Input[_builtins.bool]] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = ArchivePolicyArgs.__new__(ArchivePolicyArgs)

            __props__.__dict__["cron_expression"] = cron_expression
            __props__.__dict__["description"] = description
            __props__.__dict__["duration_in_minutes"] = duration_in_minutes
            __props__.__dict__["enabled"] = enabled
            if key is None and not opts.urn:
                raise TypeError("Missing required property 'key'")
            __props__.__dict__["key"] = key
            __props__.__dict__["project_key"] = project_key
            if search_criteria is None and not opts.urn:
                raise TypeError("Missing required property 'search_criteria'")
            __props__.__dict__["search_criteria"] = search_criteria
            __props__.__dict__["skip_trashcan"] = skip_trashcan
        super(ArchivePolicy, __self__).__init__(
            'artifactory:index/archivePolicy:ArchivePolicy',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            cron_expression: Optional[pulumi.Input[_builtins.str]] = None,
            description: Optional[pulumi.Input[_builtins.str]] = None,
            duration_in_minutes: Optional[pulumi.Input[_builtins.int]] = None,
            enabled: Optional[pulumi.Input[_builtins.bool]] = None,
            key: Optional[pulumi.Input[_builtins.str]] = None,
            project_key: Optional[pulumi.Input[_builtins.str]] = None,
            search_criteria: Optional[pulumi.Input[Union['ArchivePolicySearchCriteriaArgs', 'ArchivePolicySearchCriteriaArgsDict']]] = None,
            skip_trashcan: Optional[pulumi.Input[_builtins.bool]] = None) -> 'ArchivePolicy':
        """
        Get an existing ArchivePolicy resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[_builtins.str] cron_expression: The cron expression determines when the policy is run. This parameter is not mandatory, however if left empty the policy will not run automatically and can only be triggered manually.
        :param pulumi.Input[_builtins.int] duration_in_minutes: The maximum duration (in minutes) for policy execution, after which the policy will stop running even if not completed. While setting a maximum run duration for a policy is useful for adhering to a strict archive V2 schedule, it can cause the policy to stop before completion.
        :param pulumi.Input[_builtins.bool] enabled: Enables or disabled the package cleanup policy. This allows the user to run the policy manually. If a policy has a valid cron expression, then it will be scheduled for execution based on it. If a policy is disabled, its future executions will be unscheduled. Defaults to `true`
        :param pulumi.Input[_builtins.str] key: An ID that is used to identify the archive policy. A minimum of three characters is required and can include letters, numbers, underscore and hyphen.
        :param pulumi.Input[_builtins.str] project_key: This attribute is used only for project-level archive V2 policies, it is not used for global-level policies.
        :param pulumi.Input[_builtins.bool] skip_trashcan: A `true` value means that when this policy is executed, packages will be permanently deleted. `false` means that when the policy is executed packages will be deleted to the Trash Can. Defaults to `false`.
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _ArchivePolicyState.__new__(_ArchivePolicyState)

        __props__.__dict__["cron_expression"] = cron_expression
        __props__.__dict__["description"] = description
        __props__.__dict__["duration_in_minutes"] = duration_in_minutes
        __props__.__dict__["enabled"] = enabled
        __props__.__dict__["key"] = key
        __props__.__dict__["project_key"] = project_key
        __props__.__dict__["search_criteria"] = search_criteria
        __props__.__dict__["skip_trashcan"] = skip_trashcan
        return ArchivePolicy(resource_name, opts=opts, __props__=__props__)

    @_builtins.property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> pulumi.Output[Optional[_builtins.str]]:
        """
        The cron expression determines when the policy is run. This parameter is not mandatory, however if left empty the policy will not run automatically and can only be triggered manually.
        """
        return pulumi.get(self, "cron_expression")

    @_builtins.property
    @pulumi.getter
    def description(self) -> pulumi.Output[Optional[_builtins.str]]:
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="durationInMinutes")
    def duration_in_minutes(self) -> pulumi.Output[_builtins.int]:
        """
        The maximum duration (in minutes) for policy execution, after which the policy will stop running even if not completed. While setting a maximum run duration for a policy is useful for adhering to a strict archive V2 schedule, it can cause the policy to stop before completion.
        """
        return pulumi.get(self, "duration_in_minutes")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Output[_builtins.bool]:
        """
        Enables or disabled the package cleanup policy. This allows the user to run the policy manually. If a policy has a valid cron expression, then it will be scheduled for execution based on it. If a policy is disabled, its future executions will be unscheduled. Defaults to `true`
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Output[_builtins.str]:
        """
        An ID that is used to identify the archive policy. A minimum of three characters is required and can include letters, numbers, underscore and hyphen.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter(name="projectKey")
    def project_key(self) -> pulumi.Output[Optional[_builtins.str]]:
        """
        This attribute is used only for project-level archive V2 policies, it is not used for global-level policies.
        """
        return pulumi.get(self, "project_key")

    @_builtins.property
    @pulumi.getter(name="searchCriteria")
    def search_criteria(self) -> pulumi.Output['outputs.ArchivePolicySearchCriteria']:
        return pulumi.get(self, "search_criteria")

    @_builtins.property
    @pulumi.getter(name="skipTrashcan")
    def skip_trashcan(self) -> pulumi.Output[_builtins.bool]:
        """
        A `true` value means that when this policy is executed, packages will be permanently deleted. `false` means that when the policy is executed packages will be deleted to the Trash Can. Defaults to `false`.
        """
        return pulumi.get(self, "skip_trashcan")

