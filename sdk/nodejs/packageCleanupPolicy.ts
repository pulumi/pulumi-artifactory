// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "./types/input";
import * as outputs from "./types/output";
import * as utilities from "./utilities";

/**
 * Provides an Artifactory Package Cleanup Policy resource. This resource enable system administrators to define and customize policies based on specific criteria for removing unused binaries from across their JFrog platform. Package cleanup policies are supported on the Cloud (7.98.2) and Self-Hosted (7.98.7) platforms, with an Enterprise+ license. See [Cleanup Policies](https://jfrog.com/help/r/jfrog-platform-administration-documentation/cleanup-policies) for more details.
 *
 * ## Example Usage
 *
 * ### Time-based Cleanup Policy (Days)
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as artifactory from "@pulumi/artifactory";
 *
 * const my_cleanup_policy = new artifactory.PackageCleanupPolicy("my-cleanup-policy", {
 *     key: "my-cleanup-policy",
 *     description: "My cleanup policy",
 *     cronExpression: "0 0 2 ? * MON-SAT *",
 *     durationInMinutes: 60,
 *     enabled: true,
 *     skipTrashcan: false,
 *     searchCriteria: {
 *         packageTypes: [
 *             "docker",
 *             "gradle",
 *             "maven",
 *         ],
 *         repos: ["**"],
 *         includeAllProjects: true,
 *         includedProjects: [],
 *         includedPackages: ["**"],
 *         excludedPackages: ["com/jfrog/latest"],
 *         createdBeforeInDays: 30,
 *         lastDownloadedBeforeInDays: 60,
 *     },
 * });
 * ```
 *
 * ### Version-based Cleanup Policy
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as artifactory from "@pulumi/artifactory";
 *
 * const my_version_policy = new artifactory.PackageCleanupPolicy("my-version-policy", {
 *     key: "my-version-policy",
 *     description: "Keep only latest versions",
 *     cronExpression: "0 0 2 ? * MON-SAT *",
 *     durationInMinutes: 60,
 *     enabled: true,
 *     skipTrashcan: false,
 *     searchCriteria: {
 *         packageTypes: ["maven"],
 *         repos: ["**"],
 *         includeAllProjects: true,
 *         includedProjects: [],
 *         includedPackages: ["**"],
 *         excludedPackages: ["com/jfrog/latest"],
 *         keepLastNVersions: 5,
 *     },
 * });
 * ```
 *
 * ### Properties-based Cleanup Policy
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as artifactory from "@pulumi/artifactory";
 *
 * const my_properties_policy = new artifactory.PackageCleanupPolicy("my-properties-policy", {
 *     key: "my-properties-policy",
 *     description: "Cleanup based on properties",
 *     cronExpression: "0 0 2 ? * MON-SAT *",
 *     durationInMinutes: 60,
 *     enabled: true,
 *     skipTrashcan: false,
 *     searchCriteria: {
 *         packageTypes: ["docker"],
 *         repos: ["**"],
 *         includeAllProjects: true,
 *         includedProjects: [],
 *         includedPackages: ["**"],
 *         excludedPackages: ["com/jfrog/latest"],
 *         includedProperties: {
 *             "build.name": ["my-app"],
 *         },
 *     },
 * });
 * ```
 *
 * ### Using Variables for Condition Fields
 *
 * You can use Terraform variables for condition fields (`createdBeforeInDays`, `lastDownloadedBeforeInDays`, `createdBeforeInMonths`, `lastDownloadedBeforeInMonths`, `keepLastNVersions`, `includedProperties`) and `durationInMinutes`. The validator will skip validation when values are unknown (variables), allowing `terraform validate` to pass without requiring variable values.
 *
 * **Example with variables:**
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as artifactory from "@pulumi/artifactory";
 *
 * const config = new pulumi.Config();
 * const cleanupPolicyLastDownloadedBeforeInDays = config.getNumber("cleanupPolicyLastDownloadedBeforeInDays") || 60;
 * const cleanupPolicyDurationInMinutes = config.getNumber("cleanupPolicyDurationInMinutes") || 120;
 * const my_cleanup_policy = new artifactory.PackageCleanupPolicy("my-cleanup-policy", {
 *     key: "my-cleanup-policy",
 *     description: "My cleanup policy with variables",
 *     cronExpression: "0 0 2 ? * MON-SAT *",
 *     durationInMinutes: cleanupPolicyDurationInMinutes,
 *     enabled: true,
 *     skipTrashcan: false,
 *     searchCriteria: {
 *         packageTypes: [
 *             "docker",
 *             "generic",
 *             "helm",
 *             "helmoci",
 *             "nuget",
 *             "terraform",
 *         ],
 *         repos: ["**"],
 *         includeAllProjects: false,
 *         includedProjects: ["default"],
 *         includedPackages: ["**"],
 *         excludedPackages: ["com/jfrog/latest"],
 *         lastDownloadedBeforeInDays: cleanupPolicyLastDownloadedBeforeInDays,
 *     },
 * });
 * ```
 *
 * **Important Notes:**
 * - Variables with default values allow `terraform validate` to pass without requiring variable values
 * - Variables without default values will require values to be provided during `pulumi preview` or `pulumi up`
 * - The validator automatically skips validation when condition field values are unknown (variables), preventing false validation errors during `terraform validate`
 *
 * ## Validation Rules
 *
 * The cleanup policy resource enforces the following validation rules:
 *
 * 1. **Condition Types**: A policy must use exactly one of the following condition types:
 *    - Time-based conditions (`days-based`)
 *    - Version-based condition (`keepLastNVersions`)
 *    - Properties-based condition (`includedProperties`)
 *
 * 2. **Mutual Exclusivity**: Cannot use multiple condition types together.
 *
 * 3. **Zero Values**: Time-based and version-based conditions must have values greater than 0.
 *
 * 4. **Days vs Months**: Cannot use both days-based conditions (`createdBeforeInDays`, `lastDownloadedBeforeInDays`) and months-based conditions (`createdBeforeInMonths`, `lastDownloadedBeforeInMonths`) together.
 *
 * 5. **Properties Validation**: Properties-based conditions must have exactly one key with exactly one string value.
 *
 * 6. **Project Configuration**: When `includeAllProjects` is set to `true`, the `includedProjects` field can be empty array. When `includeAllProjects` is `false`, `includedProjects` must contain at least one project key.
 *
 * 7. **Project-level Policy Constraints**: When `projectKey` is specified (project-level policy):
 *    - `includeAllProjects` must be set to `false`
 *    - `includedProjects` should be empty array `[]`
 *    - Policy `key` must start with the project key value as a prefix followed by a hyphen
 *      - ✅ Valid: `projectKey = "myproj"` → `key = "myproj-cleanup-policy"`
 *      - ❌ Invalid: `projectKey = "myproj"` → `key = "cleanup-policy"` (missing prefix)
 *      - ❌ Invalid: `projectKey = "myproj"` → `key = "other-cleanup-policy"` (wrong prefix)
 *
 * ## Supported Package Types
 *
 * The following package types are supported for cleanup policies with their respective minimum Artifactory versions:
 *
 * - **alpine** - Alpine Linux packages (supported from 7.108.0)
 * - **ansible** - Ansible collections and roles (supported from 7.104.2)
 * - **cargo** - Rust Cargo packages (supported from 7.102.0)
 * - **chef** - Chef cookbooks (supported from 7.112.0)
 * - **cocoapods** - CocoaPods packages (supported from 7.99.1)
 * - **composer** - PHP Composer packages (supported from 7.116.0)
 * - **conan** - Conan C/C++ packages (supported from 7.98.2)
 * - **conda** - Conda packages (supported from 7.105.2)
 * - **debian** - Debian packages (supported from 7.98.2)
 * - **docker** - Docker images (supported from 7.98.2, version-based condition (keep_last_n_versions) from 7.115.1)
 * - **gems** - Ruby gems (supported from 7.96.3)
 * - **generic** - Generic packages (supported from 7.98.2, version-based conditions is not supported)
 * - **go** - Go modules (supported from 7.98.2)
 * - **gradle** - Gradle packages (supported from 7.98.2)
 * - **helm** - Helm charts (supported from 7.98.2)
 * - **helmoci** - Helm OCI charts (supported from 7.102.0, version-based conditions (keep_last_n_versions) from 7.115.1)
 * - **huggingfaceml** - Hugging Face ML models (supported from 7.100.0)
 * - **machinelearning** - Machine learning models (supported from 7.104.2)
 * - **maven** - Maven packages (supported from 7.98.2)
 * - **npm** - Node.js packages (supported from 7.98.2)
 * - **nuget** - .NET NuGet packages (supported from 7.98.2)
 * - **oci** - OCI images (supported from 7.90.1, version-based conditions (keep_last_n_versions) from 7.115.1)
 * - **puppet** - Puppet modules (supported from 7.112.0)
 * - **pypi** - Python packages (supported from 7.98.2)
 * - **rpm|yum** - RPM packages (supported from 7.98.2)
 * - **sbt** - Scala SBT packages (supported from 7.108.0)
 * - **swift** - Swift packages
 * - **terraform** - Terraform modules (supported from 7.99.1)
 * - **terraformbackend** - Terraform backend configurations (supported from 7.103.0)
 *
 * ## Version Compatibility
 *
 * - The `createdBeforeInDays` and `lastDownloadedBeforeInDays` attributes are only supported in Artifactory 7.111.2 and later. For earlier versions, use `createdBeforeInMonths` and `lastDownloadedBeforeInMonths`.
 *
 * ## Import
 *
 * ```sh
 * $ pulumi import artifactory:index/packageCleanupPolicy:PackageCleanupPolicy my-cleanup-policy my-policy
 *
 * $ pulumi import artifactory:index/packageCleanupPolicy:PackageCleanupPolicy my-cleanup-policy my-policy:myproj
 * ```
 */
export class PackageCleanupPolicy extends pulumi.CustomResource {
    /**
     * Get an existing PackageCleanupPolicy resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: PackageCleanupPolicyState, opts?: pulumi.CustomResourceOptions): PackageCleanupPolicy {
        return new PackageCleanupPolicy(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'artifactory:index/packageCleanupPolicy:PackageCleanupPolicy';

    /**
     * Returns true if the given object is an instance of PackageCleanupPolicy.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is PackageCleanupPolicy {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === PackageCleanupPolicy.__pulumiType;
    }

    /**
     * The cron expression that determines when the policy is run, However if left empty the policy will not run automatically and can only be triggered manually.
     */
    declare public readonly cronExpression: pulumi.Output<string | undefined>;
    declare public readonly description: pulumi.Output<string | undefined>;
    /**
     * The maximum duration (in minutes) for policy execution, after which the policy will stop running even if not completed. While setting a maximum run duration for a policy is useful for adhering to a strict cleanup schedule, it can cause the policy to stop before completion.
     */
    declare public readonly durationInMinutes: pulumi.Output<number>;
    /**
     * A cleanup policy must be created inactive. But if used it must be set to `false`. If set to `true` when calling this API, the API call will fail and an error message is received. Defaults to `true`
     */
    declare public readonly enabled: pulumi.Output<boolean>;
    /**
     * An ID that is used to identify the cleanup policy. A minimum of three characters is required and can include letters, numbers, underscore and hyphen.
     */
    declare public readonly key: pulumi.Output<string>;
    /**
     * This attribute is used only for project-level cleanup policies, it is not used for global-level policies. When specified, the policy will be scoped to the specified project. Note: The policy `key` must start with this project key value as a prefix (e.g., if `projectKey` is `"myproj"`, the `key` should be `"myproj-policy-name"`).
     */
    declare public readonly projectKey: pulumi.Output<string | undefined>;
    declare public readonly searchCriteria: pulumi.Output<outputs.PackageCleanupPolicySearchCriteria>;
    /**
     * A true value means that when this policy is executed, packages will be permanently deleted. false means that when the policy is executed packages will be deleted to the Trash Can. Defaults to `false`.
     */
    declare public readonly skipTrashcan: pulumi.Output<boolean>;

    /**
     * Create a PackageCleanupPolicy resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: PackageCleanupPolicyArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: PackageCleanupPolicyArgs | PackageCleanupPolicyState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as PackageCleanupPolicyState | undefined;
            resourceInputs["cronExpression"] = state?.cronExpression;
            resourceInputs["description"] = state?.description;
            resourceInputs["durationInMinutes"] = state?.durationInMinutes;
            resourceInputs["enabled"] = state?.enabled;
            resourceInputs["key"] = state?.key;
            resourceInputs["projectKey"] = state?.projectKey;
            resourceInputs["searchCriteria"] = state?.searchCriteria;
            resourceInputs["skipTrashcan"] = state?.skipTrashcan;
        } else {
            const args = argsOrState as PackageCleanupPolicyArgs | undefined;
            if (args?.key === undefined && !opts.urn) {
                throw new Error("Missing required property 'key'");
            }
            if (args?.searchCriteria === undefined && !opts.urn) {
                throw new Error("Missing required property 'searchCriteria'");
            }
            resourceInputs["cronExpression"] = args?.cronExpression;
            resourceInputs["description"] = args?.description;
            resourceInputs["durationInMinutes"] = args?.durationInMinutes;
            resourceInputs["enabled"] = args?.enabled;
            resourceInputs["key"] = args?.key;
            resourceInputs["projectKey"] = args?.projectKey;
            resourceInputs["searchCriteria"] = args?.searchCriteria;
            resourceInputs["skipTrashcan"] = args?.skipTrashcan;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(PackageCleanupPolicy.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering PackageCleanupPolicy resources.
 */
export interface PackageCleanupPolicyState {
    /**
     * The cron expression that determines when the policy is run, However if left empty the policy will not run automatically and can only be triggered manually.
     */
    cronExpression?: pulumi.Input<string>;
    description?: pulumi.Input<string>;
    /**
     * The maximum duration (in minutes) for policy execution, after which the policy will stop running even if not completed. While setting a maximum run duration for a policy is useful for adhering to a strict cleanup schedule, it can cause the policy to stop before completion.
     */
    durationInMinutes?: pulumi.Input<number>;
    /**
     * A cleanup policy must be created inactive. But if used it must be set to `false`. If set to `true` when calling this API, the API call will fail and an error message is received. Defaults to `true`
     */
    enabled?: pulumi.Input<boolean>;
    /**
     * An ID that is used to identify the cleanup policy. A minimum of three characters is required and can include letters, numbers, underscore and hyphen.
     */
    key?: pulumi.Input<string>;
    /**
     * This attribute is used only for project-level cleanup policies, it is not used for global-level policies. When specified, the policy will be scoped to the specified project. Note: The policy `key` must start with this project key value as a prefix (e.g., if `projectKey` is `"myproj"`, the `key` should be `"myproj-policy-name"`).
     */
    projectKey?: pulumi.Input<string>;
    searchCriteria?: pulumi.Input<inputs.PackageCleanupPolicySearchCriteria>;
    /**
     * A true value means that when this policy is executed, packages will be permanently deleted. false means that when the policy is executed packages will be deleted to the Trash Can. Defaults to `false`.
     */
    skipTrashcan?: pulumi.Input<boolean>;
}

/**
 * The set of arguments for constructing a PackageCleanupPolicy resource.
 */
export interface PackageCleanupPolicyArgs {
    /**
     * The cron expression that determines when the policy is run, However if left empty the policy will not run automatically and can only be triggered manually.
     */
    cronExpression?: pulumi.Input<string>;
    description?: pulumi.Input<string>;
    /**
     * The maximum duration (in minutes) for policy execution, after which the policy will stop running even if not completed. While setting a maximum run duration for a policy is useful for adhering to a strict cleanup schedule, it can cause the policy to stop before completion.
     */
    durationInMinutes?: pulumi.Input<number>;
    /**
     * A cleanup policy must be created inactive. But if used it must be set to `false`. If set to `true` when calling this API, the API call will fail and an error message is received. Defaults to `true`
     */
    enabled?: pulumi.Input<boolean>;
    /**
     * An ID that is used to identify the cleanup policy. A minimum of three characters is required and can include letters, numbers, underscore and hyphen.
     */
    key: pulumi.Input<string>;
    /**
     * This attribute is used only for project-level cleanup policies, it is not used for global-level policies. When specified, the policy will be scoped to the specified project. Note: The policy `key` must start with this project key value as a prefix (e.g., if `projectKey` is `"myproj"`, the `key` should be `"myproj-policy-name"`).
     */
    projectKey?: pulumi.Input<string>;
    searchCriteria: pulumi.Input<inputs.PackageCleanupPolicySearchCriteria>;
    /**
     * A true value means that when this policy is executed, packages will be permanently deleted. false means that when the policy is executed packages will be deleted to the Trash Can. Defaults to `false`.
     */
    skipTrashcan?: pulumi.Input<boolean>;
}
