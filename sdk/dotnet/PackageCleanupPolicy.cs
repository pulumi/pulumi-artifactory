// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Artifactory
{
    /// <summary>
    /// Provides an Artifactory Package Cleanup Policy resource. This resource enable system administrators to define and customize policies based on specific criteria for removing unused binaries from across their JFrog platform. Package cleanup policies are supported on the Cloud (7.98.2) and Self-Hosted (7.98.7) platforms, with an Enterprise+ license. See [Cleanup Policies](https://jfrog.com/help/r/jfrog-platform-administration-documentation/cleanup-policies) for more details.
    /// 
    /// ## Example Usage
    /// 
    /// ### Time-based Cleanup Policy (Days)
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Artifactory = Pulumi.Artifactory;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var my_cleanup_policy = new Artifactory.PackageCleanupPolicy("my-cleanup-policy", new()
    ///     {
    ///         Key = "my-cleanup-policy",
    ///         Description = "My cleanup policy",
    ///         CronExpression = "0 0 2 ? * MON-SAT *",
    ///         DurationInMinutes = 60,
    ///         Enabled = true,
    ///         SkipTrashcan = false,
    ///         SearchCriteria = new Artifactory.Inputs.PackageCleanupPolicySearchCriteriaArgs
    ///         {
    ///             PackageTypes = new[]
    ///             {
    ///                 "docker",
    ///                 "gradle",
    ///                 "maven",
    ///             },
    ///             Repos = new[]
    ///             {
    ///                 "**",
    ///             },
    ///             IncludeAllProjects = true,
    ///             IncludedProjects = new() { },
    ///             IncludedPackages = new[]
    ///             {
    ///                 "**",
    ///             },
    ///             ExcludedPackages = new[]
    ///             {
    ///                 "com/jfrog/latest",
    ///             },
    ///             CreatedBeforeInDays = 30,
    ///             LastDownloadedBeforeInDays = 60,
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ### Version-based Cleanup Policy
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Artifactory = Pulumi.Artifactory;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var my_version_policy = new Artifactory.PackageCleanupPolicy("my-version-policy", new()
    ///     {
    ///         Key = "my-version-policy",
    ///         Description = "Keep only latest versions",
    ///         CronExpression = "0 0 2 ? * MON-SAT *",
    ///         DurationInMinutes = 60,
    ///         Enabled = true,
    ///         SkipTrashcan = false,
    ///         SearchCriteria = new Artifactory.Inputs.PackageCleanupPolicySearchCriteriaArgs
    ///         {
    ///             PackageTypes = new[]
    ///             {
    ///                 "maven",
    ///             },
    ///             Repos = new[]
    ///             {
    ///                 "**",
    ///             },
    ///             IncludeAllProjects = true,
    ///             IncludedProjects = new() { },
    ///             IncludedPackages = new[]
    ///             {
    ///                 "**",
    ///             },
    ///             ExcludedPackages = new[]
    ///             {
    ///                 "com/jfrog/latest",
    ///             },
    ///             KeepLastNVersions = 5,
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ### Properties-based Cleanup Policy
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Artifactory = Pulumi.Artifactory;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var my_properties_policy = new Artifactory.PackageCleanupPolicy("my-properties-policy", new()
    ///     {
    ///         Key = "my-properties-policy",
    ///         Description = "Cleanup based on properties",
    ///         CronExpression = "0 0 2 ? * MON-SAT *",
    ///         DurationInMinutes = 60,
    ///         Enabled = true,
    ///         SkipTrashcan = false,
    ///         SearchCriteria = new Artifactory.Inputs.PackageCleanupPolicySearchCriteriaArgs
    ///         {
    ///             PackageTypes = new[]
    ///             {
    ///                 "docker",
    ///             },
    ///             Repos = new[]
    ///             {
    ///                 "**",
    ///             },
    ///             IncludeAllProjects = true,
    ///             IncludedProjects = new() { },
    ///             IncludedPackages = new[]
    ///             {
    ///                 "**",
    ///             },
    ///             ExcludedPackages = new[]
    ///             {
    ///                 "com/jfrog/latest",
    ///             },
    ///             IncludedProperties = 
    ///             {
    ///                 { "build.name", new[]
    ///                 {
    ///                     "my-app",
    ///                 } },
    ///             },
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ### Using Variables for Condition Fields
    /// 
    /// You can use Terraform variables for condition fields (`CreatedBeforeInDays`, `LastDownloadedBeforeInDays`, `CreatedBeforeInMonths`, `LastDownloadedBeforeInMonths`, `KeepLastNVersions`, `IncludedProperties`) and `DurationInMinutes`. The validator will skip validation when values are unknown (variables), allowing `terraform validate` to pass without requiring variable values.
    /// 
    /// **Example with variables:**
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Artifactory = Pulumi.Artifactory;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var config = new Config();
    ///     var cleanupPolicyLastDownloadedBeforeInDays = config.GetDouble("cleanupPolicyLastDownloadedBeforeInDays") ?? 60;
    ///     var cleanupPolicyDurationInMinutes = config.GetDouble("cleanupPolicyDurationInMinutes") ?? 120;
    ///     var my_cleanup_policy = new Artifactory.PackageCleanupPolicy("my-cleanup-policy", new()
    ///     {
    ///         Key = "my-cleanup-policy",
    ///         Description = "My cleanup policy with variables",
    ///         CronExpression = "0 0 2 ? * MON-SAT *",
    ///         DurationInMinutes = cleanupPolicyDurationInMinutes,
    ///         Enabled = true,
    ///         SkipTrashcan = false,
    ///         SearchCriteria = new Artifactory.Inputs.PackageCleanupPolicySearchCriteriaArgs
    ///         {
    ///             PackageTypes = new[]
    ///             {
    ///                 "docker",
    ///                 "generic",
    ///                 "helm",
    ///                 "helmoci",
    ///                 "nuget",
    ///                 "terraform",
    ///             },
    ///             Repos = new[]
    ///             {
    ///                 "**",
    ///             },
    ///             IncludeAllProjects = false,
    ///             IncludedProjects = new[]
    ///             {
    ///                 "default",
    ///             },
    ///             IncludedPackages = new[]
    ///             {
    ///                 "**",
    ///             },
    ///             ExcludedPackages = new[]
    ///             {
    ///                 "com/jfrog/latest",
    ///             },
    ///             LastDownloadedBeforeInDays = cleanupPolicyLastDownloadedBeforeInDays,
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// **Important Notes:**
    /// - Variables with default values allow `terraform validate` to pass without requiring variable values
    /// - Variables without default values will require values to be provided during `pulumi preview` or `pulumi up`
    /// - The validator automatically skips validation when condition field values are unknown (variables), preventing false validation errors during `terraform validate`
    /// 
    /// ## Validation Rules
    /// 
    /// The cleanup policy resource enforces the following validation rules:
    /// 
    /// 1. **Condition Types**: A policy must use exactly one of the following condition types:
    ///    - Time-based conditions (`days-based`)
    ///    - Version-based condition (`KeepLastNVersions`)
    ///    - Properties-based condition (`IncludedProperties`)
    /// 
    /// 2. **Mutual Exclusivity**: Cannot use multiple condition types together.
    /// 
    /// 3. **Zero Values**: Time-based and version-based conditions must have values greater than 0.
    /// 
    /// 4. **Days vs Months**: Cannot use both days-based conditions (`CreatedBeforeInDays`, `LastDownloadedBeforeInDays`) and months-based conditions (`CreatedBeforeInMonths`, `LastDownloadedBeforeInMonths`) together.
    /// 
    /// 5. **Properties Validation**: Properties-based conditions must have exactly one key with exactly one string value.
    /// 
    /// 6. **Project Configuration**: When `IncludeAllProjects` is set to `True`, the `IncludedProjects` field can be empty array. When `IncludeAllProjects` is `False`, `IncludedProjects` must contain at least one project key.
    /// 
    /// 7. **Project-level Policy Constraints**: When `ProjectKey` is specified (project-level policy):
    ///    - `IncludeAllProjects` must be set to `False`
    ///    - `IncludedProjects` should be empty array `[]`
    ///    - Policy `Key` must start with the project key value as a prefix followed by a hyphen
    ///      - ✅ Valid: `ProjectKey = "myproj"` → `key = "myproj-cleanup-policy"`
    ///      - ❌ Invalid: `ProjectKey = "myproj"` → `key = "cleanup-policy"` (missing prefix)
    ///      - ❌ Invalid: `ProjectKey = "myproj"` → `key = "other-cleanup-policy"` (wrong prefix)
    /// 
    /// ## Supported Package Types
    /// 
    /// The following package types are supported for cleanup policies with their respective minimum Artifactory versions:
    /// 
    /// - **alpine** - Alpine Linux packages (supported from 7.108.0)
    /// - **ansible** - Ansible collections and roles (supported from 7.104.2)
    /// - **cargo** - Rust Cargo packages (supported from 7.102.0)
    /// - **chef** - Chef cookbooks (supported from 7.112.0)
    /// - **cocoapods** - CocoaPods packages (supported from 7.99.1)
    /// - **composer** - PHP Composer packages (supported from 7.116.0)
    /// - **conan** - Conan C/C++ packages (supported from 7.98.2)
    /// - **conda** - Conda packages (supported from 7.105.2)
    /// - **debian** - Debian packages (supported from 7.98.2)
    /// - **docker** - Docker images (supported from 7.98.2, version-based condition (keep_last_n_versions) from 7.115.1)
    /// - **gems** - Ruby gems (supported from 7.96.3)
    /// - **generic** - Generic packages (supported from 7.98.2, version-based conditions is not supported)
    /// - **go** - Go modules (supported from 7.98.2)
    /// - **gradle** - Gradle packages (supported from 7.98.2)
    /// - **helm** - Helm charts (supported from 7.98.2)
    /// - **helmoci** - Helm OCI charts (supported from 7.102.0, version-based conditions (keep_last_n_versions) from 7.115.1)
    /// - **huggingfaceml** - Hugging Face ML models (supported from 7.100.0)
    /// - **machinelearning** - Machine learning models (supported from 7.104.2)
    /// - **maven** - Maven packages (supported from 7.98.2)
    /// - **npm** - Node.js packages (supported from 7.98.2)
    /// - **nuget** - .NET NuGet packages (supported from 7.98.2)
    /// - **oci** - OCI images (supported from 7.90.1, version-based conditions (keep_last_n_versions) from 7.115.1)
    /// - **puppet** - Puppet modules (supported from 7.112.0)
    /// - **pypi** - Python packages (supported from 7.98.2)
    /// - **rpm|yum** - RPM packages (supported from 7.98.2)
    /// - **sbt** - Scala SBT packages (supported from 7.108.0)
    /// - **swift** - Swift packages
    /// - **terraform** - Terraform modules (supported from 7.99.1)
    /// - **terraformbackend** - Terraform backend configurations (supported from 7.103.0)
    /// 
    /// ## Version Compatibility
    /// 
    /// - The `CreatedBeforeInDays` and `LastDownloadedBeforeInDays` attributes are only supported in Artifactory 7.111.2 and later. For earlier versions, use `CreatedBeforeInMonths` and `LastDownloadedBeforeInMonths`.
    /// 
    /// ## Import
    /// 
    /// ```sh
    /// $ pulumi import artifactory:index/packageCleanupPolicy:PackageCleanupPolicy my-cleanup-policy my-policy
    /// 
    /// $ pulumi import artifactory:index/packageCleanupPolicy:PackageCleanupPolicy my-cleanup-policy my-policy:myproj
    /// ```
    /// </summary>
    [ArtifactoryResourceType("artifactory:index/packageCleanupPolicy:PackageCleanupPolicy")]
    public partial class PackageCleanupPolicy : global::Pulumi.CustomResource
    {
        /// <summary>
        /// The cron expression that determines when the policy is run, However if left empty the policy will not run automatically and can only be triggered manually.
        /// </summary>
        [Output("cronExpression")]
        public Output<string?> CronExpression { get; private set; } = null!;

        [Output("description")]
        public Output<string?> Description { get; private set; } = null!;

        /// <summary>
        /// The maximum duration (in minutes) for policy execution, after which the policy will stop running even if not completed. While setting a maximum run duration for a policy is useful for adhering to a strict cleanup schedule, it can cause the policy to stop before completion.
        /// </summary>
        [Output("durationInMinutes")]
        public Output<int> DurationInMinutes { get; private set; } = null!;

        /// <summary>
        /// A cleanup policy must be created inactive. But if used it must be set to `False`. If set to `True` when calling this API, the API call will fail and an error message is received. Defaults to `True`
        /// </summary>
        [Output("enabled")]
        public Output<bool> Enabled { get; private set; } = null!;

        /// <summary>
        /// An ID that is used to identify the cleanup policy. A minimum of three characters is required and can include letters, numbers, underscore and hyphen.
        /// </summary>
        [Output("key")]
        public Output<string> Key { get; private set; } = null!;

        /// <summary>
        /// This attribute is used only for project-level cleanup policies, it is not used for global-level policies. When specified, the policy will be scoped to the specified project. Note: The policy `Key` must start with this project key value as a prefix (e.g., if `ProjectKey` is `"myproj"`, the `Key` should be `"myproj-policy-name"`).
        /// </summary>
        [Output("projectKey")]
        public Output<string?> ProjectKey { get; private set; } = null!;

        [Output("searchCriteria")]
        public Output<Outputs.PackageCleanupPolicySearchCriteria> SearchCriteria { get; private set; } = null!;

        /// <summary>
        /// A true value means that when this policy is executed, packages will be permanently deleted. false means that when the policy is executed packages will be deleted to the Trash Can. Defaults to `False`.
        /// </summary>
        [Output("skipTrashcan")]
        public Output<bool> SkipTrashcan { get; private set; } = null!;


        /// <summary>
        /// Create a PackageCleanupPolicy resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public PackageCleanupPolicy(string name, PackageCleanupPolicyArgs args, CustomResourceOptions? options = null)
            : base("artifactory:index/packageCleanupPolicy:PackageCleanupPolicy", name, args ?? new PackageCleanupPolicyArgs(), MakeResourceOptions(options, ""))
        {
        }

        private PackageCleanupPolicy(string name, Input<string> id, PackageCleanupPolicyState? state = null, CustomResourceOptions? options = null)
            : base("artifactory:index/packageCleanupPolicy:PackageCleanupPolicy", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing PackageCleanupPolicy resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static PackageCleanupPolicy Get(string name, Input<string> id, PackageCleanupPolicyState? state = null, CustomResourceOptions? options = null)
        {
            return new PackageCleanupPolicy(name, id, state, options);
        }
    }

    public sealed class PackageCleanupPolicyArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// The cron expression that determines when the policy is run, However if left empty the policy will not run automatically and can only be triggered manually.
        /// </summary>
        [Input("cronExpression")]
        public Input<string>? CronExpression { get; set; }

        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// The maximum duration (in minutes) for policy execution, after which the policy will stop running even if not completed. While setting a maximum run duration for a policy is useful for adhering to a strict cleanup schedule, it can cause the policy to stop before completion.
        /// </summary>
        [Input("durationInMinutes")]
        public Input<int>? DurationInMinutes { get; set; }

        /// <summary>
        /// A cleanup policy must be created inactive. But if used it must be set to `False`. If set to `True` when calling this API, the API call will fail and an error message is received. Defaults to `True`
        /// </summary>
        [Input("enabled")]
        public Input<bool>? Enabled { get; set; }

        /// <summary>
        /// An ID that is used to identify the cleanup policy. A minimum of three characters is required and can include letters, numbers, underscore and hyphen.
        /// </summary>
        [Input("key", required: true)]
        public Input<string> Key { get; set; } = null!;

        /// <summary>
        /// This attribute is used only for project-level cleanup policies, it is not used for global-level policies. When specified, the policy will be scoped to the specified project. Note: The policy `Key` must start with this project key value as a prefix (e.g., if `ProjectKey` is `"myproj"`, the `Key` should be `"myproj-policy-name"`).
        /// </summary>
        [Input("projectKey")]
        public Input<string>? ProjectKey { get; set; }

        [Input("searchCriteria", required: true)]
        public Input<Inputs.PackageCleanupPolicySearchCriteriaArgs> SearchCriteria { get; set; } = null!;

        /// <summary>
        /// A true value means that when this policy is executed, packages will be permanently deleted. false means that when the policy is executed packages will be deleted to the Trash Can. Defaults to `False`.
        /// </summary>
        [Input("skipTrashcan")]
        public Input<bool>? SkipTrashcan { get; set; }

        public PackageCleanupPolicyArgs()
        {
        }
        public static new PackageCleanupPolicyArgs Empty => new PackageCleanupPolicyArgs();
    }

    public sealed class PackageCleanupPolicyState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// The cron expression that determines when the policy is run, However if left empty the policy will not run automatically and can only be triggered manually.
        /// </summary>
        [Input("cronExpression")]
        public Input<string>? CronExpression { get; set; }

        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// The maximum duration (in minutes) for policy execution, after which the policy will stop running even if not completed. While setting a maximum run duration for a policy is useful for adhering to a strict cleanup schedule, it can cause the policy to stop before completion.
        /// </summary>
        [Input("durationInMinutes")]
        public Input<int>? DurationInMinutes { get; set; }

        /// <summary>
        /// A cleanup policy must be created inactive. But if used it must be set to `False`. If set to `True` when calling this API, the API call will fail and an error message is received. Defaults to `True`
        /// </summary>
        [Input("enabled")]
        public Input<bool>? Enabled { get; set; }

        /// <summary>
        /// An ID that is used to identify the cleanup policy. A minimum of three characters is required and can include letters, numbers, underscore and hyphen.
        /// </summary>
        [Input("key")]
        public Input<string>? Key { get; set; }

        /// <summary>
        /// This attribute is used only for project-level cleanup policies, it is not used for global-level policies. When specified, the policy will be scoped to the specified project. Note: The policy `Key` must start with this project key value as a prefix (e.g., if `ProjectKey` is `"myproj"`, the `Key` should be `"myproj-policy-name"`).
        /// </summary>
        [Input("projectKey")]
        public Input<string>? ProjectKey { get; set; }

        [Input("searchCriteria")]
        public Input<Inputs.PackageCleanupPolicySearchCriteriaGetArgs>? SearchCriteria { get; set; }

        /// <summary>
        /// A true value means that when this policy is executed, packages will be permanently deleted. false means that when the policy is executed packages will be deleted to the Trash Can. Defaults to `False`.
        /// </summary>
        [Input("skipTrashcan")]
        public Input<bool>? SkipTrashcan { get; set; }

        public PackageCleanupPolicyState()
        {
        }
        public static new PackageCleanupPolicyState Empty => new PackageCleanupPolicyState();
    }
}
