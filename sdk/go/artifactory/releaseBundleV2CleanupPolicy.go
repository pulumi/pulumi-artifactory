// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package artifactory

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-artifactory/sdk/v8/go/artifactory/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Provides an Artifactory Archive Policy resource. This resource enable system administrators to configure and maintain JFrog cleanup policies for Release Bundles V2. See [Cleanup Policies](https://jfrog.com/help/r/jfrog-rest-apis/cleanup-policies-release-bundles-v2-apis) for more details.
//
// ~>Release Bundles V2 Cleanup Policies APIs are supported on Artifactory version 7.104.2 and later.
//
// ## Import
//
// ```sh
// $ pulumi import artifactory:index/releaseBundleV2CleanupPolicy:ReleaseBundleV2CleanupPolicy my-cleanup-policy my-policy
// ```
type ReleaseBundleV2CleanupPolicy struct {
	pulumi.CustomResourceState

	// The cron expression determines when the policy is run. This parameter is not mandatory, however if left empty the policy will not run automatically and can only be triggered manually.
	CronExpression pulumi.StringPtrOutput `pulumi:"cronExpression"`
	Description    pulumi.StringPtrOutput `pulumi:"description"`
	// The maximum duration (in minutes) for policy execution, after which the policy will stop running even if not completed. While setting a maximum run duration for a policy is useful for adhering to a strict archive V2 schedule, it can cause the policy to stop before completion.
	DurationInMinutes pulumi.IntPtrOutput `pulumi:"durationInMinutes"`
	// Enables or disabled the release bundles v2 cleanup policy. This allows the user to run the policy manually. If a policy has a valid cron expression, then it will be scheduled for execution based on it. If a policy is disabled, its future executions will be unscheduled. Defaults to `true`
	Enabled pulumi.BoolOutput `pulumi:"enabled"`
	// Needs to be set to releaseBundle.
	ItemType pulumi.StringOutput `pulumi:"itemType"`
	// An ID that is used to identify the cleanup policy. A minimum of three characters is required and can include letters, numbers, underscore and hyphen.
	Key            pulumi.StringOutput                              `pulumi:"key"`
	SearchCriteria ReleaseBundleV2CleanupPolicySearchCriteriaOutput `pulumi:"searchCriteria"`
}

// NewReleaseBundleV2CleanupPolicy registers a new resource with the given unique name, arguments, and options.
func NewReleaseBundleV2CleanupPolicy(ctx *pulumi.Context,
	name string, args *ReleaseBundleV2CleanupPolicyArgs, opts ...pulumi.ResourceOption) (*ReleaseBundleV2CleanupPolicy, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Key == nil {
		return nil, errors.New("invalid value for required argument 'Key'")
	}
	if args.SearchCriteria == nil {
		return nil, errors.New("invalid value for required argument 'SearchCriteria'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource ReleaseBundleV2CleanupPolicy
	err := ctx.RegisterResource("artifactory:index/releaseBundleV2CleanupPolicy:ReleaseBundleV2CleanupPolicy", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetReleaseBundleV2CleanupPolicy gets an existing ReleaseBundleV2CleanupPolicy resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetReleaseBundleV2CleanupPolicy(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ReleaseBundleV2CleanupPolicyState, opts ...pulumi.ResourceOption) (*ReleaseBundleV2CleanupPolicy, error) {
	var resource ReleaseBundleV2CleanupPolicy
	err := ctx.ReadResource("artifactory:index/releaseBundleV2CleanupPolicy:ReleaseBundleV2CleanupPolicy", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ReleaseBundleV2CleanupPolicy resources.
type releaseBundleV2CleanupPolicyState struct {
	// The cron expression determines when the policy is run. This parameter is not mandatory, however if left empty the policy will not run automatically and can only be triggered manually.
	CronExpression *string `pulumi:"cronExpression"`
	Description    *string `pulumi:"description"`
	// The maximum duration (in minutes) for policy execution, after which the policy will stop running even if not completed. While setting a maximum run duration for a policy is useful for adhering to a strict archive V2 schedule, it can cause the policy to stop before completion.
	DurationInMinutes *int `pulumi:"durationInMinutes"`
	// Enables or disabled the release bundles v2 cleanup policy. This allows the user to run the policy manually. If a policy has a valid cron expression, then it will be scheduled for execution based on it. If a policy is disabled, its future executions will be unscheduled. Defaults to `true`
	Enabled *bool `pulumi:"enabled"`
	// Needs to be set to releaseBundle.
	ItemType *string `pulumi:"itemType"`
	// An ID that is used to identify the cleanup policy. A minimum of three characters is required and can include letters, numbers, underscore and hyphen.
	Key            *string                                     `pulumi:"key"`
	SearchCriteria *ReleaseBundleV2CleanupPolicySearchCriteria `pulumi:"searchCriteria"`
}

type ReleaseBundleV2CleanupPolicyState struct {
	// The cron expression determines when the policy is run. This parameter is not mandatory, however if left empty the policy will not run automatically and can only be triggered manually.
	CronExpression pulumi.StringPtrInput
	Description    pulumi.StringPtrInput
	// The maximum duration (in minutes) for policy execution, after which the policy will stop running even if not completed. While setting a maximum run duration for a policy is useful for adhering to a strict archive V2 schedule, it can cause the policy to stop before completion.
	DurationInMinutes pulumi.IntPtrInput
	// Enables or disabled the release bundles v2 cleanup policy. This allows the user to run the policy manually. If a policy has a valid cron expression, then it will be scheduled for execution based on it. If a policy is disabled, its future executions will be unscheduled. Defaults to `true`
	Enabled pulumi.BoolPtrInput
	// Needs to be set to releaseBundle.
	ItemType pulumi.StringPtrInput
	// An ID that is used to identify the cleanup policy. A minimum of three characters is required and can include letters, numbers, underscore and hyphen.
	Key            pulumi.StringPtrInput
	SearchCriteria ReleaseBundleV2CleanupPolicySearchCriteriaPtrInput
}

func (ReleaseBundleV2CleanupPolicyState) ElementType() reflect.Type {
	return reflect.TypeOf((*releaseBundleV2CleanupPolicyState)(nil)).Elem()
}

type releaseBundleV2CleanupPolicyArgs struct {
	// The cron expression determines when the policy is run. This parameter is not mandatory, however if left empty the policy will not run automatically and can only be triggered manually.
	CronExpression *string `pulumi:"cronExpression"`
	Description    *string `pulumi:"description"`
	// The maximum duration (in minutes) for policy execution, after which the policy will stop running even if not completed. While setting a maximum run duration for a policy is useful for adhering to a strict archive V2 schedule, it can cause the policy to stop before completion.
	DurationInMinutes *int `pulumi:"durationInMinutes"`
	// Enables or disabled the release bundles v2 cleanup policy. This allows the user to run the policy manually. If a policy has a valid cron expression, then it will be scheduled for execution based on it. If a policy is disabled, its future executions will be unscheduled. Defaults to `true`
	Enabled *bool `pulumi:"enabled"`
	// Needs to be set to releaseBundle.
	ItemType *string `pulumi:"itemType"`
	// An ID that is used to identify the cleanup policy. A minimum of three characters is required and can include letters, numbers, underscore and hyphen.
	Key            string                                     `pulumi:"key"`
	SearchCriteria ReleaseBundleV2CleanupPolicySearchCriteria `pulumi:"searchCriteria"`
}

// The set of arguments for constructing a ReleaseBundleV2CleanupPolicy resource.
type ReleaseBundleV2CleanupPolicyArgs struct {
	// The cron expression determines when the policy is run. This parameter is not mandatory, however if left empty the policy will not run automatically and can only be triggered manually.
	CronExpression pulumi.StringPtrInput
	Description    pulumi.StringPtrInput
	// The maximum duration (in minutes) for policy execution, after which the policy will stop running even if not completed. While setting a maximum run duration for a policy is useful for adhering to a strict archive V2 schedule, it can cause the policy to stop before completion.
	DurationInMinutes pulumi.IntPtrInput
	// Enables or disabled the release bundles v2 cleanup policy. This allows the user to run the policy manually. If a policy has a valid cron expression, then it will be scheduled for execution based on it. If a policy is disabled, its future executions will be unscheduled. Defaults to `true`
	Enabled pulumi.BoolPtrInput
	// Needs to be set to releaseBundle.
	ItemType pulumi.StringPtrInput
	// An ID that is used to identify the cleanup policy. A minimum of three characters is required and can include letters, numbers, underscore and hyphen.
	Key            pulumi.StringInput
	SearchCriteria ReleaseBundleV2CleanupPolicySearchCriteriaInput
}

func (ReleaseBundleV2CleanupPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*releaseBundleV2CleanupPolicyArgs)(nil)).Elem()
}

type ReleaseBundleV2CleanupPolicyInput interface {
	pulumi.Input

	ToReleaseBundleV2CleanupPolicyOutput() ReleaseBundleV2CleanupPolicyOutput
	ToReleaseBundleV2CleanupPolicyOutputWithContext(ctx context.Context) ReleaseBundleV2CleanupPolicyOutput
}

func (*ReleaseBundleV2CleanupPolicy) ElementType() reflect.Type {
	return reflect.TypeOf((**ReleaseBundleV2CleanupPolicy)(nil)).Elem()
}

func (i *ReleaseBundleV2CleanupPolicy) ToReleaseBundleV2CleanupPolicyOutput() ReleaseBundleV2CleanupPolicyOutput {
	return i.ToReleaseBundleV2CleanupPolicyOutputWithContext(context.Background())
}

func (i *ReleaseBundleV2CleanupPolicy) ToReleaseBundleV2CleanupPolicyOutputWithContext(ctx context.Context) ReleaseBundleV2CleanupPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ReleaseBundleV2CleanupPolicyOutput)
}

// ReleaseBundleV2CleanupPolicyArrayInput is an input type that accepts ReleaseBundleV2CleanupPolicyArray and ReleaseBundleV2CleanupPolicyArrayOutput values.
// You can construct a concrete instance of `ReleaseBundleV2CleanupPolicyArrayInput` via:
//
//	ReleaseBundleV2CleanupPolicyArray{ ReleaseBundleV2CleanupPolicyArgs{...} }
type ReleaseBundleV2CleanupPolicyArrayInput interface {
	pulumi.Input

	ToReleaseBundleV2CleanupPolicyArrayOutput() ReleaseBundleV2CleanupPolicyArrayOutput
	ToReleaseBundleV2CleanupPolicyArrayOutputWithContext(context.Context) ReleaseBundleV2CleanupPolicyArrayOutput
}

type ReleaseBundleV2CleanupPolicyArray []ReleaseBundleV2CleanupPolicyInput

func (ReleaseBundleV2CleanupPolicyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ReleaseBundleV2CleanupPolicy)(nil)).Elem()
}

func (i ReleaseBundleV2CleanupPolicyArray) ToReleaseBundleV2CleanupPolicyArrayOutput() ReleaseBundleV2CleanupPolicyArrayOutput {
	return i.ToReleaseBundleV2CleanupPolicyArrayOutputWithContext(context.Background())
}

func (i ReleaseBundleV2CleanupPolicyArray) ToReleaseBundleV2CleanupPolicyArrayOutputWithContext(ctx context.Context) ReleaseBundleV2CleanupPolicyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ReleaseBundleV2CleanupPolicyArrayOutput)
}

// ReleaseBundleV2CleanupPolicyMapInput is an input type that accepts ReleaseBundleV2CleanupPolicyMap and ReleaseBundleV2CleanupPolicyMapOutput values.
// You can construct a concrete instance of `ReleaseBundleV2CleanupPolicyMapInput` via:
//
//	ReleaseBundleV2CleanupPolicyMap{ "key": ReleaseBundleV2CleanupPolicyArgs{...} }
type ReleaseBundleV2CleanupPolicyMapInput interface {
	pulumi.Input

	ToReleaseBundleV2CleanupPolicyMapOutput() ReleaseBundleV2CleanupPolicyMapOutput
	ToReleaseBundleV2CleanupPolicyMapOutputWithContext(context.Context) ReleaseBundleV2CleanupPolicyMapOutput
}

type ReleaseBundleV2CleanupPolicyMap map[string]ReleaseBundleV2CleanupPolicyInput

func (ReleaseBundleV2CleanupPolicyMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ReleaseBundleV2CleanupPolicy)(nil)).Elem()
}

func (i ReleaseBundleV2CleanupPolicyMap) ToReleaseBundleV2CleanupPolicyMapOutput() ReleaseBundleV2CleanupPolicyMapOutput {
	return i.ToReleaseBundleV2CleanupPolicyMapOutputWithContext(context.Background())
}

func (i ReleaseBundleV2CleanupPolicyMap) ToReleaseBundleV2CleanupPolicyMapOutputWithContext(ctx context.Context) ReleaseBundleV2CleanupPolicyMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ReleaseBundleV2CleanupPolicyMapOutput)
}

type ReleaseBundleV2CleanupPolicyOutput struct{ *pulumi.OutputState }

func (ReleaseBundleV2CleanupPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ReleaseBundleV2CleanupPolicy)(nil)).Elem()
}

func (o ReleaseBundleV2CleanupPolicyOutput) ToReleaseBundleV2CleanupPolicyOutput() ReleaseBundleV2CleanupPolicyOutput {
	return o
}

func (o ReleaseBundleV2CleanupPolicyOutput) ToReleaseBundleV2CleanupPolicyOutputWithContext(ctx context.Context) ReleaseBundleV2CleanupPolicyOutput {
	return o
}

// The cron expression determines when the policy is run. This parameter is not mandatory, however if left empty the policy will not run automatically and can only be triggered manually.
func (o ReleaseBundleV2CleanupPolicyOutput) CronExpression() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ReleaseBundleV2CleanupPolicy) pulumi.StringPtrOutput { return v.CronExpression }).(pulumi.StringPtrOutput)
}

func (o ReleaseBundleV2CleanupPolicyOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ReleaseBundleV2CleanupPolicy) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// The maximum duration (in minutes) for policy execution, after which the policy will stop running even if not completed. While setting a maximum run duration for a policy is useful for adhering to a strict archive V2 schedule, it can cause the policy to stop before completion.
func (o ReleaseBundleV2CleanupPolicyOutput) DurationInMinutes() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ReleaseBundleV2CleanupPolicy) pulumi.IntPtrOutput { return v.DurationInMinutes }).(pulumi.IntPtrOutput)
}

// Enables or disabled the release bundles v2 cleanup policy. This allows the user to run the policy manually. If a policy has a valid cron expression, then it will be scheduled for execution based on it. If a policy is disabled, its future executions will be unscheduled. Defaults to `true`
func (o ReleaseBundleV2CleanupPolicyOutput) Enabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *ReleaseBundleV2CleanupPolicy) pulumi.BoolOutput { return v.Enabled }).(pulumi.BoolOutput)
}

// Needs to be set to releaseBundle.
func (o ReleaseBundleV2CleanupPolicyOutput) ItemType() pulumi.StringOutput {
	return o.ApplyT(func(v *ReleaseBundleV2CleanupPolicy) pulumi.StringOutput { return v.ItemType }).(pulumi.StringOutput)
}

// An ID that is used to identify the cleanup policy. A minimum of three characters is required and can include letters, numbers, underscore and hyphen.
func (o ReleaseBundleV2CleanupPolicyOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v *ReleaseBundleV2CleanupPolicy) pulumi.StringOutput { return v.Key }).(pulumi.StringOutput)
}

func (o ReleaseBundleV2CleanupPolicyOutput) SearchCriteria() ReleaseBundleV2CleanupPolicySearchCriteriaOutput {
	return o.ApplyT(func(v *ReleaseBundleV2CleanupPolicy) ReleaseBundleV2CleanupPolicySearchCriteriaOutput {
		return v.SearchCriteria
	}).(ReleaseBundleV2CleanupPolicySearchCriteriaOutput)
}

type ReleaseBundleV2CleanupPolicyArrayOutput struct{ *pulumi.OutputState }

func (ReleaseBundleV2CleanupPolicyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ReleaseBundleV2CleanupPolicy)(nil)).Elem()
}

func (o ReleaseBundleV2CleanupPolicyArrayOutput) ToReleaseBundleV2CleanupPolicyArrayOutput() ReleaseBundleV2CleanupPolicyArrayOutput {
	return o
}

func (o ReleaseBundleV2CleanupPolicyArrayOutput) ToReleaseBundleV2CleanupPolicyArrayOutputWithContext(ctx context.Context) ReleaseBundleV2CleanupPolicyArrayOutput {
	return o
}

func (o ReleaseBundleV2CleanupPolicyArrayOutput) Index(i pulumi.IntInput) ReleaseBundleV2CleanupPolicyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ReleaseBundleV2CleanupPolicy {
		return vs[0].([]*ReleaseBundleV2CleanupPolicy)[vs[1].(int)]
	}).(ReleaseBundleV2CleanupPolicyOutput)
}

type ReleaseBundleV2CleanupPolicyMapOutput struct{ *pulumi.OutputState }

func (ReleaseBundleV2CleanupPolicyMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ReleaseBundleV2CleanupPolicy)(nil)).Elem()
}

func (o ReleaseBundleV2CleanupPolicyMapOutput) ToReleaseBundleV2CleanupPolicyMapOutput() ReleaseBundleV2CleanupPolicyMapOutput {
	return o
}

func (o ReleaseBundleV2CleanupPolicyMapOutput) ToReleaseBundleV2CleanupPolicyMapOutputWithContext(ctx context.Context) ReleaseBundleV2CleanupPolicyMapOutput {
	return o
}

func (o ReleaseBundleV2CleanupPolicyMapOutput) MapIndex(k pulumi.StringInput) ReleaseBundleV2CleanupPolicyOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ReleaseBundleV2CleanupPolicy {
		return vs[0].(map[string]*ReleaseBundleV2CleanupPolicy)[vs[1].(string)]
	}).(ReleaseBundleV2CleanupPolicyOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ReleaseBundleV2CleanupPolicyInput)(nil)).Elem(), &ReleaseBundleV2CleanupPolicy{})
	pulumi.RegisterInputType(reflect.TypeOf((*ReleaseBundleV2CleanupPolicyArrayInput)(nil)).Elem(), ReleaseBundleV2CleanupPolicyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ReleaseBundleV2CleanupPolicyMapInput)(nil)).Elem(), ReleaseBundleV2CleanupPolicyMap{})
	pulumi.RegisterOutputType(ReleaseBundleV2CleanupPolicyOutput{})
	pulumi.RegisterOutputType(ReleaseBundleV2CleanupPolicyArrayOutput{})
	pulumi.RegisterOutputType(ReleaseBundleV2CleanupPolicyMapOutput{})
}
