// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package artifactory

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-artifactory/sdk/v8/go/artifactory/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Provides an Artifactory Archive Policy resource. This resource enable system administrators to define and customize policies based on specific criteria for removing unused binaries from across their JFrog platform. See [Retention Policies](https://jfrog.com/help/r/jfrog-platform-administration-documentation/retention-policies) for more details.
//
// ~>Currently in beta and not yet globally available. A full rollout is scheduled for Q1 2025.
//
// ## Import
//
// ```sh
// $ pulumi import artifactory:index/archivePolicy:ArchivePolicy my-archive-policy my-policy
// ```
//
// ```sh
// $ pulumi import artifactory:index/archivePolicy:ArchivePolicy my-archive-policy my-policy:myproj
// ```
type ArchivePolicy struct {
	pulumi.CustomResourceState

	// The cron expression determines when the policy is run. This parameter is not mandatory, however if left empty the policy will not run automatically and can only be triggered manually.
	CronExpression pulumi.StringPtrOutput `pulumi:"cronExpression"`
	Description    pulumi.StringPtrOutput `pulumi:"description"`
	// The maximum duration (in minutes) for policy execution, after which the policy will stop running even if not completed. While setting a maximum run duration for a policy is useful for adhering to a strict archive V2 schedule, it can cause the policy to stop before completion.
	DurationInMinutes pulumi.IntPtrOutput `pulumi:"durationInMinutes"`
	// Enables or disabled the package cleanup policy. This allows the user to run the policy manually. If a policy has a valid cron expression, then it will be scheduled for execution based on it. If a policy is disabled, its future executions will be unscheduled. Defaults to `true`
	Enabled pulumi.BoolOutput `pulumi:"enabled"`
	// An ID that is used to identify the archive policy. A minimum of three characters is required and can include letters, numbers, underscore and hyphen.
	Key pulumi.StringOutput `pulumi:"key"`
	// This attribute is used only for project-level archive V2 policies, it is not used for global-level policies.
	ProjectKey     pulumi.StringPtrOutput            `pulumi:"projectKey"`
	SearchCriteria ArchivePolicySearchCriteriaOutput `pulumi:"searchCriteria"`
	// A `true` value means that when this policy is executed, packages will be permanently deleted. `false` means that when the policy is executed packages will be deleted to the Trash Can. Defaults to `false`.
	SkipTrashcan pulumi.BoolOutput `pulumi:"skipTrashcan"`
}

// NewArchivePolicy registers a new resource with the given unique name, arguments, and options.
func NewArchivePolicy(ctx *pulumi.Context,
	name string, args *ArchivePolicyArgs, opts ...pulumi.ResourceOption) (*ArchivePolicy, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Key == nil {
		return nil, errors.New("invalid value for required argument 'Key'")
	}
	if args.SearchCriteria == nil {
		return nil, errors.New("invalid value for required argument 'SearchCriteria'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource ArchivePolicy
	err := ctx.RegisterResource("artifactory:index/archivePolicy:ArchivePolicy", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetArchivePolicy gets an existing ArchivePolicy resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetArchivePolicy(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ArchivePolicyState, opts ...pulumi.ResourceOption) (*ArchivePolicy, error) {
	var resource ArchivePolicy
	err := ctx.ReadResource("artifactory:index/archivePolicy:ArchivePolicy", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ArchivePolicy resources.
type archivePolicyState struct {
	// The cron expression determines when the policy is run. This parameter is not mandatory, however if left empty the policy will not run automatically and can only be triggered manually.
	CronExpression *string `pulumi:"cronExpression"`
	Description    *string `pulumi:"description"`
	// The maximum duration (in minutes) for policy execution, after which the policy will stop running even if not completed. While setting a maximum run duration for a policy is useful for adhering to a strict archive V2 schedule, it can cause the policy to stop before completion.
	DurationInMinutes *int `pulumi:"durationInMinutes"`
	// Enables or disabled the package cleanup policy. This allows the user to run the policy manually. If a policy has a valid cron expression, then it will be scheduled for execution based on it. If a policy is disabled, its future executions will be unscheduled. Defaults to `true`
	Enabled *bool `pulumi:"enabled"`
	// An ID that is used to identify the archive policy. A minimum of three characters is required and can include letters, numbers, underscore and hyphen.
	Key *string `pulumi:"key"`
	// This attribute is used only for project-level archive V2 policies, it is not used for global-level policies.
	ProjectKey     *string                      `pulumi:"projectKey"`
	SearchCriteria *ArchivePolicySearchCriteria `pulumi:"searchCriteria"`
	// A `true` value means that when this policy is executed, packages will be permanently deleted. `false` means that when the policy is executed packages will be deleted to the Trash Can. Defaults to `false`.
	SkipTrashcan *bool `pulumi:"skipTrashcan"`
}

type ArchivePolicyState struct {
	// The cron expression determines when the policy is run. This parameter is not mandatory, however if left empty the policy will not run automatically and can only be triggered manually.
	CronExpression pulumi.StringPtrInput
	Description    pulumi.StringPtrInput
	// The maximum duration (in minutes) for policy execution, after which the policy will stop running even if not completed. While setting a maximum run duration for a policy is useful for adhering to a strict archive V2 schedule, it can cause the policy to stop before completion.
	DurationInMinutes pulumi.IntPtrInput
	// Enables or disabled the package cleanup policy. This allows the user to run the policy manually. If a policy has a valid cron expression, then it will be scheduled for execution based on it. If a policy is disabled, its future executions will be unscheduled. Defaults to `true`
	Enabled pulumi.BoolPtrInput
	// An ID that is used to identify the archive policy. A minimum of three characters is required and can include letters, numbers, underscore and hyphen.
	Key pulumi.StringPtrInput
	// This attribute is used only for project-level archive V2 policies, it is not used for global-level policies.
	ProjectKey     pulumi.StringPtrInput
	SearchCriteria ArchivePolicySearchCriteriaPtrInput
	// A `true` value means that when this policy is executed, packages will be permanently deleted. `false` means that when the policy is executed packages will be deleted to the Trash Can. Defaults to `false`.
	SkipTrashcan pulumi.BoolPtrInput
}

func (ArchivePolicyState) ElementType() reflect.Type {
	return reflect.TypeOf((*archivePolicyState)(nil)).Elem()
}

type archivePolicyArgs struct {
	// The cron expression determines when the policy is run. This parameter is not mandatory, however if left empty the policy will not run automatically and can only be triggered manually.
	CronExpression *string `pulumi:"cronExpression"`
	Description    *string `pulumi:"description"`
	// The maximum duration (in minutes) for policy execution, after which the policy will stop running even if not completed. While setting a maximum run duration for a policy is useful for adhering to a strict archive V2 schedule, it can cause the policy to stop before completion.
	DurationInMinutes *int `pulumi:"durationInMinutes"`
	// Enables or disabled the package cleanup policy. This allows the user to run the policy manually. If a policy has a valid cron expression, then it will be scheduled for execution based on it. If a policy is disabled, its future executions will be unscheduled. Defaults to `true`
	Enabled *bool `pulumi:"enabled"`
	// An ID that is used to identify the archive policy. A minimum of three characters is required and can include letters, numbers, underscore and hyphen.
	Key string `pulumi:"key"`
	// This attribute is used only for project-level archive V2 policies, it is not used for global-level policies.
	ProjectKey     *string                     `pulumi:"projectKey"`
	SearchCriteria ArchivePolicySearchCriteria `pulumi:"searchCriteria"`
	// A `true` value means that when this policy is executed, packages will be permanently deleted. `false` means that when the policy is executed packages will be deleted to the Trash Can. Defaults to `false`.
	SkipTrashcan *bool `pulumi:"skipTrashcan"`
}

// The set of arguments for constructing a ArchivePolicy resource.
type ArchivePolicyArgs struct {
	// The cron expression determines when the policy is run. This parameter is not mandatory, however if left empty the policy will not run automatically and can only be triggered manually.
	CronExpression pulumi.StringPtrInput
	Description    pulumi.StringPtrInput
	// The maximum duration (in minutes) for policy execution, after which the policy will stop running even if not completed. While setting a maximum run duration for a policy is useful for adhering to a strict archive V2 schedule, it can cause the policy to stop before completion.
	DurationInMinutes pulumi.IntPtrInput
	// Enables or disabled the package cleanup policy. This allows the user to run the policy manually. If a policy has a valid cron expression, then it will be scheduled for execution based on it. If a policy is disabled, its future executions will be unscheduled. Defaults to `true`
	Enabled pulumi.BoolPtrInput
	// An ID that is used to identify the archive policy. A minimum of three characters is required and can include letters, numbers, underscore and hyphen.
	Key pulumi.StringInput
	// This attribute is used only for project-level archive V2 policies, it is not used for global-level policies.
	ProjectKey     pulumi.StringPtrInput
	SearchCriteria ArchivePolicySearchCriteriaInput
	// A `true` value means that when this policy is executed, packages will be permanently deleted. `false` means that when the policy is executed packages will be deleted to the Trash Can. Defaults to `false`.
	SkipTrashcan pulumi.BoolPtrInput
}

func (ArchivePolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*archivePolicyArgs)(nil)).Elem()
}

type ArchivePolicyInput interface {
	pulumi.Input

	ToArchivePolicyOutput() ArchivePolicyOutput
	ToArchivePolicyOutputWithContext(ctx context.Context) ArchivePolicyOutput
}

func (*ArchivePolicy) ElementType() reflect.Type {
	return reflect.TypeOf((**ArchivePolicy)(nil)).Elem()
}

func (i *ArchivePolicy) ToArchivePolicyOutput() ArchivePolicyOutput {
	return i.ToArchivePolicyOutputWithContext(context.Background())
}

func (i *ArchivePolicy) ToArchivePolicyOutputWithContext(ctx context.Context) ArchivePolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ArchivePolicyOutput)
}

// ArchivePolicyArrayInput is an input type that accepts ArchivePolicyArray and ArchivePolicyArrayOutput values.
// You can construct a concrete instance of `ArchivePolicyArrayInput` via:
//
//	ArchivePolicyArray{ ArchivePolicyArgs{...} }
type ArchivePolicyArrayInput interface {
	pulumi.Input

	ToArchivePolicyArrayOutput() ArchivePolicyArrayOutput
	ToArchivePolicyArrayOutputWithContext(context.Context) ArchivePolicyArrayOutput
}

type ArchivePolicyArray []ArchivePolicyInput

func (ArchivePolicyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ArchivePolicy)(nil)).Elem()
}

func (i ArchivePolicyArray) ToArchivePolicyArrayOutput() ArchivePolicyArrayOutput {
	return i.ToArchivePolicyArrayOutputWithContext(context.Background())
}

func (i ArchivePolicyArray) ToArchivePolicyArrayOutputWithContext(ctx context.Context) ArchivePolicyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ArchivePolicyArrayOutput)
}

// ArchivePolicyMapInput is an input type that accepts ArchivePolicyMap and ArchivePolicyMapOutput values.
// You can construct a concrete instance of `ArchivePolicyMapInput` via:
//
//	ArchivePolicyMap{ "key": ArchivePolicyArgs{...} }
type ArchivePolicyMapInput interface {
	pulumi.Input

	ToArchivePolicyMapOutput() ArchivePolicyMapOutput
	ToArchivePolicyMapOutputWithContext(context.Context) ArchivePolicyMapOutput
}

type ArchivePolicyMap map[string]ArchivePolicyInput

func (ArchivePolicyMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ArchivePolicy)(nil)).Elem()
}

func (i ArchivePolicyMap) ToArchivePolicyMapOutput() ArchivePolicyMapOutput {
	return i.ToArchivePolicyMapOutputWithContext(context.Background())
}

func (i ArchivePolicyMap) ToArchivePolicyMapOutputWithContext(ctx context.Context) ArchivePolicyMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ArchivePolicyMapOutput)
}

type ArchivePolicyOutput struct{ *pulumi.OutputState }

func (ArchivePolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ArchivePolicy)(nil)).Elem()
}

func (o ArchivePolicyOutput) ToArchivePolicyOutput() ArchivePolicyOutput {
	return o
}

func (o ArchivePolicyOutput) ToArchivePolicyOutputWithContext(ctx context.Context) ArchivePolicyOutput {
	return o
}

// The cron expression determines when the policy is run. This parameter is not mandatory, however if left empty the policy will not run automatically and can only be triggered manually.
func (o ArchivePolicyOutput) CronExpression() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ArchivePolicy) pulumi.StringPtrOutput { return v.CronExpression }).(pulumi.StringPtrOutput)
}

func (o ArchivePolicyOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ArchivePolicy) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// The maximum duration (in minutes) for policy execution, after which the policy will stop running even if not completed. While setting a maximum run duration for a policy is useful for adhering to a strict archive V2 schedule, it can cause the policy to stop before completion.
func (o ArchivePolicyOutput) DurationInMinutes() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ArchivePolicy) pulumi.IntPtrOutput { return v.DurationInMinutes }).(pulumi.IntPtrOutput)
}

// Enables or disabled the package cleanup policy. This allows the user to run the policy manually. If a policy has a valid cron expression, then it will be scheduled for execution based on it. If a policy is disabled, its future executions will be unscheduled. Defaults to `true`
func (o ArchivePolicyOutput) Enabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *ArchivePolicy) pulumi.BoolOutput { return v.Enabled }).(pulumi.BoolOutput)
}

// An ID that is used to identify the archive policy. A minimum of three characters is required and can include letters, numbers, underscore and hyphen.
func (o ArchivePolicyOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v *ArchivePolicy) pulumi.StringOutput { return v.Key }).(pulumi.StringOutput)
}

// This attribute is used only for project-level archive V2 policies, it is not used for global-level policies.
func (o ArchivePolicyOutput) ProjectKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ArchivePolicy) pulumi.StringPtrOutput { return v.ProjectKey }).(pulumi.StringPtrOutput)
}

func (o ArchivePolicyOutput) SearchCriteria() ArchivePolicySearchCriteriaOutput {
	return o.ApplyT(func(v *ArchivePolicy) ArchivePolicySearchCriteriaOutput { return v.SearchCriteria }).(ArchivePolicySearchCriteriaOutput)
}

// A `true` value means that when this policy is executed, packages will be permanently deleted. `false` means that when the policy is executed packages will be deleted to the Trash Can. Defaults to `false`.
func (o ArchivePolicyOutput) SkipTrashcan() pulumi.BoolOutput {
	return o.ApplyT(func(v *ArchivePolicy) pulumi.BoolOutput { return v.SkipTrashcan }).(pulumi.BoolOutput)
}

type ArchivePolicyArrayOutput struct{ *pulumi.OutputState }

func (ArchivePolicyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ArchivePolicy)(nil)).Elem()
}

func (o ArchivePolicyArrayOutput) ToArchivePolicyArrayOutput() ArchivePolicyArrayOutput {
	return o
}

func (o ArchivePolicyArrayOutput) ToArchivePolicyArrayOutputWithContext(ctx context.Context) ArchivePolicyArrayOutput {
	return o
}

func (o ArchivePolicyArrayOutput) Index(i pulumi.IntInput) ArchivePolicyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ArchivePolicy {
		return vs[0].([]*ArchivePolicy)[vs[1].(int)]
	}).(ArchivePolicyOutput)
}

type ArchivePolicyMapOutput struct{ *pulumi.OutputState }

func (ArchivePolicyMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ArchivePolicy)(nil)).Elem()
}

func (o ArchivePolicyMapOutput) ToArchivePolicyMapOutput() ArchivePolicyMapOutput {
	return o
}

func (o ArchivePolicyMapOutput) ToArchivePolicyMapOutputWithContext(ctx context.Context) ArchivePolicyMapOutput {
	return o
}

func (o ArchivePolicyMapOutput) MapIndex(k pulumi.StringInput) ArchivePolicyOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ArchivePolicy {
		return vs[0].(map[string]*ArchivePolicy)[vs[1].(string)]
	}).(ArchivePolicyOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ArchivePolicyInput)(nil)).Elem(), &ArchivePolicy{})
	pulumi.RegisterInputType(reflect.TypeOf((*ArchivePolicyArrayInput)(nil)).Elem(), ArchivePolicyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ArchivePolicyMapInput)(nil)).Elem(), ArchivePolicyMap{})
	pulumi.RegisterOutputType(ArchivePolicyOutput{})
	pulumi.RegisterOutputType(ArchivePolicyArrayOutput{})
	pulumi.RegisterOutputType(ArchivePolicyMapOutput{})
}
