// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package artifactory

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-artifactory/sdk/v8/go/artifactory/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Provides an Artifactory Archive Policy resource. This resource enable system administrators to define and customize policies based on specific criteria for removing unused binaries from across their JFrog platform. See [Retention Policies](https://jfrog.com/help/r/jfrog-platform-administration-documentation/archive) for more details.
//
// ## Example Usage
//
// ### Time-based Archive Policy (Days)
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-artifactory/sdk/v8/go/artifactory"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := artifactory.NewArchivePolicy(ctx, "my-archive-policy", &artifactory.ArchivePolicyArgs{
//				Key:               pulumi.String("my-archive-policy"),
//				Description:       pulumi.String("My archive policy"),
//				CronExpression:    pulumi.String("0 0 2 ? * MON-SAT *"),
//				DurationInMinutes: pulumi.Int(60),
//				Enabled:           pulumi.Bool(true),
//				SkipTrashcan:      pulumi.Bool(false),
//				SearchCriteria: &artifactory.ArchivePolicySearchCriteriaArgs{
//					PackageTypes: pulumi.StringArray{
//						pulumi.String("docker"),
//					},
//					Repos: pulumi.StringArray{
//						pulumi.String("**"),
//					},
//					IncludeAllProjects: pulumi.Bool(true),
//					IncludedProjects:   pulumi.StringArray{},
//					IncludedPackages: pulumi.StringArray{
//						pulumi.String("**"),
//					},
//					ExcludedPackages: pulumi.StringArray{
//						pulumi.String("com/jfrog/latest"),
//					},
//					CreatedBeforeInDays:        pulumi.Int(30),
//					LastDownloadedBeforeInDays: pulumi.Int(60),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### Version-based Archive Policy
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-artifactory/sdk/v8/go/artifactory"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := artifactory.NewArchivePolicy(ctx, "my-version-policy", &artifactory.ArchivePolicyArgs{
//				Key:               pulumi.String("my-version-policy"),
//				Description:       pulumi.String("Keep only latest versions"),
//				CronExpression:    pulumi.String("0 0 2 ? * MON-SAT *"),
//				DurationInMinutes: pulumi.Int(60),
//				Enabled:           pulumi.Bool(true),
//				SkipTrashcan:      pulumi.Bool(false),
//				SearchCriteria: &artifactory.ArchivePolicySearchCriteriaArgs{
//					PackageTypes: pulumi.StringArray{
//						pulumi.String("docker"),
//					},
//					Repos: pulumi.StringArray{
//						pulumi.String("**"),
//					},
//					IncludeAllProjects: pulumi.Bool(true),
//					IncludedProjects:   pulumi.StringArray{},
//					IncludedPackages: pulumi.StringArray{
//						pulumi.String("**"),
//					},
//					ExcludedPackages: pulumi.StringArray{
//						pulumi.String("com/jfrog/latest"),
//					},
//					KeepLastNVersions: pulumi.Int(5),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### Properties-based Archive Policy
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-artifactory/sdk/v8/go/artifactory"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := artifactory.NewArchivePolicy(ctx, "my-properties-policy", &artifactory.ArchivePolicyArgs{
//				Key:               pulumi.String("my-properties-policy"),
//				Description:       pulumi.String("Archive based on properties"),
//				CronExpression:    pulumi.String("0 0 2 ? * MON-SAT *"),
//				DurationInMinutes: pulumi.Int(60),
//				Enabled:           pulumi.Bool(true),
//				SkipTrashcan:      pulumi.Bool(false),
//				SearchCriteria: &artifactory.ArchivePolicySearchCriteriaArgs{
//					PackageTypes: pulumi.StringArray{
//						pulumi.String("docker"),
//					},
//					Repos: pulumi.StringArray{
//						pulumi.String("**"),
//					},
//					IncludeAllProjects: pulumi.Bool(true),
//					IncludedProjects:   pulumi.StringArray{},
//					IncludedPackages: pulumi.StringArray{
//						pulumi.String("**"),
//					},
//					ExcludedPackages: pulumi.StringArray{
//						pulumi.String("com/jfrog/latest"),
//					},
//					IncludedProperties: pulumi.StringArrayMap{
//						"build.name": pulumi.StringArray{
//							pulumi.String("my-app"),
//						},
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### Using Variables for Condition Fields
//
// You can use Terraform variables for condition fields (`createdBeforeInDays`, `lastDownloadedBeforeInDays`, `createdBeforeInMonths`, `lastDownloadedBeforeInMonths`, `keepLastNVersions`, `includedProperties`) and `durationInMinutes`. The validator will skip validation when values are unknown (variables), allowing `terraform validate` to pass without requiring variable values.
//
// **Example with variables:**
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-artifactory/sdk/v8/go/artifactory"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi/config"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			cfg := config.New(ctx, "")
//			archivePolicyLastDownloadedBeforeInDays := float64(30)
//			if param := cfg.GetFloat64("archivePolicyLastDownloadedBeforeInDays"); param != 0 {
//				archivePolicyLastDownloadedBeforeInDays = param
//			}
//			archivePolicyDurationInMinutes := float64(60)
//			if param := cfg.GetFloat64("archivePolicyDurationInMinutes"); param != 0 {
//				archivePolicyDurationInMinutes = param
//			}
//			_, err := artifactory.NewArchivePolicy(ctx, "my-archive-policy", &artifactory.ArchivePolicyArgs{
//				Key:               pulumi.String("my-archive-policy"),
//				Description:       pulumi.String("My archive policy with variables"),
//				CronExpression:    pulumi.String("0 0 2 ? * MON-SAT *"),
//				DurationInMinutes: pulumi.Float64(archivePolicyDurationInMinutes),
//				Enabled:           pulumi.Bool(true),
//				SkipTrashcan:      pulumi.Bool(false),
//				SearchCriteria: &artifactory.ArchivePolicySearchCriteriaArgs{
//					PackageTypes: pulumi.StringArray{
//						pulumi.String("docker"),
//						pulumi.String("generic"),
//						pulumi.String("helm"),
//						pulumi.String("helmoci"),
//						pulumi.String("nuget"),
//						pulumi.String("terraform"),
//					},
//					Repos: pulumi.StringArray{
//						pulumi.String("**"),
//					},
//					IncludeAllProjects: pulumi.Bool(false),
//					IncludedProjects: pulumi.StringArray{
//						pulumi.String("default"),
//					},
//					IncludedPackages: pulumi.StringArray{
//						pulumi.String("**"),
//					},
//					ExcludedPackages: pulumi.StringArray{
//						pulumi.String("com/jfrog/latest"),
//					},
//					LastDownloadedBeforeInDays: pulumi.Float64(archivePolicyLastDownloadedBeforeInDays),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// **Important Notes:**
// - Variables with default values allow `terraform validate` to pass without requiring variable values
// - Variables without default values will require values to be provided during `pulumi preview` or `pulumi up`
// - The validator automatically skips validation when condition field values are unknown (variables), preventing false validation errors during `terraform validate`
//
// ## Validation Rules
//
// The archive policy resource enforces the following validation rules:
//
// 1. **Condition Types**: A policy must use exactly one of the following condition types:
//   - Time-based conditions (`days-based`)
//   - Version-based condition (`keepLastNVersions`)
//   - Properties-based condition (`includedProperties`)
//
// 2. **Mutual Exclusivity**: Cannot use multiple condition types together.
//
// 3. **Zero Values**: Time-based and version-based conditions must have values greater than 0.
//
// 4. **Days vs Months**: Cannot use both days-based conditions (`createdBeforeInDays`, `lastDownloadedBeforeInDays`) and months-based conditions (`createdBeforeInMonths`, `lastDownloadedBeforeInMonths`) together.
//
// 5. **Properties Validation**: Properties-based conditions must have exactly one key with exactly one string value.
//
// 6. **Project Configuration**: When `includeAllProjects` is set to `true`, the `includedProjects` field can be empty array. When `includeAllProjects` is `false`, `includedProjects` must contain at least one project key.
//
// ## Supported Package Types
//
// The following package types are supported: alpine, ansible, cargo, chef, cocoapods, composer, conan, conda, debian, docker, gems, generic, go, gradle, helm, helmoci, huggingfaceml, maven, npm, nuget, oci, opkg, puppet, pypi, sbt, swift, terraform, terraformbackend, vagrant, yum.
//
// ## Version Compatibility
//
// - The `createdBeforeInDays` and `lastDownloadedBeforeInDays` attributes are only supported in Artifactory 7.111.2 and later. For earlier versions, use `createdBeforeInMonths` and `lastDownloadedBeforeInMonths`.
//
// ## Import
//
// ```sh
// $ pulumi import artifactory:index/archivePolicy:ArchivePolicy my-archive-policy my-policy
//
// $ pulumi import artifactory:index/archivePolicy:ArchivePolicy my-archive-policy my-policy:myproj
// ```
type ArchivePolicy struct {
	pulumi.CustomResourceState

	// The cron expression determines when the policy is run. This parameter is not mandatory, however if left empty the policy will not run automatically and can only be triggered manually.
	CronExpression pulumi.StringPtrOutput `pulumi:"cronExpression"`
	Description    pulumi.StringPtrOutput `pulumi:"description"`
	// The maximum duration (in minutes) for policy execution, after which the policy will stop running even if not completed. While setting a maximum run duration for a policy is useful for adhering to a strict archive V2 schedule, it can cause the policy to stop before completion.
	DurationInMinutes pulumi.IntOutput `pulumi:"durationInMinutes"`
	// Enables or disabled the package cleanup policy. This allows the user to run the policy manually. If a policy has a valid cron expression, then it will be scheduled for execution based on it. If a policy is disabled, its future executions will be unscheduled. Defaults to `true`
	Enabled pulumi.BoolOutput `pulumi:"enabled"`
	// An ID that is used to identify the archive policy. A minimum of three characters is required and can include letters, numbers, underscore and hyphen.
	Key pulumi.StringOutput `pulumi:"key"`
	// This attribute is used only for project-level archive V2 policies, it is not used for global-level policies.
	ProjectKey     pulumi.StringPtrOutput            `pulumi:"projectKey"`
	SearchCriteria ArchivePolicySearchCriteriaOutput `pulumi:"searchCriteria"`
	// A `true` value means that when this policy is executed, packages will be permanently deleted. `false` means that when the policy is executed packages will be deleted to the Trash Can. Defaults to `false`.
	SkipTrashcan pulumi.BoolOutput `pulumi:"skipTrashcan"`
}

// NewArchivePolicy registers a new resource with the given unique name, arguments, and options.
func NewArchivePolicy(ctx *pulumi.Context,
	name string, args *ArchivePolicyArgs, opts ...pulumi.ResourceOption) (*ArchivePolicy, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Key == nil {
		return nil, errors.New("invalid value for required argument 'Key'")
	}
	if args.SearchCriteria == nil {
		return nil, errors.New("invalid value for required argument 'SearchCriteria'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource ArchivePolicy
	err := ctx.RegisterResource("artifactory:index/archivePolicy:ArchivePolicy", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetArchivePolicy gets an existing ArchivePolicy resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetArchivePolicy(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ArchivePolicyState, opts ...pulumi.ResourceOption) (*ArchivePolicy, error) {
	var resource ArchivePolicy
	err := ctx.ReadResource("artifactory:index/archivePolicy:ArchivePolicy", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ArchivePolicy resources.
type archivePolicyState struct {
	// The cron expression determines when the policy is run. This parameter is not mandatory, however if left empty the policy will not run automatically and can only be triggered manually.
	CronExpression *string `pulumi:"cronExpression"`
	Description    *string `pulumi:"description"`
	// The maximum duration (in minutes) for policy execution, after which the policy will stop running even if not completed. While setting a maximum run duration for a policy is useful for adhering to a strict archive V2 schedule, it can cause the policy to stop before completion.
	DurationInMinutes *int `pulumi:"durationInMinutes"`
	// Enables or disabled the package cleanup policy. This allows the user to run the policy manually. If a policy has a valid cron expression, then it will be scheduled for execution based on it. If a policy is disabled, its future executions will be unscheduled. Defaults to `true`
	Enabled *bool `pulumi:"enabled"`
	// An ID that is used to identify the archive policy. A minimum of three characters is required and can include letters, numbers, underscore and hyphen.
	Key *string `pulumi:"key"`
	// This attribute is used only for project-level archive V2 policies, it is not used for global-level policies.
	ProjectKey     *string                      `pulumi:"projectKey"`
	SearchCriteria *ArchivePolicySearchCriteria `pulumi:"searchCriteria"`
	// A `true` value means that when this policy is executed, packages will be permanently deleted. `false` means that when the policy is executed packages will be deleted to the Trash Can. Defaults to `false`.
	SkipTrashcan *bool `pulumi:"skipTrashcan"`
}

type ArchivePolicyState struct {
	// The cron expression determines when the policy is run. This parameter is not mandatory, however if left empty the policy will not run automatically and can only be triggered manually.
	CronExpression pulumi.StringPtrInput
	Description    pulumi.StringPtrInput
	// The maximum duration (in minutes) for policy execution, after which the policy will stop running even if not completed. While setting a maximum run duration for a policy is useful for adhering to a strict archive V2 schedule, it can cause the policy to stop before completion.
	DurationInMinutes pulumi.IntPtrInput
	// Enables or disabled the package cleanup policy. This allows the user to run the policy manually. If a policy has a valid cron expression, then it will be scheduled for execution based on it. If a policy is disabled, its future executions will be unscheduled. Defaults to `true`
	Enabled pulumi.BoolPtrInput
	// An ID that is used to identify the archive policy. A minimum of three characters is required and can include letters, numbers, underscore and hyphen.
	Key pulumi.StringPtrInput
	// This attribute is used only for project-level archive V2 policies, it is not used for global-level policies.
	ProjectKey     pulumi.StringPtrInput
	SearchCriteria ArchivePolicySearchCriteriaPtrInput
	// A `true` value means that when this policy is executed, packages will be permanently deleted. `false` means that when the policy is executed packages will be deleted to the Trash Can. Defaults to `false`.
	SkipTrashcan pulumi.BoolPtrInput
}

func (ArchivePolicyState) ElementType() reflect.Type {
	return reflect.TypeOf((*archivePolicyState)(nil)).Elem()
}

type archivePolicyArgs struct {
	// The cron expression determines when the policy is run. This parameter is not mandatory, however if left empty the policy will not run automatically and can only be triggered manually.
	CronExpression *string `pulumi:"cronExpression"`
	Description    *string `pulumi:"description"`
	// The maximum duration (in minutes) for policy execution, after which the policy will stop running even if not completed. While setting a maximum run duration for a policy is useful for adhering to a strict archive V2 schedule, it can cause the policy to stop before completion.
	DurationInMinutes *int `pulumi:"durationInMinutes"`
	// Enables or disabled the package cleanup policy. This allows the user to run the policy manually. If a policy has a valid cron expression, then it will be scheduled for execution based on it. If a policy is disabled, its future executions will be unscheduled. Defaults to `true`
	Enabled *bool `pulumi:"enabled"`
	// An ID that is used to identify the archive policy. A minimum of three characters is required and can include letters, numbers, underscore and hyphen.
	Key string `pulumi:"key"`
	// This attribute is used only for project-level archive V2 policies, it is not used for global-level policies.
	ProjectKey     *string                     `pulumi:"projectKey"`
	SearchCriteria ArchivePolicySearchCriteria `pulumi:"searchCriteria"`
	// A `true` value means that when this policy is executed, packages will be permanently deleted. `false` means that when the policy is executed packages will be deleted to the Trash Can. Defaults to `false`.
	SkipTrashcan *bool `pulumi:"skipTrashcan"`
}

// The set of arguments for constructing a ArchivePolicy resource.
type ArchivePolicyArgs struct {
	// The cron expression determines when the policy is run. This parameter is not mandatory, however if left empty the policy will not run automatically and can only be triggered manually.
	CronExpression pulumi.StringPtrInput
	Description    pulumi.StringPtrInput
	// The maximum duration (in minutes) for policy execution, after which the policy will stop running even if not completed. While setting a maximum run duration for a policy is useful for adhering to a strict archive V2 schedule, it can cause the policy to stop before completion.
	DurationInMinutes pulumi.IntPtrInput
	// Enables or disabled the package cleanup policy. This allows the user to run the policy manually. If a policy has a valid cron expression, then it will be scheduled for execution based on it. If a policy is disabled, its future executions will be unscheduled. Defaults to `true`
	Enabled pulumi.BoolPtrInput
	// An ID that is used to identify the archive policy. A minimum of three characters is required and can include letters, numbers, underscore and hyphen.
	Key pulumi.StringInput
	// This attribute is used only for project-level archive V2 policies, it is not used for global-level policies.
	ProjectKey     pulumi.StringPtrInput
	SearchCriteria ArchivePolicySearchCriteriaInput
	// A `true` value means that when this policy is executed, packages will be permanently deleted. `false` means that when the policy is executed packages will be deleted to the Trash Can. Defaults to `false`.
	SkipTrashcan pulumi.BoolPtrInput
}

func (ArchivePolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*archivePolicyArgs)(nil)).Elem()
}

type ArchivePolicyInput interface {
	pulumi.Input

	ToArchivePolicyOutput() ArchivePolicyOutput
	ToArchivePolicyOutputWithContext(ctx context.Context) ArchivePolicyOutput
}

func (*ArchivePolicy) ElementType() reflect.Type {
	return reflect.TypeOf((**ArchivePolicy)(nil)).Elem()
}

func (i *ArchivePolicy) ToArchivePolicyOutput() ArchivePolicyOutput {
	return i.ToArchivePolicyOutputWithContext(context.Background())
}

func (i *ArchivePolicy) ToArchivePolicyOutputWithContext(ctx context.Context) ArchivePolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ArchivePolicyOutput)
}

// ArchivePolicyArrayInput is an input type that accepts ArchivePolicyArray and ArchivePolicyArrayOutput values.
// You can construct a concrete instance of `ArchivePolicyArrayInput` via:
//
//	ArchivePolicyArray{ ArchivePolicyArgs{...} }
type ArchivePolicyArrayInput interface {
	pulumi.Input

	ToArchivePolicyArrayOutput() ArchivePolicyArrayOutput
	ToArchivePolicyArrayOutputWithContext(context.Context) ArchivePolicyArrayOutput
}

type ArchivePolicyArray []ArchivePolicyInput

func (ArchivePolicyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ArchivePolicy)(nil)).Elem()
}

func (i ArchivePolicyArray) ToArchivePolicyArrayOutput() ArchivePolicyArrayOutput {
	return i.ToArchivePolicyArrayOutputWithContext(context.Background())
}

func (i ArchivePolicyArray) ToArchivePolicyArrayOutputWithContext(ctx context.Context) ArchivePolicyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ArchivePolicyArrayOutput)
}

// ArchivePolicyMapInput is an input type that accepts ArchivePolicyMap and ArchivePolicyMapOutput values.
// You can construct a concrete instance of `ArchivePolicyMapInput` via:
//
//	ArchivePolicyMap{ "key": ArchivePolicyArgs{...} }
type ArchivePolicyMapInput interface {
	pulumi.Input

	ToArchivePolicyMapOutput() ArchivePolicyMapOutput
	ToArchivePolicyMapOutputWithContext(context.Context) ArchivePolicyMapOutput
}

type ArchivePolicyMap map[string]ArchivePolicyInput

func (ArchivePolicyMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ArchivePolicy)(nil)).Elem()
}

func (i ArchivePolicyMap) ToArchivePolicyMapOutput() ArchivePolicyMapOutput {
	return i.ToArchivePolicyMapOutputWithContext(context.Background())
}

func (i ArchivePolicyMap) ToArchivePolicyMapOutputWithContext(ctx context.Context) ArchivePolicyMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ArchivePolicyMapOutput)
}

type ArchivePolicyOutput struct{ *pulumi.OutputState }

func (ArchivePolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ArchivePolicy)(nil)).Elem()
}

func (o ArchivePolicyOutput) ToArchivePolicyOutput() ArchivePolicyOutput {
	return o
}

func (o ArchivePolicyOutput) ToArchivePolicyOutputWithContext(ctx context.Context) ArchivePolicyOutput {
	return o
}

// The cron expression determines when the policy is run. This parameter is not mandatory, however if left empty the policy will not run automatically and can only be triggered manually.
func (o ArchivePolicyOutput) CronExpression() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ArchivePolicy) pulumi.StringPtrOutput { return v.CronExpression }).(pulumi.StringPtrOutput)
}

func (o ArchivePolicyOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ArchivePolicy) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// The maximum duration (in minutes) for policy execution, after which the policy will stop running even if not completed. While setting a maximum run duration for a policy is useful for adhering to a strict archive V2 schedule, it can cause the policy to stop before completion.
func (o ArchivePolicyOutput) DurationInMinutes() pulumi.IntOutput {
	return o.ApplyT(func(v *ArchivePolicy) pulumi.IntOutput { return v.DurationInMinutes }).(pulumi.IntOutput)
}

// Enables or disabled the package cleanup policy. This allows the user to run the policy manually. If a policy has a valid cron expression, then it will be scheduled for execution based on it. If a policy is disabled, its future executions will be unscheduled. Defaults to `true`
func (o ArchivePolicyOutput) Enabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *ArchivePolicy) pulumi.BoolOutput { return v.Enabled }).(pulumi.BoolOutput)
}

// An ID that is used to identify the archive policy. A minimum of three characters is required and can include letters, numbers, underscore and hyphen.
func (o ArchivePolicyOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v *ArchivePolicy) pulumi.StringOutput { return v.Key }).(pulumi.StringOutput)
}

// This attribute is used only for project-level archive V2 policies, it is not used for global-level policies.
func (o ArchivePolicyOutput) ProjectKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ArchivePolicy) pulumi.StringPtrOutput { return v.ProjectKey }).(pulumi.StringPtrOutput)
}

func (o ArchivePolicyOutput) SearchCriteria() ArchivePolicySearchCriteriaOutput {
	return o.ApplyT(func(v *ArchivePolicy) ArchivePolicySearchCriteriaOutput { return v.SearchCriteria }).(ArchivePolicySearchCriteriaOutput)
}

// A `true` value means that when this policy is executed, packages will be permanently deleted. `false` means that when the policy is executed packages will be deleted to the Trash Can. Defaults to `false`.
func (o ArchivePolicyOutput) SkipTrashcan() pulumi.BoolOutput {
	return o.ApplyT(func(v *ArchivePolicy) pulumi.BoolOutput { return v.SkipTrashcan }).(pulumi.BoolOutput)
}

type ArchivePolicyArrayOutput struct{ *pulumi.OutputState }

func (ArchivePolicyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ArchivePolicy)(nil)).Elem()
}

func (o ArchivePolicyArrayOutput) ToArchivePolicyArrayOutput() ArchivePolicyArrayOutput {
	return o
}

func (o ArchivePolicyArrayOutput) ToArchivePolicyArrayOutputWithContext(ctx context.Context) ArchivePolicyArrayOutput {
	return o
}

func (o ArchivePolicyArrayOutput) Index(i pulumi.IntInput) ArchivePolicyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ArchivePolicy {
		return vs[0].([]*ArchivePolicy)[vs[1].(int)]
	}).(ArchivePolicyOutput)
}

type ArchivePolicyMapOutput struct{ *pulumi.OutputState }

func (ArchivePolicyMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ArchivePolicy)(nil)).Elem()
}

func (o ArchivePolicyMapOutput) ToArchivePolicyMapOutput() ArchivePolicyMapOutput {
	return o
}

func (o ArchivePolicyMapOutput) ToArchivePolicyMapOutputWithContext(ctx context.Context) ArchivePolicyMapOutput {
	return o
}

func (o ArchivePolicyMapOutput) MapIndex(k pulumi.StringInput) ArchivePolicyOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ArchivePolicy {
		return vs[0].(map[string]*ArchivePolicy)[vs[1].(string)]
	}).(ArchivePolicyOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ArchivePolicyInput)(nil)).Elem(), &ArchivePolicy{})
	pulumi.RegisterInputType(reflect.TypeOf((*ArchivePolicyArrayInput)(nil)).Elem(), ArchivePolicyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ArchivePolicyMapInput)(nil)).Elem(), ArchivePolicyMap{})
	pulumi.RegisterOutputType(ArchivePolicyOutput{})
	pulumi.RegisterOutputType(ArchivePolicyArrayOutput{})
	pulumi.RegisterOutputType(ArchivePolicyMapOutput{})
}
