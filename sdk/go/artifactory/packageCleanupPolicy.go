// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package artifactory

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-artifactory/sdk/v8/go/artifactory/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// ## Import
//
// ```sh
// $ pulumi import artifactory:index/packageCleanupPolicy:PackageCleanupPolicy my-cleanup-policy my-policy
// ```
//
// ```sh
// $ pulumi import artifactory:index/packageCleanupPolicy:PackageCleanupPolicy my-cleanup-policy my-policy:myproj
// ```
type PackageCleanupPolicy struct {
	pulumi.CustomResourceState

	// The cron expression that determines when the policy is run, However if left empty the policy will not run automatically and can only be triggered manually.
	CronExpression pulumi.StringPtrOutput `pulumi:"cronExpression"`
	Description    pulumi.StringPtrOutput `pulumi:"description"`
	// The maximum duration (in minutes) for policy execution, after which the policy will stop running even if not completed. While setting a maximum run duration for a policy is useful for adhering to a strict cleanup schedule, it can cause the policy to stop before completion.
	DurationInMinutes pulumi.IntPtrOutput `pulumi:"durationInMinutes"`
	// A cleanup policy must be created inactive. But if used it must be set to `false`. If set to `true` when calling this API, the API call will fail and an error message is received. Defaults to `true`
	Enabled pulumi.BoolOutput `pulumi:"enabled"`
	// An ID that is used to identify the cleanup policy. A minimum of three characters is required and can include letters, numbers, underscore and hyphen.
	Key            pulumi.StringOutput                      `pulumi:"key"`
	SearchCriteria PackageCleanupPolicySearchCriteriaOutput `pulumi:"searchCriteria"`
	// A true value means that when this policy is executed, packages will be permanently deleted. false means that when the policy is executed packages will be deleted to the Trash Can. Defaults to `false`.
	SkipTrashcan pulumi.BoolOutput `pulumi:"skipTrashcan"`
}

// NewPackageCleanupPolicy registers a new resource with the given unique name, arguments, and options.
func NewPackageCleanupPolicy(ctx *pulumi.Context,
	name string, args *PackageCleanupPolicyArgs, opts ...pulumi.ResourceOption) (*PackageCleanupPolicy, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Key == nil {
		return nil, errors.New("invalid value for required argument 'Key'")
	}
	if args.SearchCriteria == nil {
		return nil, errors.New("invalid value for required argument 'SearchCriteria'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource PackageCleanupPolicy
	err := ctx.RegisterResource("artifactory:index/packageCleanupPolicy:PackageCleanupPolicy", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetPackageCleanupPolicy gets an existing PackageCleanupPolicy resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetPackageCleanupPolicy(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *PackageCleanupPolicyState, opts ...pulumi.ResourceOption) (*PackageCleanupPolicy, error) {
	var resource PackageCleanupPolicy
	err := ctx.ReadResource("artifactory:index/packageCleanupPolicy:PackageCleanupPolicy", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering PackageCleanupPolicy resources.
type packageCleanupPolicyState struct {
	// The cron expression that determines when the policy is run, However if left empty the policy will not run automatically and can only be triggered manually.
	CronExpression *string `pulumi:"cronExpression"`
	Description    *string `pulumi:"description"`
	// The maximum duration (in minutes) for policy execution, after which the policy will stop running even if not completed. While setting a maximum run duration for a policy is useful for adhering to a strict cleanup schedule, it can cause the policy to stop before completion.
	DurationInMinutes *int `pulumi:"durationInMinutes"`
	// A cleanup policy must be created inactive. But if used it must be set to `false`. If set to `true` when calling this API, the API call will fail and an error message is received. Defaults to `true`
	Enabled *bool `pulumi:"enabled"`
	// An ID that is used to identify the cleanup policy. A minimum of three characters is required and can include letters, numbers, underscore and hyphen.
	Key            *string                             `pulumi:"key"`
	SearchCriteria *PackageCleanupPolicySearchCriteria `pulumi:"searchCriteria"`
	// A true value means that when this policy is executed, packages will be permanently deleted. false means that when the policy is executed packages will be deleted to the Trash Can. Defaults to `false`.
	SkipTrashcan *bool `pulumi:"skipTrashcan"`
}

type PackageCleanupPolicyState struct {
	// The cron expression that determines when the policy is run, However if left empty the policy will not run automatically and can only be triggered manually.
	CronExpression pulumi.StringPtrInput
	Description    pulumi.StringPtrInput
	// The maximum duration (in minutes) for policy execution, after which the policy will stop running even if not completed. While setting a maximum run duration for a policy is useful for adhering to a strict cleanup schedule, it can cause the policy to stop before completion.
	DurationInMinutes pulumi.IntPtrInput
	// A cleanup policy must be created inactive. But if used it must be set to `false`. If set to `true` when calling this API, the API call will fail and an error message is received. Defaults to `true`
	Enabled pulumi.BoolPtrInput
	// An ID that is used to identify the cleanup policy. A minimum of three characters is required and can include letters, numbers, underscore and hyphen.
	Key            pulumi.StringPtrInput
	SearchCriteria PackageCleanupPolicySearchCriteriaPtrInput
	// A true value means that when this policy is executed, packages will be permanently deleted. false means that when the policy is executed packages will be deleted to the Trash Can. Defaults to `false`.
	SkipTrashcan pulumi.BoolPtrInput
}

func (PackageCleanupPolicyState) ElementType() reflect.Type {
	return reflect.TypeOf((*packageCleanupPolicyState)(nil)).Elem()
}

type packageCleanupPolicyArgs struct {
	// The cron expression that determines when the policy is run, However if left empty the policy will not run automatically and can only be triggered manually.
	CronExpression *string `pulumi:"cronExpression"`
	Description    *string `pulumi:"description"`
	// The maximum duration (in minutes) for policy execution, after which the policy will stop running even if not completed. While setting a maximum run duration for a policy is useful for adhering to a strict cleanup schedule, it can cause the policy to stop before completion.
	DurationInMinutes *int `pulumi:"durationInMinutes"`
	// A cleanup policy must be created inactive. But if used it must be set to `false`. If set to `true` when calling this API, the API call will fail and an error message is received. Defaults to `true`
	Enabled *bool `pulumi:"enabled"`
	// An ID that is used to identify the cleanup policy. A minimum of three characters is required and can include letters, numbers, underscore and hyphen.
	Key            string                             `pulumi:"key"`
	SearchCriteria PackageCleanupPolicySearchCriteria `pulumi:"searchCriteria"`
	// A true value means that when this policy is executed, packages will be permanently deleted. false means that when the policy is executed packages will be deleted to the Trash Can. Defaults to `false`.
	SkipTrashcan *bool `pulumi:"skipTrashcan"`
}

// The set of arguments for constructing a PackageCleanupPolicy resource.
type PackageCleanupPolicyArgs struct {
	// The cron expression that determines when the policy is run, However if left empty the policy will not run automatically and can only be triggered manually.
	CronExpression pulumi.StringPtrInput
	Description    pulumi.StringPtrInput
	// The maximum duration (in minutes) for policy execution, after which the policy will stop running even if not completed. While setting a maximum run duration for a policy is useful for adhering to a strict cleanup schedule, it can cause the policy to stop before completion.
	DurationInMinutes pulumi.IntPtrInput
	// A cleanup policy must be created inactive. But if used it must be set to `false`. If set to `true` when calling this API, the API call will fail and an error message is received. Defaults to `true`
	Enabled pulumi.BoolPtrInput
	// An ID that is used to identify the cleanup policy. A minimum of three characters is required and can include letters, numbers, underscore and hyphen.
	Key            pulumi.StringInput
	SearchCriteria PackageCleanupPolicySearchCriteriaInput
	// A true value means that when this policy is executed, packages will be permanently deleted. false means that when the policy is executed packages will be deleted to the Trash Can. Defaults to `false`.
	SkipTrashcan pulumi.BoolPtrInput
}

func (PackageCleanupPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*packageCleanupPolicyArgs)(nil)).Elem()
}

type PackageCleanupPolicyInput interface {
	pulumi.Input

	ToPackageCleanupPolicyOutput() PackageCleanupPolicyOutput
	ToPackageCleanupPolicyOutputWithContext(ctx context.Context) PackageCleanupPolicyOutput
}

func (*PackageCleanupPolicy) ElementType() reflect.Type {
	return reflect.TypeOf((**PackageCleanupPolicy)(nil)).Elem()
}

func (i *PackageCleanupPolicy) ToPackageCleanupPolicyOutput() PackageCleanupPolicyOutput {
	return i.ToPackageCleanupPolicyOutputWithContext(context.Background())
}

func (i *PackageCleanupPolicy) ToPackageCleanupPolicyOutputWithContext(ctx context.Context) PackageCleanupPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PackageCleanupPolicyOutput)
}

// PackageCleanupPolicyArrayInput is an input type that accepts PackageCleanupPolicyArray and PackageCleanupPolicyArrayOutput values.
// You can construct a concrete instance of `PackageCleanupPolicyArrayInput` via:
//
//	PackageCleanupPolicyArray{ PackageCleanupPolicyArgs{...} }
type PackageCleanupPolicyArrayInput interface {
	pulumi.Input

	ToPackageCleanupPolicyArrayOutput() PackageCleanupPolicyArrayOutput
	ToPackageCleanupPolicyArrayOutputWithContext(context.Context) PackageCleanupPolicyArrayOutput
}

type PackageCleanupPolicyArray []PackageCleanupPolicyInput

func (PackageCleanupPolicyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*PackageCleanupPolicy)(nil)).Elem()
}

func (i PackageCleanupPolicyArray) ToPackageCleanupPolicyArrayOutput() PackageCleanupPolicyArrayOutput {
	return i.ToPackageCleanupPolicyArrayOutputWithContext(context.Background())
}

func (i PackageCleanupPolicyArray) ToPackageCleanupPolicyArrayOutputWithContext(ctx context.Context) PackageCleanupPolicyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PackageCleanupPolicyArrayOutput)
}

// PackageCleanupPolicyMapInput is an input type that accepts PackageCleanupPolicyMap and PackageCleanupPolicyMapOutput values.
// You can construct a concrete instance of `PackageCleanupPolicyMapInput` via:
//
//	PackageCleanupPolicyMap{ "key": PackageCleanupPolicyArgs{...} }
type PackageCleanupPolicyMapInput interface {
	pulumi.Input

	ToPackageCleanupPolicyMapOutput() PackageCleanupPolicyMapOutput
	ToPackageCleanupPolicyMapOutputWithContext(context.Context) PackageCleanupPolicyMapOutput
}

type PackageCleanupPolicyMap map[string]PackageCleanupPolicyInput

func (PackageCleanupPolicyMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*PackageCleanupPolicy)(nil)).Elem()
}

func (i PackageCleanupPolicyMap) ToPackageCleanupPolicyMapOutput() PackageCleanupPolicyMapOutput {
	return i.ToPackageCleanupPolicyMapOutputWithContext(context.Background())
}

func (i PackageCleanupPolicyMap) ToPackageCleanupPolicyMapOutputWithContext(ctx context.Context) PackageCleanupPolicyMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PackageCleanupPolicyMapOutput)
}

type PackageCleanupPolicyOutput struct{ *pulumi.OutputState }

func (PackageCleanupPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PackageCleanupPolicy)(nil)).Elem()
}

func (o PackageCleanupPolicyOutput) ToPackageCleanupPolicyOutput() PackageCleanupPolicyOutput {
	return o
}

func (o PackageCleanupPolicyOutput) ToPackageCleanupPolicyOutputWithContext(ctx context.Context) PackageCleanupPolicyOutput {
	return o
}

// The cron expression that determines when the policy is run, However if left empty the policy will not run automatically and can only be triggered manually.
func (o PackageCleanupPolicyOutput) CronExpression() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PackageCleanupPolicy) pulumi.StringPtrOutput { return v.CronExpression }).(pulumi.StringPtrOutput)
}

func (o PackageCleanupPolicyOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PackageCleanupPolicy) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// The maximum duration (in minutes) for policy execution, after which the policy will stop running even if not completed. While setting a maximum run duration for a policy is useful for adhering to a strict cleanup schedule, it can cause the policy to stop before completion.
func (o PackageCleanupPolicyOutput) DurationInMinutes() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *PackageCleanupPolicy) pulumi.IntPtrOutput { return v.DurationInMinutes }).(pulumi.IntPtrOutput)
}

// A cleanup policy must be created inactive. But if used it must be set to `false`. If set to `true` when calling this API, the API call will fail and an error message is received. Defaults to `true`
func (o PackageCleanupPolicyOutput) Enabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *PackageCleanupPolicy) pulumi.BoolOutput { return v.Enabled }).(pulumi.BoolOutput)
}

// An ID that is used to identify the cleanup policy. A minimum of three characters is required and can include letters, numbers, underscore and hyphen.
func (o PackageCleanupPolicyOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v *PackageCleanupPolicy) pulumi.StringOutput { return v.Key }).(pulumi.StringOutput)
}

func (o PackageCleanupPolicyOutput) SearchCriteria() PackageCleanupPolicySearchCriteriaOutput {
	return o.ApplyT(func(v *PackageCleanupPolicy) PackageCleanupPolicySearchCriteriaOutput { return v.SearchCriteria }).(PackageCleanupPolicySearchCriteriaOutput)
}

// A true value means that when this policy is executed, packages will be permanently deleted. false means that when the policy is executed packages will be deleted to the Trash Can. Defaults to `false`.
func (o PackageCleanupPolicyOutput) SkipTrashcan() pulumi.BoolOutput {
	return o.ApplyT(func(v *PackageCleanupPolicy) pulumi.BoolOutput { return v.SkipTrashcan }).(pulumi.BoolOutput)
}

type PackageCleanupPolicyArrayOutput struct{ *pulumi.OutputState }

func (PackageCleanupPolicyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*PackageCleanupPolicy)(nil)).Elem()
}

func (o PackageCleanupPolicyArrayOutput) ToPackageCleanupPolicyArrayOutput() PackageCleanupPolicyArrayOutput {
	return o
}

func (o PackageCleanupPolicyArrayOutput) ToPackageCleanupPolicyArrayOutputWithContext(ctx context.Context) PackageCleanupPolicyArrayOutput {
	return o
}

func (o PackageCleanupPolicyArrayOutput) Index(i pulumi.IntInput) PackageCleanupPolicyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *PackageCleanupPolicy {
		return vs[0].([]*PackageCleanupPolicy)[vs[1].(int)]
	}).(PackageCleanupPolicyOutput)
}

type PackageCleanupPolicyMapOutput struct{ *pulumi.OutputState }

func (PackageCleanupPolicyMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*PackageCleanupPolicy)(nil)).Elem()
}

func (o PackageCleanupPolicyMapOutput) ToPackageCleanupPolicyMapOutput() PackageCleanupPolicyMapOutput {
	return o
}

func (o PackageCleanupPolicyMapOutput) ToPackageCleanupPolicyMapOutputWithContext(ctx context.Context) PackageCleanupPolicyMapOutput {
	return o
}

func (o PackageCleanupPolicyMapOutput) MapIndex(k pulumi.StringInput) PackageCleanupPolicyOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *PackageCleanupPolicy {
		return vs[0].(map[string]*PackageCleanupPolicy)[vs[1].(string)]
	}).(PackageCleanupPolicyOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*PackageCleanupPolicyInput)(nil)).Elem(), &PackageCleanupPolicy{})
	pulumi.RegisterInputType(reflect.TypeOf((*PackageCleanupPolicyArrayInput)(nil)).Elem(), PackageCleanupPolicyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*PackageCleanupPolicyMapInput)(nil)).Elem(), PackageCleanupPolicyMap{})
	pulumi.RegisterOutputType(PackageCleanupPolicyOutput{})
	pulumi.RegisterOutputType(PackageCleanupPolicyArrayOutput{})
	pulumi.RegisterOutputType(PackageCleanupPolicyMapOutput{})
}
