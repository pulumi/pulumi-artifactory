// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package artifactory

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-artifactory/sdk/v8/go/artifactory/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Provides an Artifactory Package Cleanup Policy resource. This resource enable system administrators to define and customize policies based on specific criteria for removing unused binaries from across their JFrog platform. Package cleanup policies are supported on the Cloud (7.98.2) and Self-Hosted (7.98.7) platforms, with an Enterprise+ license. See [Cleanup Policies](https://jfrog.com/help/r/jfrog-platform-administration-documentation/cleanup-policies) for more details.
//
// ## Example Usage
//
// ### Time-based Cleanup Policy (Days)
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-artifactory/sdk/v8/go/artifactory"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := artifactory.NewPackageCleanupPolicy(ctx, "my-cleanup-policy", &artifactory.PackageCleanupPolicyArgs{
//				Key:               pulumi.String("my-cleanup-policy"),
//				Description:       pulumi.String("My cleanup policy"),
//				CronExpression:    pulumi.String("0 0 2 ? * MON-SAT *"),
//				DurationInMinutes: pulumi.Int(60),
//				Enabled:           pulumi.Bool(true),
//				SkipTrashcan:      pulumi.Bool(false),
//				SearchCriteria: &artifactory.PackageCleanupPolicySearchCriteriaArgs{
//					PackageTypes: pulumi.StringArray{
//						pulumi.String("docker"),
//						pulumi.String("gradle"),
//						pulumi.String("maven"),
//					},
//					Repos: pulumi.StringArray{
//						pulumi.String("**"),
//					},
//					IncludeAllProjects: pulumi.Bool(true),
//					IncludedProjects:   pulumi.StringArray{},
//					IncludedPackages: pulumi.StringArray{
//						pulumi.String("**"),
//					},
//					ExcludedPackages: pulumi.StringArray{
//						pulumi.String("com/jfrog/latest"),
//					},
//					CreatedBeforeInDays:        pulumi.Int(30),
//					LastDownloadedBeforeInDays: pulumi.Int(60),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### Version-based Cleanup Policy
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-artifactory/sdk/v8/go/artifactory"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := artifactory.NewPackageCleanupPolicy(ctx, "my-version-policy", &artifactory.PackageCleanupPolicyArgs{
//				Key:               pulumi.String("my-version-policy"),
//				Description:       pulumi.String("Keep only latest versions"),
//				CronExpression:    pulumi.String("0 0 2 ? * MON-SAT *"),
//				DurationInMinutes: pulumi.Int(60),
//				Enabled:           pulumi.Bool(true),
//				SkipTrashcan:      pulumi.Bool(false),
//				SearchCriteria: &artifactory.PackageCleanupPolicySearchCriteriaArgs{
//					PackageTypes: pulumi.StringArray{
//						pulumi.String("maven"),
//					},
//					Repos: pulumi.StringArray{
//						pulumi.String("**"),
//					},
//					IncludeAllProjects: pulumi.Bool(true),
//					IncludedProjects:   pulumi.StringArray{},
//					IncludedPackages: pulumi.StringArray{
//						pulumi.String("**"),
//					},
//					ExcludedPackages: pulumi.StringArray{
//						pulumi.String("com/jfrog/latest"),
//					},
//					KeepLastNVersions: pulumi.Int(5),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### Properties-based Cleanup Policy
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-artifactory/sdk/v8/go/artifactory"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := artifactory.NewPackageCleanupPolicy(ctx, "my-properties-policy", &artifactory.PackageCleanupPolicyArgs{
//				Key:               pulumi.String("my-properties-policy"),
//				Description:       pulumi.String("Cleanup based on properties"),
//				CronExpression:    pulumi.String("0 0 2 ? * MON-SAT *"),
//				DurationInMinutes: pulumi.Int(60),
//				Enabled:           pulumi.Bool(true),
//				SkipTrashcan:      pulumi.Bool(false),
//				SearchCriteria: &artifactory.PackageCleanupPolicySearchCriteriaArgs{
//					PackageTypes: pulumi.StringArray{
//						pulumi.String("docker"),
//					},
//					Repos: pulumi.StringArray{
//						pulumi.String("**"),
//					},
//					IncludeAllProjects: pulumi.Bool(true),
//					IncludedProjects:   pulumi.StringArray{},
//					IncludedPackages: pulumi.StringArray{
//						pulumi.String("**"),
//					},
//					ExcludedPackages: pulumi.StringArray{
//						pulumi.String("com/jfrog/latest"),
//					},
//					IncludedProperties: pulumi.StringArrayMap{
//						"build.name": pulumi.StringArray{
//							pulumi.String("my-app"),
//						},
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### Using Variables for Condition Fields
//
// You can use Terraform variables for condition fields (`createdBeforeInDays`, `lastDownloadedBeforeInDays`, `createdBeforeInMonths`, `lastDownloadedBeforeInMonths`, `keepLastNVersions`, `includedProperties`) and `durationInMinutes`. The validator will skip validation when values are unknown (variables), allowing `terraform validate` to pass without requiring variable values.
//
// **Example with variables:**
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-artifactory/sdk/v8/go/artifactory"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi/config"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			cfg := config.New(ctx, "")
//			cleanupPolicyLastDownloadedBeforeInDays := float64(60)
//			if param := cfg.GetFloat64("cleanupPolicyLastDownloadedBeforeInDays"); param != 0 {
//				cleanupPolicyLastDownloadedBeforeInDays = param
//			}
//			cleanupPolicyDurationInMinutes := float64(120)
//			if param := cfg.GetFloat64("cleanupPolicyDurationInMinutes"); param != 0 {
//				cleanupPolicyDurationInMinutes = param
//			}
//			_, err := artifactory.NewPackageCleanupPolicy(ctx, "my-cleanup-policy", &artifactory.PackageCleanupPolicyArgs{
//				Key:               pulumi.String("my-cleanup-policy"),
//				Description:       pulumi.String("My cleanup policy with variables"),
//				CronExpression:    pulumi.String("0 0 2 ? * MON-SAT *"),
//				DurationInMinutes: pulumi.Float64(cleanupPolicyDurationInMinutes),
//				Enabled:           pulumi.Bool(true),
//				SkipTrashcan:      pulumi.Bool(false),
//				SearchCriteria: &artifactory.PackageCleanupPolicySearchCriteriaArgs{
//					PackageTypes: pulumi.StringArray{
//						pulumi.String("docker"),
//						pulumi.String("generic"),
//						pulumi.String("helm"),
//						pulumi.String("helmoci"),
//						pulumi.String("nuget"),
//						pulumi.String("terraform"),
//					},
//					Repos: pulumi.StringArray{
//						pulumi.String("**"),
//					},
//					IncludeAllProjects: pulumi.Bool(false),
//					IncludedProjects: pulumi.StringArray{
//						pulumi.String("default"),
//					},
//					IncludedPackages: pulumi.StringArray{
//						pulumi.String("**"),
//					},
//					ExcludedPackages: pulumi.StringArray{
//						pulumi.String("com/jfrog/latest"),
//					},
//					LastDownloadedBeforeInDays: pulumi.Float64(cleanupPolicyLastDownloadedBeforeInDays),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// **Important Notes:**
// - Variables with default values allow `terraform validate` to pass without requiring variable values
// - Variables without default values will require values to be provided during `pulumi preview` or `pulumi up`
// - The validator automatically skips validation when condition field values are unknown (variables), preventing false validation errors during `terraform validate`
//
// ## Validation Rules
//
// The cleanup policy resource enforces the following validation rules:
//
// 1. **Condition Types**: A policy must use exactly one of the following condition types:
//   - Time-based conditions (`days-based`)
//   - Version-based condition (`keepLastNVersions`)
//   - Properties-based condition (`includedProperties`)
//
// 2. **Mutual Exclusivity**: Cannot use multiple condition types together.
//
// 3. **Zero Values**: Time-based and version-based conditions must have values greater than 0.
//
// 4. **Days vs Months**: Cannot use both days-based conditions (`createdBeforeInDays`, `lastDownloadedBeforeInDays`) and months-based conditions (`createdBeforeInMonths`, `lastDownloadedBeforeInMonths`) together.
//
// 5. **Properties Validation**: Properties-based conditions must have exactly one key with exactly one string value.
//
// 6. **Project Configuration**: When `includeAllProjects` is set to `true`, the `includedProjects` field can be empty array. When `includeAllProjects` is `false`, `includedProjects` must contain at least one project key.
//
// 7. **Project-level Policy Constraints**: When `projectKey` is specified (project-level policy):
//   - `includeAllProjects` must be set to `false`
//   - `includedProjects` should be empty array `[]`
//   - Policy `key` must start with the project key value as a prefix followed by a hyphen
//   - ✅ Valid: `projectKey = "myproj"` → `key = "myproj-cleanup-policy"`
//   - ❌ Invalid: `projectKey = "myproj"` → `key = "cleanup-policy"` (missing prefix)
//   - ❌ Invalid: `projectKey = "myproj"` → `key = "other-cleanup-policy"` (wrong prefix)
//
// ## Supported Package Types
//
// The following package types are supported for cleanup policies with their respective minimum Artifactory versions:
//
// - **alpine** - Alpine Linux packages (supported from 7.108.0)
// - **ansible** - Ansible collections and roles (supported from 7.104.2)
// - **cargo** - Rust Cargo packages (supported from 7.102.0)
// - **chef** - Chef cookbooks (supported from 7.112.0)
// - **cocoapods** - CocoaPods packages (supported from 7.99.1)
// - **composer** - PHP Composer packages (supported from 7.116.0)
// - **conan** - Conan C/C++ packages (supported from 7.98.2)
// - **conda** - Conda packages (supported from 7.105.2)
// - **debian** - Debian packages (supported from 7.98.2)
// - **docker** - Docker images (supported from 7.98.2, version-based condition (keep_last_n_versions) from 7.115.1)
// - **gems** - Ruby gems (supported from 7.96.3)
// - **generic** - Generic packages (supported from 7.98.2, version-based conditions is not supported)
// - **go** - Go modules (supported from 7.98.2)
// - **gradle** - Gradle packages (supported from 7.98.2)
// - **helm** - Helm charts (supported from 7.98.2)
// - **helmoci** - Helm OCI charts (supported from 7.102.0, version-based conditions (keep_last_n_versions) from 7.115.1)
// - **huggingfaceml** - Hugging Face ML models (supported from 7.100.0)
// - **machinelearning** - Machine learning models (supported from 7.104.2)
// - **maven** - Maven packages (supported from 7.98.2)
// - **npm** - Node.js packages (supported from 7.98.2)
// - **nuget** - .NET NuGet packages (supported from 7.98.2)
// - **oci** - OCI images (supported from 7.90.1, version-based conditions (keep_last_n_versions) from 7.115.1)
// - **puppet** - Puppet modules (supported from 7.112.0)
// - **pypi** - Python packages (supported from 7.98.2)
// - **rpm|yum** - RPM packages (supported from 7.98.2)
// - **sbt** - Scala SBT packages (supported from 7.108.0)
// - **swift** - Swift packages
// - **terraform** - Terraform modules (supported from 7.99.1)
// - **terraformbackend** - Terraform backend configurations (supported from 7.103.0)
//
// ## Version Compatibility
//
// - The `createdBeforeInDays` and `lastDownloadedBeforeInDays` attributes are only supported in Artifactory 7.111.2 and later. For earlier versions, use `createdBeforeInMonths` and `lastDownloadedBeforeInMonths`.
//
// ## Import
//
// ```sh
// $ pulumi import artifactory:index/packageCleanupPolicy:PackageCleanupPolicy my-cleanup-policy my-policy
//
// $ pulumi import artifactory:index/packageCleanupPolicy:PackageCleanupPolicy my-cleanup-policy my-policy:myproj
// ```
type PackageCleanupPolicy struct {
	pulumi.CustomResourceState

	// The cron expression that determines when the policy is run, However if left empty the policy will not run automatically and can only be triggered manually.
	CronExpression pulumi.StringPtrOutput `pulumi:"cronExpression"`
	Description    pulumi.StringPtrOutput `pulumi:"description"`
	// The maximum duration (in minutes) for policy execution, after which the policy will stop running even if not completed. While setting a maximum run duration for a policy is useful for adhering to a strict cleanup schedule, it can cause the policy to stop before completion.
	DurationInMinutes pulumi.IntOutput `pulumi:"durationInMinutes"`
	// A cleanup policy must be created inactive. But if used it must be set to `false`. If set to `true` when calling this API, the API call will fail and an error message is received. Defaults to `true`
	Enabled pulumi.BoolOutput `pulumi:"enabled"`
	// An ID that is used to identify the cleanup policy. A minimum of three characters is required and can include letters, numbers, underscore and hyphen.
	Key pulumi.StringOutput `pulumi:"key"`
	// This attribute is used only for project-level cleanup policies, it is not used for global-level policies. When specified, the policy will be scoped to the specified project. Note: The policy `key` must start with this project key value as a prefix (e.g., if `projectKey` is `"myproj"`, the `key` should be `"myproj-policy-name"`).
	ProjectKey     pulumi.StringPtrOutput                   `pulumi:"projectKey"`
	SearchCriteria PackageCleanupPolicySearchCriteriaOutput `pulumi:"searchCriteria"`
	// A true value means that when this policy is executed, packages will be permanently deleted. false means that when the policy is executed packages will be deleted to the Trash Can. Defaults to `false`.
	SkipTrashcan pulumi.BoolOutput `pulumi:"skipTrashcan"`
}

// NewPackageCleanupPolicy registers a new resource with the given unique name, arguments, and options.
func NewPackageCleanupPolicy(ctx *pulumi.Context,
	name string, args *PackageCleanupPolicyArgs, opts ...pulumi.ResourceOption) (*PackageCleanupPolicy, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Key == nil {
		return nil, errors.New("invalid value for required argument 'Key'")
	}
	if args.SearchCriteria == nil {
		return nil, errors.New("invalid value for required argument 'SearchCriteria'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource PackageCleanupPolicy
	err := ctx.RegisterResource("artifactory:index/packageCleanupPolicy:PackageCleanupPolicy", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetPackageCleanupPolicy gets an existing PackageCleanupPolicy resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetPackageCleanupPolicy(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *PackageCleanupPolicyState, opts ...pulumi.ResourceOption) (*PackageCleanupPolicy, error) {
	var resource PackageCleanupPolicy
	err := ctx.ReadResource("artifactory:index/packageCleanupPolicy:PackageCleanupPolicy", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering PackageCleanupPolicy resources.
type packageCleanupPolicyState struct {
	// The cron expression that determines when the policy is run, However if left empty the policy will not run automatically and can only be triggered manually.
	CronExpression *string `pulumi:"cronExpression"`
	Description    *string `pulumi:"description"`
	// The maximum duration (in minutes) for policy execution, after which the policy will stop running even if not completed. While setting a maximum run duration for a policy is useful for adhering to a strict cleanup schedule, it can cause the policy to stop before completion.
	DurationInMinutes *int `pulumi:"durationInMinutes"`
	// A cleanup policy must be created inactive. But if used it must be set to `false`. If set to `true` when calling this API, the API call will fail and an error message is received. Defaults to `true`
	Enabled *bool `pulumi:"enabled"`
	// An ID that is used to identify the cleanup policy. A minimum of three characters is required and can include letters, numbers, underscore and hyphen.
	Key *string `pulumi:"key"`
	// This attribute is used only for project-level cleanup policies, it is not used for global-level policies. When specified, the policy will be scoped to the specified project. Note: The policy `key` must start with this project key value as a prefix (e.g., if `projectKey` is `"myproj"`, the `key` should be `"myproj-policy-name"`).
	ProjectKey     *string                             `pulumi:"projectKey"`
	SearchCriteria *PackageCleanupPolicySearchCriteria `pulumi:"searchCriteria"`
	// A true value means that when this policy is executed, packages will be permanently deleted. false means that when the policy is executed packages will be deleted to the Trash Can. Defaults to `false`.
	SkipTrashcan *bool `pulumi:"skipTrashcan"`
}

type PackageCleanupPolicyState struct {
	// The cron expression that determines when the policy is run, However if left empty the policy will not run automatically and can only be triggered manually.
	CronExpression pulumi.StringPtrInput
	Description    pulumi.StringPtrInput
	// The maximum duration (in minutes) for policy execution, after which the policy will stop running even if not completed. While setting a maximum run duration for a policy is useful for adhering to a strict cleanup schedule, it can cause the policy to stop before completion.
	DurationInMinutes pulumi.IntPtrInput
	// A cleanup policy must be created inactive. But if used it must be set to `false`. If set to `true` when calling this API, the API call will fail and an error message is received. Defaults to `true`
	Enabled pulumi.BoolPtrInput
	// An ID that is used to identify the cleanup policy. A minimum of three characters is required and can include letters, numbers, underscore and hyphen.
	Key pulumi.StringPtrInput
	// This attribute is used only for project-level cleanup policies, it is not used for global-level policies. When specified, the policy will be scoped to the specified project. Note: The policy `key` must start with this project key value as a prefix (e.g., if `projectKey` is `"myproj"`, the `key` should be `"myproj-policy-name"`).
	ProjectKey     pulumi.StringPtrInput
	SearchCriteria PackageCleanupPolicySearchCriteriaPtrInput
	// A true value means that when this policy is executed, packages will be permanently deleted. false means that when the policy is executed packages will be deleted to the Trash Can. Defaults to `false`.
	SkipTrashcan pulumi.BoolPtrInput
}

func (PackageCleanupPolicyState) ElementType() reflect.Type {
	return reflect.TypeOf((*packageCleanupPolicyState)(nil)).Elem()
}

type packageCleanupPolicyArgs struct {
	// The cron expression that determines when the policy is run, However if left empty the policy will not run automatically and can only be triggered manually.
	CronExpression *string `pulumi:"cronExpression"`
	Description    *string `pulumi:"description"`
	// The maximum duration (in minutes) for policy execution, after which the policy will stop running even if not completed. While setting a maximum run duration for a policy is useful for adhering to a strict cleanup schedule, it can cause the policy to stop before completion.
	DurationInMinutes *int `pulumi:"durationInMinutes"`
	// A cleanup policy must be created inactive. But if used it must be set to `false`. If set to `true` when calling this API, the API call will fail and an error message is received. Defaults to `true`
	Enabled *bool `pulumi:"enabled"`
	// An ID that is used to identify the cleanup policy. A minimum of three characters is required and can include letters, numbers, underscore and hyphen.
	Key string `pulumi:"key"`
	// This attribute is used only for project-level cleanup policies, it is not used for global-level policies. When specified, the policy will be scoped to the specified project. Note: The policy `key` must start with this project key value as a prefix (e.g., if `projectKey` is `"myproj"`, the `key` should be `"myproj-policy-name"`).
	ProjectKey     *string                            `pulumi:"projectKey"`
	SearchCriteria PackageCleanupPolicySearchCriteria `pulumi:"searchCriteria"`
	// A true value means that when this policy is executed, packages will be permanently deleted. false means that when the policy is executed packages will be deleted to the Trash Can. Defaults to `false`.
	SkipTrashcan *bool `pulumi:"skipTrashcan"`
}

// The set of arguments for constructing a PackageCleanupPolicy resource.
type PackageCleanupPolicyArgs struct {
	// The cron expression that determines when the policy is run, However if left empty the policy will not run automatically and can only be triggered manually.
	CronExpression pulumi.StringPtrInput
	Description    pulumi.StringPtrInput
	// The maximum duration (in minutes) for policy execution, after which the policy will stop running even if not completed. While setting a maximum run duration for a policy is useful for adhering to a strict cleanup schedule, it can cause the policy to stop before completion.
	DurationInMinutes pulumi.IntPtrInput
	// A cleanup policy must be created inactive. But if used it must be set to `false`. If set to `true` when calling this API, the API call will fail and an error message is received. Defaults to `true`
	Enabled pulumi.BoolPtrInput
	// An ID that is used to identify the cleanup policy. A minimum of three characters is required and can include letters, numbers, underscore and hyphen.
	Key pulumi.StringInput
	// This attribute is used only for project-level cleanup policies, it is not used for global-level policies. When specified, the policy will be scoped to the specified project. Note: The policy `key` must start with this project key value as a prefix (e.g., if `projectKey` is `"myproj"`, the `key` should be `"myproj-policy-name"`).
	ProjectKey     pulumi.StringPtrInput
	SearchCriteria PackageCleanupPolicySearchCriteriaInput
	// A true value means that when this policy is executed, packages will be permanently deleted. false means that when the policy is executed packages will be deleted to the Trash Can. Defaults to `false`.
	SkipTrashcan pulumi.BoolPtrInput
}

func (PackageCleanupPolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*packageCleanupPolicyArgs)(nil)).Elem()
}

type PackageCleanupPolicyInput interface {
	pulumi.Input

	ToPackageCleanupPolicyOutput() PackageCleanupPolicyOutput
	ToPackageCleanupPolicyOutputWithContext(ctx context.Context) PackageCleanupPolicyOutput
}

func (*PackageCleanupPolicy) ElementType() reflect.Type {
	return reflect.TypeOf((**PackageCleanupPolicy)(nil)).Elem()
}

func (i *PackageCleanupPolicy) ToPackageCleanupPolicyOutput() PackageCleanupPolicyOutput {
	return i.ToPackageCleanupPolicyOutputWithContext(context.Background())
}

func (i *PackageCleanupPolicy) ToPackageCleanupPolicyOutputWithContext(ctx context.Context) PackageCleanupPolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PackageCleanupPolicyOutput)
}

// PackageCleanupPolicyArrayInput is an input type that accepts PackageCleanupPolicyArray and PackageCleanupPolicyArrayOutput values.
// You can construct a concrete instance of `PackageCleanupPolicyArrayInput` via:
//
//	PackageCleanupPolicyArray{ PackageCleanupPolicyArgs{...} }
type PackageCleanupPolicyArrayInput interface {
	pulumi.Input

	ToPackageCleanupPolicyArrayOutput() PackageCleanupPolicyArrayOutput
	ToPackageCleanupPolicyArrayOutputWithContext(context.Context) PackageCleanupPolicyArrayOutput
}

type PackageCleanupPolicyArray []PackageCleanupPolicyInput

func (PackageCleanupPolicyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*PackageCleanupPolicy)(nil)).Elem()
}

func (i PackageCleanupPolicyArray) ToPackageCleanupPolicyArrayOutput() PackageCleanupPolicyArrayOutput {
	return i.ToPackageCleanupPolicyArrayOutputWithContext(context.Background())
}

func (i PackageCleanupPolicyArray) ToPackageCleanupPolicyArrayOutputWithContext(ctx context.Context) PackageCleanupPolicyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PackageCleanupPolicyArrayOutput)
}

// PackageCleanupPolicyMapInput is an input type that accepts PackageCleanupPolicyMap and PackageCleanupPolicyMapOutput values.
// You can construct a concrete instance of `PackageCleanupPolicyMapInput` via:
//
//	PackageCleanupPolicyMap{ "key": PackageCleanupPolicyArgs{...} }
type PackageCleanupPolicyMapInput interface {
	pulumi.Input

	ToPackageCleanupPolicyMapOutput() PackageCleanupPolicyMapOutput
	ToPackageCleanupPolicyMapOutputWithContext(context.Context) PackageCleanupPolicyMapOutput
}

type PackageCleanupPolicyMap map[string]PackageCleanupPolicyInput

func (PackageCleanupPolicyMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*PackageCleanupPolicy)(nil)).Elem()
}

func (i PackageCleanupPolicyMap) ToPackageCleanupPolicyMapOutput() PackageCleanupPolicyMapOutput {
	return i.ToPackageCleanupPolicyMapOutputWithContext(context.Background())
}

func (i PackageCleanupPolicyMap) ToPackageCleanupPolicyMapOutputWithContext(ctx context.Context) PackageCleanupPolicyMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PackageCleanupPolicyMapOutput)
}

type PackageCleanupPolicyOutput struct{ *pulumi.OutputState }

func (PackageCleanupPolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PackageCleanupPolicy)(nil)).Elem()
}

func (o PackageCleanupPolicyOutput) ToPackageCleanupPolicyOutput() PackageCleanupPolicyOutput {
	return o
}

func (o PackageCleanupPolicyOutput) ToPackageCleanupPolicyOutputWithContext(ctx context.Context) PackageCleanupPolicyOutput {
	return o
}

// The cron expression that determines when the policy is run, However if left empty the policy will not run automatically and can only be triggered manually.
func (o PackageCleanupPolicyOutput) CronExpression() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PackageCleanupPolicy) pulumi.StringPtrOutput { return v.CronExpression }).(pulumi.StringPtrOutput)
}

func (o PackageCleanupPolicyOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PackageCleanupPolicy) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// The maximum duration (in minutes) for policy execution, after which the policy will stop running even if not completed. While setting a maximum run duration for a policy is useful for adhering to a strict cleanup schedule, it can cause the policy to stop before completion.
func (o PackageCleanupPolicyOutput) DurationInMinutes() pulumi.IntOutput {
	return o.ApplyT(func(v *PackageCleanupPolicy) pulumi.IntOutput { return v.DurationInMinutes }).(pulumi.IntOutput)
}

// A cleanup policy must be created inactive. But if used it must be set to `false`. If set to `true` when calling this API, the API call will fail and an error message is received. Defaults to `true`
func (o PackageCleanupPolicyOutput) Enabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *PackageCleanupPolicy) pulumi.BoolOutput { return v.Enabled }).(pulumi.BoolOutput)
}

// An ID that is used to identify the cleanup policy. A minimum of three characters is required and can include letters, numbers, underscore and hyphen.
func (o PackageCleanupPolicyOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v *PackageCleanupPolicy) pulumi.StringOutput { return v.Key }).(pulumi.StringOutput)
}

// This attribute is used only for project-level cleanup policies, it is not used for global-level policies. When specified, the policy will be scoped to the specified project. Note: The policy `key` must start with this project key value as a prefix (e.g., if `projectKey` is `"myproj"`, the `key` should be `"myproj-policy-name"`).
func (o PackageCleanupPolicyOutput) ProjectKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PackageCleanupPolicy) pulumi.StringPtrOutput { return v.ProjectKey }).(pulumi.StringPtrOutput)
}

func (o PackageCleanupPolicyOutput) SearchCriteria() PackageCleanupPolicySearchCriteriaOutput {
	return o.ApplyT(func(v *PackageCleanupPolicy) PackageCleanupPolicySearchCriteriaOutput { return v.SearchCriteria }).(PackageCleanupPolicySearchCriteriaOutput)
}

// A true value means that when this policy is executed, packages will be permanently deleted. false means that when the policy is executed packages will be deleted to the Trash Can. Defaults to `false`.
func (o PackageCleanupPolicyOutput) SkipTrashcan() pulumi.BoolOutput {
	return o.ApplyT(func(v *PackageCleanupPolicy) pulumi.BoolOutput { return v.SkipTrashcan }).(pulumi.BoolOutput)
}

type PackageCleanupPolicyArrayOutput struct{ *pulumi.OutputState }

func (PackageCleanupPolicyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*PackageCleanupPolicy)(nil)).Elem()
}

func (o PackageCleanupPolicyArrayOutput) ToPackageCleanupPolicyArrayOutput() PackageCleanupPolicyArrayOutput {
	return o
}

func (o PackageCleanupPolicyArrayOutput) ToPackageCleanupPolicyArrayOutputWithContext(ctx context.Context) PackageCleanupPolicyArrayOutput {
	return o
}

func (o PackageCleanupPolicyArrayOutput) Index(i pulumi.IntInput) PackageCleanupPolicyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *PackageCleanupPolicy {
		return vs[0].([]*PackageCleanupPolicy)[vs[1].(int)]
	}).(PackageCleanupPolicyOutput)
}

type PackageCleanupPolicyMapOutput struct{ *pulumi.OutputState }

func (PackageCleanupPolicyMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*PackageCleanupPolicy)(nil)).Elem()
}

func (o PackageCleanupPolicyMapOutput) ToPackageCleanupPolicyMapOutput() PackageCleanupPolicyMapOutput {
	return o
}

func (o PackageCleanupPolicyMapOutput) ToPackageCleanupPolicyMapOutputWithContext(ctx context.Context) PackageCleanupPolicyMapOutput {
	return o
}

func (o PackageCleanupPolicyMapOutput) MapIndex(k pulumi.StringInput) PackageCleanupPolicyOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *PackageCleanupPolicy {
		return vs[0].(map[string]*PackageCleanupPolicy)[vs[1].(string)]
	}).(PackageCleanupPolicyOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*PackageCleanupPolicyInput)(nil)).Elem(), &PackageCleanupPolicy{})
	pulumi.RegisterInputType(reflect.TypeOf((*PackageCleanupPolicyArrayInput)(nil)).Elem(), PackageCleanupPolicyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*PackageCleanupPolicyMapInput)(nil)).Elem(), PackageCleanupPolicyMap{})
	pulumi.RegisterOutputType(PackageCleanupPolicyOutput{})
	pulumi.RegisterOutputType(PackageCleanupPolicyArrayOutput{})
	pulumi.RegisterOutputType(PackageCleanupPolicyMapOutput{})
}
