// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package artifactory

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-artifactory/sdk/v6/go/artifactory/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Provides a local repository replication resource, also referred to as Artifactory push replication. This can be used to create and manage Artifactory local repository replications using [Multi-push Replication API](https://www.jfrog.com/confluence/display/JFROG/Artifactory+REST+API#ArtifactoryRESTAPI-CreateorReplaceLocalMulti-pushReplication).
// Push replication is used to synchronize Local Repositories, and is implemented by the Artifactory server on the near end invoking a synchronization of artifacts to the far end.
// See the [Official Documentation](https://www.jfrog.com/confluence/display/JFROG/Repository+Replication#RepositoryReplication-PushReplication).
// This resource replaces `PushReplication` and used to create a replication of one local repository to multiple repositories on the remote server.
//
// > This resource requires Artifactory Enterprise license. Use `LocalRepositorySingleReplication` with other licenses.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"fmt"
//
//	"github.com/pulumi/pulumi-artifactory/sdk/v6/go/artifactory"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi/config"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			cfg := config.New(ctx, "")
//			artifactoryUrl := cfg.Require("artifactoryUrl")
//			artifactoryUsername := cfg.Require("artifactoryUsername")
//			artifactoryPassword := cfg.Require("artifactoryPassword")
//			providerTestSource, err := artifactory.NewLocalMavenRepository(ctx, "providerTestSource", &artifactory.LocalMavenRepositoryArgs{
//				Key: pulumi.String("provider_test_source"),
//			})
//			if err != nil {
//				return err
//			}
//			providerTestDest, err := artifactory.NewLocalMavenRepository(ctx, "providerTestDest", &artifactory.LocalMavenRepositoryArgs{
//				Key: pulumi.String("provider_test_dest"),
//			})
//			if err != nil {
//				return err
//			}
//			providerTestDest1, err := artifactory.NewLocalMavenRepository(ctx, "providerTestDest1", &artifactory.LocalMavenRepositoryArgs{
//				Key: pulumi.String("provider_test_dest1"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = artifactory.NewLocalRepositoryMultiReplication(ctx, "foo-rep", &artifactory.LocalRepositoryMultiReplicationArgs{
//				RepoKey:                providerTestSource.Key,
//				CronExp:                pulumi.String("0 0 * * * ?"),
//				EnableEventReplication: pulumi.Bool(true),
//				Replications: artifactory.LocalRepositoryMultiReplicationReplicationArray{
//					&artifactory.LocalRepositoryMultiReplicationReplicationArgs{
//						Url: providerTestDest.Key.ApplyT(func(key string) (string, error) {
//							return fmt.Sprintf("%v/artifactory/%v", artifactoryUrl, key), nil
//						}).(pulumi.StringOutput),
//						Username: pulumi.String("$var.artifactory_username"),
//						Password: pulumi.String("$var.artifactory_password"),
//						Enabled:  pulumi.Bool(true),
//					},
//					&artifactory.LocalRepositoryMultiReplicationReplicationArgs{
//						Url: providerTestDest1.Key.ApplyT(func(key string) (string, error) {
//							return fmt.Sprintf("%v/artifactory/%v", artifactoryUrl, key), nil
//						}).(pulumi.StringOutput),
//						Username: pulumi.String("$var.artifactory_username"),
//						Password: pulumi.String("$var.artifactory_password"),
//						Enabled:  pulumi.Bool(true),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Push replication configs can be imported using their repo key, e.g.
//
// ```sh
//
//	$ pulumi import artifactory:index/localRepositoryMultiReplication:LocalRepositoryMultiReplication foo-rep provider_test_source
//
// ```
type LocalRepositoryMultiReplication struct {
	pulumi.CustomResourceState

	// A valid CRON expression that you can use to control replication frequency. Eg: `0 0 12 * * ? *`, `0 0 2 ? * MON-SAT *`. Note: use 6 or 7 parts format - Seconds, Minutes Hours, Day Of Month, Month, Day Of Week, Year (optional). Specifying both a day-of-week AND a day-of-month parameter is not supported. One of them should be replaced by `?`. Incorrect: `* 5,7,9 14/2 * * WED,SAT *`, correct: `* 5,7,9 14/2 ? * WED,SAT *`. See details in [Cron Trigger Tutorial](https://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html).
	CronExp pulumi.StringOutput `pulumi:"cronExp"`
	// When set, each event will trigger replication of the artifacts changed in this event. This can be any type of event on artifact, e.g. add, deleted or property change. Default value is `false`.
	EnableEventReplication pulumi.BoolPtrOutput `pulumi:"enableEventReplication"`
	// List of replications minimum 1 element.
	Replications LocalRepositoryMultiReplicationReplicationArrayOutput `pulumi:"replications"`
	// Repository name.
	RepoKey pulumi.StringOutput `pulumi:"repoKey"`
}

// NewLocalRepositoryMultiReplication registers a new resource with the given unique name, arguments, and options.
func NewLocalRepositoryMultiReplication(ctx *pulumi.Context,
	name string, args *LocalRepositoryMultiReplicationArgs, opts ...pulumi.ResourceOption) (*LocalRepositoryMultiReplication, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.CronExp == nil {
		return nil, errors.New("invalid value for required argument 'CronExp'")
	}
	if args.RepoKey == nil {
		return nil, errors.New("invalid value for required argument 'RepoKey'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource LocalRepositoryMultiReplication
	err := ctx.RegisterResource("artifactory:index/localRepositoryMultiReplication:LocalRepositoryMultiReplication", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetLocalRepositoryMultiReplication gets an existing LocalRepositoryMultiReplication resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetLocalRepositoryMultiReplication(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *LocalRepositoryMultiReplicationState, opts ...pulumi.ResourceOption) (*LocalRepositoryMultiReplication, error) {
	var resource LocalRepositoryMultiReplication
	err := ctx.ReadResource("artifactory:index/localRepositoryMultiReplication:LocalRepositoryMultiReplication", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering LocalRepositoryMultiReplication resources.
type localRepositoryMultiReplicationState struct {
	// A valid CRON expression that you can use to control replication frequency. Eg: `0 0 12 * * ? *`, `0 0 2 ? * MON-SAT *`. Note: use 6 or 7 parts format - Seconds, Minutes Hours, Day Of Month, Month, Day Of Week, Year (optional). Specifying both a day-of-week AND a day-of-month parameter is not supported. One of them should be replaced by `?`. Incorrect: `* 5,7,9 14/2 * * WED,SAT *`, correct: `* 5,7,9 14/2 ? * WED,SAT *`. See details in [Cron Trigger Tutorial](https://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html).
	CronExp *string `pulumi:"cronExp"`
	// When set, each event will trigger replication of the artifacts changed in this event. This can be any type of event on artifact, e.g. add, deleted or property change. Default value is `false`.
	EnableEventReplication *bool `pulumi:"enableEventReplication"`
	// List of replications minimum 1 element.
	Replications []LocalRepositoryMultiReplicationReplication `pulumi:"replications"`
	// Repository name.
	RepoKey *string `pulumi:"repoKey"`
}

type LocalRepositoryMultiReplicationState struct {
	// A valid CRON expression that you can use to control replication frequency. Eg: `0 0 12 * * ? *`, `0 0 2 ? * MON-SAT *`. Note: use 6 or 7 parts format - Seconds, Minutes Hours, Day Of Month, Month, Day Of Week, Year (optional). Specifying both a day-of-week AND a day-of-month parameter is not supported. One of them should be replaced by `?`. Incorrect: `* 5,7,9 14/2 * * WED,SAT *`, correct: `* 5,7,9 14/2 ? * WED,SAT *`. See details in [Cron Trigger Tutorial](https://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html).
	CronExp pulumi.StringPtrInput
	// When set, each event will trigger replication of the artifacts changed in this event. This can be any type of event on artifact, e.g. add, deleted or property change. Default value is `false`.
	EnableEventReplication pulumi.BoolPtrInput
	// List of replications minimum 1 element.
	Replications LocalRepositoryMultiReplicationReplicationArrayInput
	// Repository name.
	RepoKey pulumi.StringPtrInput
}

func (LocalRepositoryMultiReplicationState) ElementType() reflect.Type {
	return reflect.TypeOf((*localRepositoryMultiReplicationState)(nil)).Elem()
}

type localRepositoryMultiReplicationArgs struct {
	// A valid CRON expression that you can use to control replication frequency. Eg: `0 0 12 * * ? *`, `0 0 2 ? * MON-SAT *`. Note: use 6 or 7 parts format - Seconds, Minutes Hours, Day Of Month, Month, Day Of Week, Year (optional). Specifying both a day-of-week AND a day-of-month parameter is not supported. One of them should be replaced by `?`. Incorrect: `* 5,7,9 14/2 * * WED,SAT *`, correct: `* 5,7,9 14/2 ? * WED,SAT *`. See details in [Cron Trigger Tutorial](https://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html).
	CronExp string `pulumi:"cronExp"`
	// When set, each event will trigger replication of the artifacts changed in this event. This can be any type of event on artifact, e.g. add, deleted or property change. Default value is `false`.
	EnableEventReplication *bool `pulumi:"enableEventReplication"`
	// List of replications minimum 1 element.
	Replications []LocalRepositoryMultiReplicationReplication `pulumi:"replications"`
	// Repository name.
	RepoKey string `pulumi:"repoKey"`
}

// The set of arguments for constructing a LocalRepositoryMultiReplication resource.
type LocalRepositoryMultiReplicationArgs struct {
	// A valid CRON expression that you can use to control replication frequency. Eg: `0 0 12 * * ? *`, `0 0 2 ? * MON-SAT *`. Note: use 6 or 7 parts format - Seconds, Minutes Hours, Day Of Month, Month, Day Of Week, Year (optional). Specifying both a day-of-week AND a day-of-month parameter is not supported. One of them should be replaced by `?`. Incorrect: `* 5,7,9 14/2 * * WED,SAT *`, correct: `* 5,7,9 14/2 ? * WED,SAT *`. See details in [Cron Trigger Tutorial](https://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html).
	CronExp pulumi.StringInput
	// When set, each event will trigger replication of the artifacts changed in this event. This can be any type of event on artifact, e.g. add, deleted or property change. Default value is `false`.
	EnableEventReplication pulumi.BoolPtrInput
	// List of replications minimum 1 element.
	Replications LocalRepositoryMultiReplicationReplicationArrayInput
	// Repository name.
	RepoKey pulumi.StringInput
}

func (LocalRepositoryMultiReplicationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*localRepositoryMultiReplicationArgs)(nil)).Elem()
}

type LocalRepositoryMultiReplicationInput interface {
	pulumi.Input

	ToLocalRepositoryMultiReplicationOutput() LocalRepositoryMultiReplicationOutput
	ToLocalRepositoryMultiReplicationOutputWithContext(ctx context.Context) LocalRepositoryMultiReplicationOutput
}

func (*LocalRepositoryMultiReplication) ElementType() reflect.Type {
	return reflect.TypeOf((**LocalRepositoryMultiReplication)(nil)).Elem()
}

func (i *LocalRepositoryMultiReplication) ToLocalRepositoryMultiReplicationOutput() LocalRepositoryMultiReplicationOutput {
	return i.ToLocalRepositoryMultiReplicationOutputWithContext(context.Background())
}

func (i *LocalRepositoryMultiReplication) ToLocalRepositoryMultiReplicationOutputWithContext(ctx context.Context) LocalRepositoryMultiReplicationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LocalRepositoryMultiReplicationOutput)
}

// LocalRepositoryMultiReplicationArrayInput is an input type that accepts LocalRepositoryMultiReplicationArray and LocalRepositoryMultiReplicationArrayOutput values.
// You can construct a concrete instance of `LocalRepositoryMultiReplicationArrayInput` via:
//
//	LocalRepositoryMultiReplicationArray{ LocalRepositoryMultiReplicationArgs{...} }
type LocalRepositoryMultiReplicationArrayInput interface {
	pulumi.Input

	ToLocalRepositoryMultiReplicationArrayOutput() LocalRepositoryMultiReplicationArrayOutput
	ToLocalRepositoryMultiReplicationArrayOutputWithContext(context.Context) LocalRepositoryMultiReplicationArrayOutput
}

type LocalRepositoryMultiReplicationArray []LocalRepositoryMultiReplicationInput

func (LocalRepositoryMultiReplicationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*LocalRepositoryMultiReplication)(nil)).Elem()
}

func (i LocalRepositoryMultiReplicationArray) ToLocalRepositoryMultiReplicationArrayOutput() LocalRepositoryMultiReplicationArrayOutput {
	return i.ToLocalRepositoryMultiReplicationArrayOutputWithContext(context.Background())
}

func (i LocalRepositoryMultiReplicationArray) ToLocalRepositoryMultiReplicationArrayOutputWithContext(ctx context.Context) LocalRepositoryMultiReplicationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LocalRepositoryMultiReplicationArrayOutput)
}

// LocalRepositoryMultiReplicationMapInput is an input type that accepts LocalRepositoryMultiReplicationMap and LocalRepositoryMultiReplicationMapOutput values.
// You can construct a concrete instance of `LocalRepositoryMultiReplicationMapInput` via:
//
//	LocalRepositoryMultiReplicationMap{ "key": LocalRepositoryMultiReplicationArgs{...} }
type LocalRepositoryMultiReplicationMapInput interface {
	pulumi.Input

	ToLocalRepositoryMultiReplicationMapOutput() LocalRepositoryMultiReplicationMapOutput
	ToLocalRepositoryMultiReplicationMapOutputWithContext(context.Context) LocalRepositoryMultiReplicationMapOutput
}

type LocalRepositoryMultiReplicationMap map[string]LocalRepositoryMultiReplicationInput

func (LocalRepositoryMultiReplicationMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*LocalRepositoryMultiReplication)(nil)).Elem()
}

func (i LocalRepositoryMultiReplicationMap) ToLocalRepositoryMultiReplicationMapOutput() LocalRepositoryMultiReplicationMapOutput {
	return i.ToLocalRepositoryMultiReplicationMapOutputWithContext(context.Background())
}

func (i LocalRepositoryMultiReplicationMap) ToLocalRepositoryMultiReplicationMapOutputWithContext(ctx context.Context) LocalRepositoryMultiReplicationMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LocalRepositoryMultiReplicationMapOutput)
}

type LocalRepositoryMultiReplicationOutput struct{ *pulumi.OutputState }

func (LocalRepositoryMultiReplicationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LocalRepositoryMultiReplication)(nil)).Elem()
}

func (o LocalRepositoryMultiReplicationOutput) ToLocalRepositoryMultiReplicationOutput() LocalRepositoryMultiReplicationOutput {
	return o
}

func (o LocalRepositoryMultiReplicationOutput) ToLocalRepositoryMultiReplicationOutputWithContext(ctx context.Context) LocalRepositoryMultiReplicationOutput {
	return o
}

// A valid CRON expression that you can use to control replication frequency. Eg: `0 0 12 * * ? *`, `0 0 2 ? * MON-SAT *`. Note: use 6 or 7 parts format - Seconds, Minutes Hours, Day Of Month, Month, Day Of Week, Year (optional). Specifying both a day-of-week AND a day-of-month parameter is not supported. One of them should be replaced by `?`. Incorrect: `* 5,7,9 14/2 * * WED,SAT *`, correct: `* 5,7,9 14/2 ? * WED,SAT *`. See details in [Cron Trigger Tutorial](https://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html).
func (o LocalRepositoryMultiReplicationOutput) CronExp() pulumi.StringOutput {
	return o.ApplyT(func(v *LocalRepositoryMultiReplication) pulumi.StringOutput { return v.CronExp }).(pulumi.StringOutput)
}

// When set, each event will trigger replication of the artifacts changed in this event. This can be any type of event on artifact, e.g. add, deleted or property change. Default value is `false`.
func (o LocalRepositoryMultiReplicationOutput) EnableEventReplication() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *LocalRepositoryMultiReplication) pulumi.BoolPtrOutput { return v.EnableEventReplication }).(pulumi.BoolPtrOutput)
}

// List of replications minimum 1 element.
func (o LocalRepositoryMultiReplicationOutput) Replications() LocalRepositoryMultiReplicationReplicationArrayOutput {
	return o.ApplyT(func(v *LocalRepositoryMultiReplication) LocalRepositoryMultiReplicationReplicationArrayOutput {
		return v.Replications
	}).(LocalRepositoryMultiReplicationReplicationArrayOutput)
}

// Repository name.
func (o LocalRepositoryMultiReplicationOutput) RepoKey() pulumi.StringOutput {
	return o.ApplyT(func(v *LocalRepositoryMultiReplication) pulumi.StringOutput { return v.RepoKey }).(pulumi.StringOutput)
}

type LocalRepositoryMultiReplicationArrayOutput struct{ *pulumi.OutputState }

func (LocalRepositoryMultiReplicationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*LocalRepositoryMultiReplication)(nil)).Elem()
}

func (o LocalRepositoryMultiReplicationArrayOutput) ToLocalRepositoryMultiReplicationArrayOutput() LocalRepositoryMultiReplicationArrayOutput {
	return o
}

func (o LocalRepositoryMultiReplicationArrayOutput) ToLocalRepositoryMultiReplicationArrayOutputWithContext(ctx context.Context) LocalRepositoryMultiReplicationArrayOutput {
	return o
}

func (o LocalRepositoryMultiReplicationArrayOutput) Index(i pulumi.IntInput) LocalRepositoryMultiReplicationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *LocalRepositoryMultiReplication {
		return vs[0].([]*LocalRepositoryMultiReplication)[vs[1].(int)]
	}).(LocalRepositoryMultiReplicationOutput)
}

type LocalRepositoryMultiReplicationMapOutput struct{ *pulumi.OutputState }

func (LocalRepositoryMultiReplicationMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*LocalRepositoryMultiReplication)(nil)).Elem()
}

func (o LocalRepositoryMultiReplicationMapOutput) ToLocalRepositoryMultiReplicationMapOutput() LocalRepositoryMultiReplicationMapOutput {
	return o
}

func (o LocalRepositoryMultiReplicationMapOutput) ToLocalRepositoryMultiReplicationMapOutputWithContext(ctx context.Context) LocalRepositoryMultiReplicationMapOutput {
	return o
}

func (o LocalRepositoryMultiReplicationMapOutput) MapIndex(k pulumi.StringInput) LocalRepositoryMultiReplicationOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *LocalRepositoryMultiReplication {
		return vs[0].(map[string]*LocalRepositoryMultiReplication)[vs[1].(string)]
	}).(LocalRepositoryMultiReplicationOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*LocalRepositoryMultiReplicationInput)(nil)).Elem(), &LocalRepositoryMultiReplication{})
	pulumi.RegisterInputType(reflect.TypeOf((*LocalRepositoryMultiReplicationArrayInput)(nil)).Elem(), LocalRepositoryMultiReplicationArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*LocalRepositoryMultiReplicationMapInput)(nil)).Elem(), LocalRepositoryMultiReplicationMap{})
	pulumi.RegisterOutputType(LocalRepositoryMultiReplicationOutput{})
	pulumi.RegisterOutputType(LocalRepositoryMultiReplicationArrayOutput{})
	pulumi.RegisterOutputType(LocalRepositoryMultiReplicationMapOutput{})
}
