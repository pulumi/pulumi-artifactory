// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.artifactory;

import com.pulumi.artifactory.ArchivePolicyArgs;
import com.pulumi.artifactory.Utilities;
import com.pulumi.artifactory.inputs.ArchivePolicyState;
import com.pulumi.artifactory.outputs.ArchivePolicySearchCriteria;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * Provides an Artifactory Archive Policy resource. This resource enable system administrators to define and customize policies based on specific criteria for removing unused binaries from across their JFrog platform. See [Retention Policies](https://jfrog.com/help/r/jfrog-platform-administration-documentation/archive) for more details.
 * 
 * ## Example Usage
 * 
 * ### Time-based Archive Policy (Days)
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.artifactory.ArchivePolicy;
 * import com.pulumi.artifactory.ArchivePolicyArgs;
 * import com.pulumi.artifactory.inputs.ArchivePolicySearchCriteriaArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var my_archive_policy = new ArchivePolicy("my-archive-policy", ArchivePolicyArgs.builder()
 *             .key("my-archive-policy")
 *             .description("My archive policy")
 *             .cronExpression("0 0 2 ? * MON-SAT *")
 *             .durationInMinutes(60)
 *             .enabled(true)
 *             .skipTrashcan(false)
 *             .searchCriteria(ArchivePolicySearchCriteriaArgs.builder()
 *                 .packageTypes("docker")
 *                 .repos("**")
 *                 .includeAllProjects(true)
 *                 .includedProjects()
 *                 .includedPackages("**")
 *                 .excludedPackages("com/jfrog/latest")
 *                 .createdBeforeInDays(30)
 *                 .lastDownloadedBeforeInDays(60)
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ### Version-based Archive Policy
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.artifactory.ArchivePolicy;
 * import com.pulumi.artifactory.ArchivePolicyArgs;
 * import com.pulumi.artifactory.inputs.ArchivePolicySearchCriteriaArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var my_version_policy = new ArchivePolicy("my-version-policy", ArchivePolicyArgs.builder()
 *             .key("my-version-policy")
 *             .description("Keep only latest versions")
 *             .cronExpression("0 0 2 ? * MON-SAT *")
 *             .durationInMinutes(60)
 *             .enabled(true)
 *             .skipTrashcan(false)
 *             .searchCriteria(ArchivePolicySearchCriteriaArgs.builder()
 *                 .packageTypes("docker")
 *                 .repos("**")
 *                 .includeAllProjects(true)
 *                 .includedProjects()
 *                 .includedPackages("**")
 *                 .excludedPackages("com/jfrog/latest")
 *                 .keepLastNVersions(5)
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ### Properties-based Archive Policy
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.artifactory.ArchivePolicy;
 * import com.pulumi.artifactory.ArchivePolicyArgs;
 * import com.pulumi.artifactory.inputs.ArchivePolicySearchCriteriaArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var my_properties_policy = new ArchivePolicy("my-properties-policy", ArchivePolicyArgs.builder()
 *             .key("my-properties-policy")
 *             .description("Archive based on properties")
 *             .cronExpression("0 0 2 ? * MON-SAT *")
 *             .durationInMinutes(60)
 *             .enabled(true)
 *             .skipTrashcan(false)
 *             .searchCriteria(ArchivePolicySearchCriteriaArgs.builder()
 *                 .packageTypes("docker")
 *                 .repos("**")
 *                 .includeAllProjects(true)
 *                 .includedProjects()
 *                 .includedPackages("**")
 *                 .excludedPackages("com/jfrog/latest")
 *                 .includedProperties(Map.of("build.name", "my-app"))
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * ### Using Variables for Condition Fields
 * 
 * You can use Terraform variables for condition fields (`createdBeforeInDays`, `lastDownloadedBeforeInDays`, `createdBeforeInMonths`, `lastDownloadedBeforeInMonths`, `keepLastNVersions`, `includedProperties`) and `durationInMinutes`. The validator will skip validation when values are unknown (variables), allowing `terraform validate` to pass without requiring variable values.
 * 
 * **Example with variables:**
 * 
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.artifactory.ArchivePolicy;
 * import com.pulumi.artifactory.ArchivePolicyArgs;
 * import com.pulumi.artifactory.inputs.ArchivePolicySearchCriteriaArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         final var config = ctx.config();
 *         final var archivePolicyLastDownloadedBeforeInDays = config.get("archivePolicyLastDownloadedBeforeInDays").orElse(30);
 *         final var archivePolicyDurationInMinutes = config.get("archivePolicyDurationInMinutes").orElse(60);
 *         var my_archive_policy = new ArchivePolicy("my-archive-policy", ArchivePolicyArgs.builder()
 *             .key("my-archive-policy")
 *             .description("My archive policy with variables")
 *             .cronExpression("0 0 2 ? * MON-SAT *")
 *             .durationInMinutes(archivePolicyDurationInMinutes)
 *             .enabled(true)
 *             .skipTrashcan(false)
 *             .searchCriteria(ArchivePolicySearchCriteriaArgs.builder()
 *                 .packageTypes(                
 *                     "docker",
 *                     "generic",
 *                     "helm",
 *                     "helmoci",
 *                     "nuget",
 *                     "terraform")
 *                 .repos("**")
 *                 .includeAllProjects(false)
 *                 .includedProjects("default")
 *                 .includedPackages("**")
 *                 .excludedPackages("com/jfrog/latest")
 *                 .lastDownloadedBeforeInDays(archivePolicyLastDownloadedBeforeInDays)
 *                 .build())
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * 
 * **Important Notes:**
 * - Variables with default values allow `terraform validate` to pass without requiring variable values
 * - Variables without default values will require values to be provided during `pulumi preview` or `pulumi up`
 * - The validator automatically skips validation when condition field values are unknown (variables), preventing false validation errors during `terraform validate`
 * 
 * ## Validation Rules
 * 
 * The archive policy resource enforces the following validation rules:
 * 
 * 1. **Condition Types**: A policy must use exactly one of the following condition types:
 *    - Time-based conditions (`days-based`)
 *    - Version-based condition (`keepLastNVersions`)
 *    - Properties-based condition (`includedProperties`)
 * 
 * 2. **Mutual Exclusivity**: Cannot use multiple condition types together.
 * 
 * 3. **Zero Values**: Time-based and version-based conditions must have values greater than 0.
 * 
 * 4. **Days vs Months**: Cannot use both days-based conditions (`createdBeforeInDays`, `lastDownloadedBeforeInDays`) and months-based conditions (`createdBeforeInMonths`, `lastDownloadedBeforeInMonths`) together.
 * 
 * 5. **Properties Validation**: Properties-based conditions must have exactly one key with exactly one string value.
 * 
 * 6. **Project Configuration**: When `includeAllProjects` is set to `true`, the `includedProjects` field can be empty array. When `includeAllProjects` is `false`, `includedProjects` must contain at least one project key.
 * 
 * ## Supported Package Types
 * 
 * The following package types are supported: alpine, ansible, cargo, chef, cocoapods, composer, conan, conda, debian, docker, gems, generic, go, gradle, helm, helmoci, huggingfaceml, maven, npm, nuget, oci, opkg, puppet, pypi, sbt, swift, terraform, terraformbackend, vagrant, yum.
 * 
 * ## Version Compatibility
 * 
 * - The `createdBeforeInDays` and `lastDownloadedBeforeInDays` attributes are only supported in Artifactory 7.111.2 and later. For earlier versions, use `createdBeforeInMonths` and `lastDownloadedBeforeInMonths`.
 * 
 * ## Import
 * 
 * ```sh
 * $ pulumi import artifactory:index/archivePolicy:ArchivePolicy my-archive-policy my-policy
 * 
 * $ pulumi import artifactory:index/archivePolicy:ArchivePolicy my-archive-policy my-policy:myproj
 * ```
 * 
 */
@ResourceType(type="artifactory:index/archivePolicy:ArchivePolicy")
public class ArchivePolicy extends com.pulumi.resources.CustomResource {
    /**
     * The cron expression determines when the policy is run. This parameter is not mandatory, however if left empty the policy will not run automatically and can only be triggered manually.
     * 
     */
    @Export(name="cronExpression", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> cronExpression;

    /**
     * @return The cron expression determines when the policy is run. This parameter is not mandatory, however if left empty the policy will not run automatically and can only be triggered manually.
     * 
     */
    public Output<Optional<String>> cronExpression() {
        return Codegen.optional(this.cronExpression);
    }
    @Export(name="description", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> description;

    public Output<Optional<String>> description() {
        return Codegen.optional(this.description);
    }
    /**
     * The maximum duration (in minutes) for policy execution, after which the policy will stop running even if not completed. While setting a maximum run duration for a policy is useful for adhering to a strict archive V2 schedule, it can cause the policy to stop before completion.
     * 
     */
    @Export(name="durationInMinutes", refs={Integer.class}, tree="[0]")
    private Output<Integer> durationInMinutes;

    /**
     * @return The maximum duration (in minutes) for policy execution, after which the policy will stop running even if not completed. While setting a maximum run duration for a policy is useful for adhering to a strict archive V2 schedule, it can cause the policy to stop before completion.
     * 
     */
    public Output<Integer> durationInMinutes() {
        return this.durationInMinutes;
    }
    /**
     * Enables or disabled the package cleanup policy. This allows the user to run the policy manually. If a policy has a valid cron expression, then it will be scheduled for execution based on it. If a policy is disabled, its future executions will be unscheduled. Defaults to `true`
     * 
     */
    @Export(name="enabled", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> enabled;

    /**
     * @return Enables or disabled the package cleanup policy. This allows the user to run the policy manually. If a policy has a valid cron expression, then it will be scheduled for execution based on it. If a policy is disabled, its future executions will be unscheduled. Defaults to `true`
     * 
     */
    public Output<Boolean> enabled() {
        return this.enabled;
    }
    /**
     * An ID that is used to identify the archive policy. A minimum of three characters is required and can include letters, numbers, underscore and hyphen.
     * 
     */
    @Export(name="key", refs={String.class}, tree="[0]")
    private Output<String> key;

    /**
     * @return An ID that is used to identify the archive policy. A minimum of three characters is required and can include letters, numbers, underscore and hyphen.
     * 
     */
    public Output<String> key() {
        return this.key;
    }
    /**
     * This attribute is used only for project-level archive V2 policies, it is not used for global-level policies.
     * 
     */
    @Export(name="projectKey", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> projectKey;

    /**
     * @return This attribute is used only for project-level archive V2 policies, it is not used for global-level policies.
     * 
     */
    public Output<Optional<String>> projectKey() {
        return Codegen.optional(this.projectKey);
    }
    @Export(name="searchCriteria", refs={ArchivePolicySearchCriteria.class}, tree="[0]")
    private Output<ArchivePolicySearchCriteria> searchCriteria;

    public Output<ArchivePolicySearchCriteria> searchCriteria() {
        return this.searchCriteria;
    }
    /**
     * A `true` value means that when this policy is executed, packages will be permanently deleted. `false` means that when the policy is executed packages will be deleted to the Trash Can. Defaults to `false`.
     * 
     */
    @Export(name="skipTrashcan", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> skipTrashcan;

    /**
     * @return A `true` value means that when this policy is executed, packages will be permanently deleted. `false` means that when the policy is executed packages will be deleted to the Trash Can. Defaults to `false`.
     * 
     */
    public Output<Boolean> skipTrashcan() {
        return this.skipTrashcan;
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public ArchivePolicy(java.lang.String name) {
        this(name, ArchivePolicyArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public ArchivePolicy(java.lang.String name, ArchivePolicyArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public ArchivePolicy(java.lang.String name, ArchivePolicyArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("artifactory:index/archivePolicy:ArchivePolicy", name, makeArgs(args, options), makeResourceOptions(options, Codegen.empty()), false);
    }

    private ArchivePolicy(java.lang.String name, Output<java.lang.String> id, @Nullable ArchivePolicyState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("artifactory:index/archivePolicy:ArchivePolicy", name, state, makeResourceOptions(options, id), false);
    }

    private static ArchivePolicyArgs makeArgs(ArchivePolicyArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        if (options != null && options.getUrn().isPresent()) {
            return null;
        }
        return args == null ? ArchivePolicyArgs.Empty : args;
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<java.lang.String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static ArchivePolicy get(java.lang.String name, Output<java.lang.String> id, @Nullable ArchivePolicyState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new ArchivePolicy(name, id, state, options);
    }
}
